The [blog engine][engine] that this blog is run on was written in Haskell.
Now, blog engines are not particularly complicated applications by any
stretch. Haskell, however, is a bit unique in comparison to the trendy ruby,
python, or php applications of the current day.  Haskell is a *compiled
language*.  Whatever the server runs has to be compiled to the specific
architecture of the server.  It cannot be run as-is with an interpreter.

<!-- Now, blog engines are not particularly complicated applications by any -->
<!-- stretch.  They're only one step above the Pastie Clone and the Todo List, and -->
<!-- if you don't expect to be able to add posts between deploys, are even simpler -->
<!-- in that they may be *completely static* and every page pre-compiled to html -->
<!-- before it even reaches the server. -->

No matter -- Heroku's brilliant [Cedar Stack][cedar] was built from the start
to support things like this.  And by using a well-made buildpack (methods
outlined [here][method1] and [here][method2]), deploying Haskell to Heroku is,
in principle, as straightforward as deploying any other interpreted language.
In principle.

This blog is a Haskell web app of unremarkable complexity and
[reasonable dependencies][dependencies].  However, when deploying using a
build pack, Cedar **times out** while downloading and compiling the app's
dependencies through cabal.  It appears that Cedar apps, as of September 2013,
have a hard-coded timeout of **fifteen minutes** --- any app that takes longer
than fifteen minutes to set up on the server is completely out of luck.

The only solutions, therefore, for an app with enough dependencies as to
require more than fifteen minutes to both download and compile, is to either
play an ugly dance of slowly committing more and more dependencies to force
cabal to install in small bursts and increments, or to compile the app to a
native binary that can be run on Heroku's servers out of the box.

This article is about the second option.

[engine]: https://github.com/mstksg/blog
[cedar]: https://devcenter.heroku.com/articles/cedar
[method1]: http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html#deploying-to-heroku
[method2]: http://blog.begriffs.com/2013/08/deploying-yesod-to-heroku-with-postgres.html
[dependencies]: https://github.com/mstksg/blog/blob/master/blog.cabal#L20-52


<!-- Program?  What's a program? -->
<!-- --------------------------- -->

<!-- Let's jump right to the core of the issue here and get down and dirty, -->
<!-- philosophically. -->

<!-- When you think about writing a program, what do you think of? -->

<!-- You might think of code in a compiled low-level language like C.  You might -->
<!-- think of code in a scripting language, like Python or Ruby.  You might have -->
<!-- even jumped straight to thinking about assembly or machine code. -->

<!-- What do all of these ideas of programming have in common?  In all of these, -->
<!-- you are *writing instructions to manipulate memory*.  This is especially -->
<!-- obvious in assembly...it's somewhat obvious in C (where all memory is -->
<!-- essentially a giant array of bytes, and the program revolves around -->
<!-- manipulating chunks of those bytes at a time).  It's a little less obvious in -->
<!-- a scripting language, but scripting languages can be thought about as a list -->
<!-- of lines for a runtime environment to execute, in order to modify/manipulate -->
<!-- memory. -->

<!-- ### What is it really? -->

<!-- There are some slight issues with this definition of the "idea" of -->
<!-- programming, because in a way it betrays a lot of what we mentally do when we -->
<!-- program.  It betrays the abstractions that we spend so much effort to -->
<!-- carefully craft.  It betrays key principles in modular code or object oriented -->
<!-- programming. -->

<!-- When you work with a data structure, such as a hash table, for example, you -->
<!-- don't actually think about the low-level shuffling of bits for the complex -->
<!-- storage and lookup operations.  When you deal with an object-oriented library, -->
<!-- for example, you make method calls without any care about what memory -->
<!-- shuffling is actually being done. -->

<!-- ### Another thought -->

<!-- I propose that you think about programs not as instructions to manipulate -->
<!-- memory, but as a **language** by which you construct **ideas and concepts** -->
<!-- and structures, and the way those ideas and constructs interact.  A program is -->
<!-- not the manipulation of memory, but rather the manipulation of *ideas*. -->

<!-- So what is compilation?  Compilation is the process of turning ideas into an -->
<!-- "executable" data structure.  As most of us have learned it, compilation is -->
<!-- turning the text file (ideas) into machine code.  But really, is machine code -->
<!-- the "inherent" target of a program?  What about turning the ideas in a text -->
<!-- file into, say...executable javascript code?  What about turning the ideas in -->
<!-- a text file into a screenplay that actors can act out on camera and complete a -->
<!-- computation? -->

<!-- Think hard about "separating" the **ideas/concepts** of coding with a possible -->
<!-- **execution environment** of those ideas.  This is like saying how "ideas" of -->
<!-- human thought can be put into multiple languages.  The idea is an entity in -->
<!-- and of itself, and is not "tied" to a spoken sound representation, or a -->
<!-- particular execution environment. -->

<!-- Another Model -->
<!-- ------------- -->

<!-- In functional languages, everything is a function that returns an answer given -->
<!-- inputs. -->

<!-- So what if our "pure" functions return...instructions? -->

<!-- What about instead of thinking about a program as a list of instructions for a -->
<!-- computer...we thought about a program as a function that **returns** a list of -->
<!-- instructions? -->

<!-- Let's put this thought aside for a bit and imagine a DSL we can embed in Ruby. -->

<!-- ### A simple implementation -->

<!-- Let's say that our DSL in ruby will output some list of instructions.  It'll -->
<!-- be in the form of a list of symbols. -->

<!-- Let's create a sample program in this DSL: -->

<!-- ~~~ruby -->

<!-- def get_and_say_n_times(n) -->
<!--   instruction_list = [] -->
<!--   instruction_list << [:getline] -->
<!--   instruction_list << [:store_result_in, "to_say"] -->
<!--   n.times do -->
<!--     instruction_list << [:print_line, "to_say"] -->
<!--   end -->
<!-- end -->

<!-- get_and_say_n_times(4) -->
<!-- # [ [:getline], -->
<!-- #   [:store_result_in, "to_say"], -->
<!-- #   [:print_line, "to_say"], -->
<!-- #   [:print_line, "to_say"], -->
<!-- #   [:print_line, "to_say"], -->
<!-- #   [:print_line, "to_say"] ] -->

<!-- ~~~ -->

<!-- Let's break down how this is going to work: -->

<!-- 1.  The interpreter will move down the list, executing each instruction -->
<!--     one-by-one. -->
<!-- 2.  Every list item will have access to the result of the item before. -->
<!-- 3.  The first item in each instruction is the instruction, and rest are the -->
<!--     parameters. -->

<!-- So this `get_and_say_n_times` will take a number and return a program that -->
<!-- takes a string in stdin and echoes it *n* times. -->






<!-- Let's make a big leap of concepts.  How about we create some sort of dsl for -->
<!-- Ruby where we can make ruby -->





-----

<!-- What is Purity? -->
<!-- --------------- -->

<!-- Let's think --> 






<!-- What does this look like, practically?  The function *sin(x)*, for example, -->
<!-- does not imply any change in the world.  Sure, if you sit down and try to -->
<!-- calculate the sine of some number, you might change the state of your paper -->
<!-- and pencil. But the actual mathematical ideal of the sine function...it does -->
<!-- not involve any change in the world, -->
<!-- [lest we run into some really big problems][smbc]. The entire idea kind of -->
<!-- breaks down if you try to imagine it. Multiplication is an abstract, -->
<!-- non-physical concept.  Not a physical machine you run.  And why should two -->
<!-- times two change every time you calculate it? -->

<!-- [smbc]: http://www.smbc-comics.com/?id=2595 -->

