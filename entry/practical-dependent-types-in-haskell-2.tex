\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
\newcommand{\ImportTok}[1]{{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
\newcommand{\BuiltInTok}[1]{{#1}}
\newcommand{\ExtensionTok}[1]{{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 2)},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 2)}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html}{in
Code}}.}

We're back to continue on
\href{https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html}{our
journey} in using practical dependent types to write type-safe neural networks!
In
\href{https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html}{Part
1}, we wrote things out in normal, untyped Haskell, and looked at red flags and
general design principles that nudged us in the direction of adding dependent
types to our program. We learned to appreciate what dependent types offered in
terms of guiding us in writing our code, helping the compiler check our
correctness, providing a better interface for users, and more.

We also learned how to use singletons to work around some of Haskell's
fundamental limitations to let us ``pattern match'' on the structure of types,
and how to use typeclasses to generate singletons reflecting the structure of
types we are dealing with.

(If you read
\href{https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html}{Part
1} \emph{before} the singletons section was re-written to use the
\href{https://hackage.haskell.org/package/singletons}{singletons} library,
\href{https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html\#singletons-and-induction}{here's
a link to the section} in specific. This tutorial will assume familiarity with
what is discussed there!)

All of what we've dealt with so far has essentially been with types that are
fixed at compile-time. All the networks we've made have had ``static'' types,
with their sizes in their types indicated directly in the source code.

Today, we're going to dive into the world of types that \emph{depend} on factors
unknown until runtime, and see how dependent types in a strongly typed language
like Haskell helps us write safer, more correct, and more maintainable code.
Along the way, we'll encounter and learn first-hand about techniques and guiding
high-level principles that we can apply to our other dependently typed coding
endeavours.

\section{Run-time Types}\label{run-time-types}

Recall the type we had for our neural networks:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{k }\DataTypeTok{Network}
\DataTypeTok{Network}\OtherTok{ ::} \DataTypeTok{Nat} \OtherTok{->} \NormalTok{[}\DataTypeTok{Nat}\NormalTok{] }\OtherTok{->} \DataTypeTok{Nat} \OtherTok{->} \FunctionTok{*}
\end{Highlighting}
\end{Shaded}

They're of the form \texttt{Network\ i\ hs\ o}, where \texttt{i} is the size of
the input vector it expects, \texttt{hs} is the list of hidden layer sizes, and
\texttt{o} is the size of the output vector it produces. Something of type
\texttt{Network\ 10\ \textquotesingle{}{[}6,\ 4{]}\ 3} is a network with 10
input nodes, two input layers of size 6 and 4, and 3 output nodes.

This is great and all, but there's an apparent severe limitation to this:
Haskell is a statically typed language, right? So doesn't this mean that using a
network requires that you know the entire structure of the network at
compile-time?

It's conceivable that you might be able to have the input and output sizes known
at compile-time, but it's probably likely that you \emph{don't} know the what
you want your hidden layer structure to be in advance. You might want to load it
from a configuration file, or have it depend on user input. But can a type
really depend on things that you can't know until runtime?

To illustrate more clearly:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{main ::} \DataTypeTok{IO} \NormalTok{()}
\NormalTok{main }\FunctionTok{=} \KeywordTok{do}
    \NormalTok{putStrLn }\StringTok{"What hidden layer structure do you want?"}
    \NormalTok{hs  }\OtherTok{<- readLn        ::} \DataTypeTok{IO} \NormalTok{[}\DataTypeTok{Integer}\NormalTok{]}
    \NormalTok{net }\OtherTok{<- randomNetwork ::} \DataTypeTok{IO} \DecValTok{10} \FunctionTok{???} \DecValTok{3}   \CommentTok{-- what is ???}
    \CommentTok{-- ...?}
\end{Highlighting}
\end{Shaded}

You would \emph{want} to put \texttt{hs} there where \texttt{???} is,
but\ldots{}\texttt{???} has to be a type (of kind \texttt{{[}Nat{]}}).
\texttt{hs} is a value (of type \texttt{{[}Integer{]}}). It's clear here that
the \emph{type} of our network depends on something we can't write down or
decide until runtime.

\subsection{A Story of Parametricity}\label{a-story-of-parametricity}

Let's look at the type of \texttt{randomNet} again:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{randomNet ::} \NormalTok{m (}\DataTypeTok{Network} \NormalTok{i hs o)}
             \CommentTok{-- plus some constraints yadda yadda}
\end{Highlighting}
\end{Shaded}

To get more insight onto what the type is really saying, let's see the same
signature with the explicit forall's:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{randomNet ::} \NormalTok{forall m i hs o}\FunctionTok{.} \NormalTok{m (}\DataTypeTok{Network} \NormalTok{i hs o)}
             \CommentTok{-- plus some constraints yadda yadda}
\end{Highlighting}
\end{Shaded}

In English, this means that \texttt{randomNet} lets you produce a
\texttt{Network\ i\ hs\ o} for \emph{any} \texttt{i} you want, for \emph{any}
\texttt{hs} you want, for \emph{any} \texttt{o} you want. It's implemented in a
\emph{parametrically polymorphic way}, meaning that it's implemented in a
uniform way to handle \emph{any} \texttt{i}, \texttt{hs}, or \texttt{o} the
caller could possibly ask for. (Provided that they satisfy the typeclass
constraints, of course)

We have some other functions we defined in the last part, as well, that are
defined in such a parametrically polymorphic way:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{runNet ::} \NormalTok{forall i hs o}\FunctionTok{.} \NormalTok{(}\DataTypeTok{KnownNat} \NormalTok{i, }\DataTypeTok{KnownNat} \NormalTok{o)}
       \OtherTok{=>} \DataTypeTok{Network} \NormalTok{i hs o}
       \OtherTok{->} \DataTypeTok{R} \NormalTok{i}
       \OtherTok{->} \DataTypeTok{R} \NormalTok{o}

\OtherTok{train  ::} \NormalTok{forall i hs o}\FunctionTok{.} \NormalTok{(}\DataTypeTok{KnownNat} \NormalTok{i, }\DataTypeTok{KnownNat} \NormalTok{o)}
       \OtherTok{=>} \DataTypeTok{Double}
       \OtherTok{->} \DataTypeTok{R} \NormalTok{i}
       \OtherTok{->} \DataTypeTok{R} \NormalTok{o}
       \OtherTok{->} \DataTypeTok{Network} \NormalTok{i hs o}
       \OtherTok{->} \DataTypeTok{Network} \NormalTok{i hs o}
\end{Highlighting}
\end{Shaded}

\texttt{runNet} is written a way that it can work for \emph{any} \texttt{i} or
\emph{any} \texttt{hs} or \emph{any} \texttt{o} you want or need (provided they
satisfy the typeclass constraints). It takes a \texttt{Network\ i\ hs\ o} for
any \texttt{i}, \texttt{hs}, or \texttt{o}, and an \texttt{R\ i} for the same
\texttt{i}, and returns an \texttt{R\ o} for the same \texttt{o}. The way they
are implemented does not depend on the specific structure of the network.

Contrast this to:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{foo ::} \DataTypeTok{Network} \DecValTok{10} \CharTok{'[6,4] 3 -> R 3}
\end{Highlighting}
\end{Shaded}

This is specifically implemented to \emph{only} work on networks with 10 inputs,
6 and 4-node hidden layers, and 3 outputs. It \emph{does} care about the
structure of the network you put in.

Now, the concept of ``types that depend on run-time'' seems to jive with this
concept. If we want to write functions that work on types that depend on
run-time, it would make sense that they have to be able to anticipate and work
for \emph{any} type that the run-time processes might demand.

And that's sort of the secret to working with ``types that depend on run-time''
in Haskell --- you have to deal with them in a way that adapts to any type that
can come at you!

\subsection{Reification}\label{reification}

So we know that \texttt{randomNet} is such a function that works with \emph{any}
\texttt{hs} you could possibly throw at it. The last missing piece is a function
can \emph{run} \texttt{randomNet} with an \texttt{hs} that depends on run-time
factors.

Enter \texttt{withSomeSing}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{withSomeSing}
\OtherTok{    ::} \NormalTok{[}\DataTypeTok{Integer}\NormalTok{]}
    \OtherTok{->} \NormalTok{(forall hs}\FunctionTok{.} \DataTypeTok{Sing} \NormalTok{(}\OtherTok{hs ::} \NormalTok{[}\DataTypeTok{Nat}\NormalTok{]) }\OtherTok{->} \NormalTok{r)}
    \OtherTok{->} \NormalTok{r}
\end{Highlighting}
\end{Shaded}

(I've specialized it there to work with \texttt{{[}Integer{]}} and
\texttt{{[}Nat{]}}, but it works in general with any singleton and the values it
represents)

The type signature says ``Give me an \texttt{{[}Integer{]}} and a function that
is ready to take \emph{any} \texttt{hs}, and I'll run it with the \texttt{hs}
from the \texttt{{[}Integer{]}} for you''.

For example, if we had \texttt{foo\ ::\ Sing\ hs\ -\textgreater{}\ Int}, and we
pass it to \texttt{withSomeSing\ {[}1,2,3{]}}, it'll \emph{run} \texttt{foo},
setting with \texttt{hs} to be \texttt{\textquotesingle{}{[}1,2,3{]}}.

We can re-write \texttt{randomNet} to take a \texttt{Sing\ hs\ -\textgreater{}}
instead of a \texttt{SingI\ hs\ =\textgreater{}} (remember, the two are just two
ways of writing the same thing. Re-read the
\href{https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html\#singletons-and-induction}{singletons
section} for a review!) to make things more clear:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L47-50}
\OtherTok{randomNet' ::} \NormalTok{forall m i hs o}\FunctionTok{.} \NormalTok{(}\DataTypeTok{MonadRandom} \NormalTok{m, }\DataTypeTok{KnownNat} \NormalTok{i, }\DataTypeTok{KnownNat} \NormalTok{o)}
           \OtherTok{=>} \DataTypeTok{Sing} \NormalTok{hs }\OtherTok{->} \NormalTok{m (}\DataTypeTok{Network} \NormalTok{i hs o)}
\NormalTok{randomNet' }\FunctionTok{=} \NormalTok{\textbackslash{}}\KeywordTok{case} \DataTypeTok{SNil}            \OtherTok{->}     \DataTypeTok{O} \FunctionTok{<$>} \NormalTok{randomWeights}
                   \DataTypeTok{SNat} \OtherTok{`SCons`} \NormalTok{ss }\OtherTok{->} \NormalTok{(}\FunctionTok{:&~}\NormalTok{) }\FunctionTok{<$>} \NormalTok{randomWeights }\FunctionTok{<*>} \NormalTok{randomNet' ss}
\end{Highlighting}
\end{Shaded}

And we can implement the concept we had before:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L149-156}
\OtherTok{main ::} \DataTypeTok{IO} \NormalTok{()}
\NormalTok{main }\FunctionTok{=} \KeywordTok{do}
    \NormalTok{putStrLn }\StringTok{"What size random net?"}
    \NormalTok{xs }\OtherTok{<-} \NormalTok{readLn}
    \NormalTok{withSomeSing xs }\FunctionTok{$} \NormalTok{\textbackslash{}(}\OtherTok{ss ::} \DataTypeTok{Sing} \NormalTok{(}\OtherTok{hs ::} \NormalTok{[}\DataTypeTok{Nat}\NormalTok{])) }\OtherTok{->} \KeywordTok{do}
      \NormalTok{net }\OtherTok{<-} \NormalTok{randomNet'}\OtherTok{ ss ::} \DataTypeTok{IO} \NormalTok{(}\DataTypeTok{Network} \DecValTok{10} \NormalTok{hs }\DecValTok{3}\NormalTok{)}
      \NormalTok{print net}
      \CommentTok{-- blah blah stuff with our dynamically generated net}
\end{Highlighting}
\end{Shaded}

\texttt{someSing\ xs\ ::\ (forall\ hs.\ Sing\ hs\ -\textgreater{}\ r)\ -\textgreater{}\ r}
is a function that's waiting for a \texttt{Sing\ hs\ -\textgreater{}\ r} that
works for \emph{any} \texttt{hs}. It'll ``run'' the function with the
\texttt{hs} corresponding to \texttt{xs\ ::\ {[}Integer{]}}.

In our case, we gave it a function
\texttt{forall\ hs.\ Sing\ hs\ -\textgreater{}\ IO\ ()}, and it \emph{runs} that
function \emph{with} the \texttt{hs} corresponding to list we give it.

So, if we gave \texttt{withSomeSing} the list \texttt{{[}6,3{]}}, I'll
\emph{run} our action as if it had
\texttt{hs\ \textasciitilde{}\ \textquotesingle{}{[}6,3{]}}. And remember ---
because our function is parametrically polymorphic to work with any \texttt{hs},
it'll happily accept it!

\end{document}
