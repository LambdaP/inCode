\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
\newcommand{\ImportTok}[1]{{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
\newcommand{\BuiltInTok}[1]{{#1}}
\newcommand{\ExtensionTok}[1]{{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 2)},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 2)}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html}{in
Code}}.}

We're back to continue on
\href{https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html}{our
journey} in using practical dependent types to write type-safe neural networks!
In
\href{https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html}{Part
1}, we wrote things out in normal, untyped Haskell, and looked at red flags and
general design principles that nudged us in the direction of adding dependent
types to our program. We learned to appreciate what dependent types offered in
terms of guiding us in writing our code, helping the compiler check our
correctness, providing a better interface for users, and more.

We also learned how to use singletons to work around some of Haskell's
fundamental limitations to let us ``pattern match'' on the structure of types,
and how to use typeclasses to generate singletons reflecting the structure of
types we are dealing with.

(If you read
\href{https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html}{Part
1} \emph{before} the singletons section was re-written to use the
\href{https://hackage.haskell.org/package/singletons}{singletons} library,
\href{https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html\#singletons-and-induction}{here's
a link to the section} in specific. This tutorial will assume familiarity with
what is discussed there!)

All of what we've dealt with so far has essentially been with types that are
fixed at compile-time. All the networks we've made have had ``static'' types,
with their sizes in their types indicated directly in the source code.

Today, we're going to dive into the world of types that \emph{depend} on factors
unknown until runtime, and see how dependent types in a strongly typed language
like Haskell helps us write safer, more correct, and more maintainable code.
Along the way, we'll encounter and learn first-hand about techniques and guiding
high-level principles that we can apply to our other dependently typed coding
endeavours.

\section{Run-time Types}\label{run-time-types}

Recall the type we had for our neural networks:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{k }\DataTypeTok{Network}
\DataTypeTok{Network}\OtherTok{ ::} \DataTypeTok{Nat} \OtherTok{->} \NormalTok{[}\DataTypeTok{Nat}\NormalTok{] }\OtherTok{->} \DataTypeTok{Nat} \OtherTok{->} \FunctionTok{*}
\end{Highlighting}
\end{Shaded}

They're of the form \texttt{Network\ i\ hs\ o}, where \texttt{i} is the size of
the input vector it expects, \texttt{hs} is the list of hidden layer sizes, and
\texttt{o} is the size of the output vector it produces. Something of type
\texttt{Network\ 10\ \textquotesingle{}{[}6,\ 4{]}\ 3} is a network with 10
input nodes, two input layers of size 6 and 4, and 3 output nodes.

This is great and all, but there's an apparent severe limitation to this:
Haskell is a statically typed language, right? So doesn't this mean that using a
network requires that you know the entire structure of the network at
compile-time?

It's conceivable that you might be able to have the input and output sizes known
at compile-time, but it's probably likely that you \emph{don't} know the what
you want your hidden layer structure to be in advance. You might want to load it
from a configuration file, or have it depend on user input. But can a type
really depend on things that you can't know until runtime?

To illustrate more clearly:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{main ::} \DataTypeTok{IO} \NormalTok{()}
\NormalTok{main }\FunctionTok{=} \KeywordTok{do}
    \NormalTok{putStrLn }\StringTok{"What hidden layer structure do you want?"}
    \NormalTok{hs  }\OtherTok{<- readLn        ::} \DataTypeTok{IO} \NormalTok{[}\DataTypeTok{Integer}\NormalTok{]}
    \NormalTok{net }\OtherTok{<- randomNetwork ::} \DataTypeTok{IO} \DecValTok{10} \FunctionTok{???} \DecValTok{3}   \CommentTok{-- what is ???}
    \CommentTok{-- ...?}
\end{Highlighting}
\end{Shaded}

You would \emph{want} to put \texttt{hs} there where \texttt{???} is,
but\ldots{}\texttt{???} has to be a type (of kind \texttt{{[}Nat{]}}).
\texttt{hs} is a value (of type \texttt{{[}Integer{]}}). It's clear here that
the \emph{type} of our network depends on something we can't write down or
decide until runtime.

\subsection{An Existential Crisis}\label{an-existential-crisis}

There are a couple of ways to go about this, actually --- we'll go through them,
and we'll also see at the end how they are all really fundamentally the same
thing.

\subsubsection{Types hiding behind
constructors}\label{types-hiding-behind-constructors}

Now, having the entire structure of your neural network in the type is nice and
all for cool tricks like \texttt{randomNet}\ldots{}but do you \emph{really} want
to work with this directly? After all, from the user's perspective, the user
really only ever needs to know \texttt{i} and \texttt{o}: What vectors the
network \emph{expects}, and what vectors the network \emph{outputs}. In the end,
all a (feed-forward) Neural Network really is is an abstraction over a function
\texttt{R\ i\ -\textgreater{}\ R\ o}.

Remember, the main benefits of having the entire structure in the type was to
help us \emph{implement} our functions more safely, with the compiler's help,
and also for cute return type polymorphism tricks like \texttt{randomNet} and
\texttt{getNet}. The first type of benefit really doesn't benefit the
\emph{user} of the network.

Imagine that we had written a \texttt{Network} type that \emph{didn't} have the
internal structure in the type ---

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{OpaqueNet} \NormalTok{i o}
\end{Highlighting}
\end{Shaded}

Recall that our issue earlier was that we had to write
\texttt{Network\ i\ ???\ o}, but we had no idea what to put in for \texttt{???}.
But, what if we worked with an \texttt{OpaqueNet\ i\ o}, we wouldn't even care!
We wouldn't have to tell GHC what the internal structure is.

We can implement it as an ``existential'' wrapper over \texttt{Network},
actually:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L77-78}
\KeywordTok{data} \DataTypeTok{OpaqueNet}\OtherTok{ ::} \DataTypeTok{Nat} \OtherTok{->} \DataTypeTok{Nat} \OtherTok{->} \FunctionTok{*} \KeywordTok{where}
    \DataTypeTok{ONet}\OtherTok{ ::} \DataTypeTok{Sing} \NormalTok{hs }\OtherTok{->} \DataTypeTok{Network} \NormalTok{i hs o }\OtherTok{->} \DataTypeTok{OpaqueNet} \NormalTok{i o}
\end{Highlighting}
\end{Shaded}

So, if you have \texttt{net\ ::\ Network\ 6\ \textquotesingle{}{[}10,6,3{]}\ 2},
you can create \texttt{ONet\ sing\ net\ ::\ OpaqueNet\ 6\ 2}. When you use the
\texttt{ONet} constructor, the structure of the hidden layers disappears from
the type!

How do we use this type? We \emph{pattern match} on \texttt{ONet} to get the
singleton and the net back, and we can use them:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L80-85}
\OtherTok{numHiddens ::} \DataTypeTok{OpaqueNet} \NormalTok{i o }\OtherTok{->} \DataTypeTok{Int}
\NormalTok{numHiddens }\FunctionTok{=} \NormalTok{\textbackslash{}}\KeywordTok{case} \DataTypeTok{ONet} \NormalTok{ss _ }\OtherTok{->} \NormalTok{lengthSing ss}
  \KeywordTok{where}
\OtherTok{    lengthSing ::} \DataTypeTok{Sing} \NormalTok{(}\OtherTok{hs ::} \NormalTok{[}\DataTypeTok{Nat}\NormalTok{]) }\OtherTok{->} \DataTypeTok{Int}
    \NormalTok{lengthSing }\FunctionTok{=} \NormalTok{\textbackslash{}}\KeywordTok{case} \DataTypeTok{SNil}         \OtherTok{->} \DecValTok{0}
                       \NormalTok{_ }\OtherTok{`SCons`} \NormalTok{ss }\OtherTok{->} \DecValTok{1} \FunctionTok{+} \NormalTok{lengthSing ss}
\end{Highlighting}
\end{Shaded}

With the \texttt{ScopedTypeVariables} extension, we can even bring \texttt{hs}
back into scope, as in \texttt{ONet\ (ss\ ::\ Sing\ hs)\ \_\ -\textgreater{}}.

Note that it's important for us to include the singleton in addition to the
network itself, because of type erasure (our best friend). If we didn't pop the
singleton in, we'd have to do some work to recover the original
\texttt{hs}.\footnote{A fun exercise would be to implement a
  \texttt{Network\ i\ hs\ o\ -\textgreater{}\ Sing\ hs}, to get
  \texttt{Sing\ hs} back. There's a
  \href{https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs\#L73-75}{solution}
  in the source code!}

Another way we could have counter-acted type erasure would be to have:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{OpaqueNet}\OtherTok{ ::} \FunctionTok{*} \OtherTok{->} \FunctionTok{*} \KeywordTok{where}
    \DataTypeTok{ONet}\OtherTok{ ::} \DataTypeTok{SingI} \NormalTok{hs }\OtherTok{=>} \DataTypeTok{Network} \NormalTok{i hs o }\OtherTok{->} \DataTypeTok{OpaqueNet} \NormalTok{i o}
\end{Highlighting}
\end{Shaded}

Like we learned last time, the \texttt{Sing\ hs\ -\textgreater{}} and
\texttt{SingI\ hs\ =\textgreater{}} styles are just two ways of doing the same
thing.

This pattern is known as the \textbf{dependent pair}: pair a representation of
\texttt{hs} with some type that includes \texttt{hs}, and pattern match on the
\texttt{Sing\ hs} to reveal both!

And here's the key to making this all work: once you \emph{do} pattern match on
\texttt{ONet}, you have to handle the \texttt{hs} in a \emph{completely
polymorphic way}. You're not allowed to assume anything about
\texttt{hs}\ldots{}you have to provide a completely parametrically polymorphic
way of dealing with it!

For example, this function is completely \emph{not} ok:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{bad ::} \DataTypeTok{OpaqueNet} \NormalTok{i o }\OtherTok{->} \DataTypeTok{Network} \NormalTok{i hs o}
\NormalTok{bad }\FunctionTok{=} \NormalTok{\textbackslash{}}\KeywordTok{case} \DataTypeTok{ONet} \NormalTok{_ n }\OtherTok{->} \NormalTok{n          }\CommentTok{-- nope, not ok at all.}
\end{Highlighting}
\end{Shaded}

Why not? Well, a type signature like
\texttt{OpaqueNet\ i\ o\ -\textgreater{}\ Network\ i\ hs\ o} means that the
\emph{caller} can decide what \texttt{hs} can be --- just like
\texttt{read\ ::\ Read\ a\ =\textgreater{}\ String\ -\textgreater{}\ a}, where
the caller decides what \texttt{a} is.

Of course, this \emph{isn't} the case with the way we've written the
function\ldots{}the function only returns a \emph{specific} \texttt{hs} that the
\emph{function} decides. The \emph{caller} has to accommodate whatever is inside
\texttt{ONet}.

\subsubsection{The Universal and the
Existential}\label{the-universal-and-the-existential}

We just brushed here on something at the heart of using existential types in
Haskell: the issue of who has the power to decide what the types will be
instantiated as.

Most polymorphic functions you work with in Haskell are ``universally
qualified''. For example, for a function like

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{map}\OtherTok{ ::} \NormalTok{(a }\OtherTok{->} \NormalTok{b) }\OtherTok{->} \NormalTok{[a] }\OtherTok{->} \NormalTok{[b]}
\end{Highlighting}
\end{Shaded}

\texttt{a} and \texttt{b} are universally quantified, which means that the
person who \emph{uses} \texttt{map} gets to decide what \texttt{a} and
\texttt{b} are. To be more explicit, that type signature can be written as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{map}\OtherTok{ ::} \NormalTok{forall a b}\FunctionTok{.} \NormalTok{(a }\OtherTok{->} \NormalTok{b) }\OtherTok{->} \NormalTok{[a] }\OtherTok{->} \NormalTok{[b]}
\end{Highlighting}
\end{Shaded}

This means that \texttt{map} is defined in a way that will work for \emph{any}
\texttt{a} and \texttt{b} that the \emph{caller} wants. As a caller, you can
request:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{map}\OtherTok{ ::} \NormalTok{(}\DataTypeTok{Int} \OtherTok{->} \DataTypeTok{Bool}\NormalTok{)    }\OtherTok{->} \NormalTok{[}\DataTypeTok{Int}\NormalTok{]    }\OtherTok{->} \NormalTok{[}\DataTypeTok{Bool}\NormalTok{]}
\NormalTok{map}\OtherTok{ ::} \NormalTok{(}\DataTypeTok{Double} \OtherTok{->} \DataTypeTok{Void}\NormalTok{) }\OtherTok{->} \NormalTok{[}\DataTypeTok{Double}\NormalTok{] }\OtherTok{->} \NormalTok{[}\DataTypeTok{Void}\NormalTok{]}
\NormalTok{map}\OtherTok{ ::} \NormalTok{(}\DataTypeTok{String} \OtherTok{->} \NormalTok{(}\DataTypeTok{Bool} \OtherTok{->} \DataTypeTok{Char}\NormalTok{)) }\OtherTok{->} \NormalTok{[}\DataTypeTok{String}\NormalTok{] }\OtherTok{->} \NormalTok{[}\DataTypeTok{Bool} \OtherTok{->} \DataTypeTok{Char}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Consequentially, the function has to be implemented in a way that will work for
\emph{any} \texttt{a} and \texttt{b}. The function's implementation has the
burden of being flexible enough to handle whatever the caller asks for.

But, for a function like:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{foo ::} \NormalTok{[}\DataTypeTok{Int}\NormalTok{] }\OtherTok{->} \DataTypeTok{OpaqueNet} \NormalTok{i o}
\end{Highlighting}
\end{Shaded}

While the caller can choose what \texttt{i} and \texttt{o} are, the
\emph{function} gets to choose what \texttt{hs} (in the hidden
\texttt{Network\ i\ hs\ o}) is.

If I want to \emph{use} the thing that \texttt{foo} returns\ldots{}then \emph{I}
have to be flexible. \emph{I} have the burden of being flexible enough to handle
whatever the \emph{function} returns.

In summary:

\begin{itemize}
\item
  For universally quantified types, the \emph{caller} chooses the type being
  instanced, and the \emph{function's implementation} has to accommodate any
  choice.
\item
  For existentially quantified types, the \emph{function's implementation}
  chooses the type being instanced, and the \emph{caller} has to accommodate any
  choice.
\end{itemize}

Indeed, we saw earlier that if we ever wanted to \emph{use} the
\texttt{Network\ i\ hs\ o} inside the \texttt{OpaqueNet\ i\ o}, we were forced
to deal with it in a parametrically polymorphic way. We had to be able to handle
\emph{any} \texttt{hs} that the \texttt{ONet} could throw at us!

\subsubsection{A familiar friend}\label{a-familiar-friend}

I called \texttt{OpaqueNet\ i\ o} a ``dependent pair'' earlier, which
existentially quantifies over \texttt{hs}. But there's another common term for
it: a \textbf{dependent sum}.

People familiar with Haskell might recognize that ``sum types'' are
\texttt{Either}-like types that can be one thing or another. Sum types are one
of the first things you learn about in Haskell --- heck, even \texttt{Maybe\ a}
is the sum of \texttt{a} and \texttt{()}.

Dependent pairs/existential types actually are very similar to
\texttt{Either}/sum types, in spirit, and it might help to see the parallel so
that you can see that they're nothing scary, and that the fundamentals/intuition
of working with existential types in Haskell is no different than working with
\texttt{Either}!

If I had:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{foo ::} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{Either} \DataTypeTok{Int} \DataTypeTok{Bool}
\end{Highlighting}
\end{Shaded}

I have to handle the result\ldots{}but I have to handle it for both the case
where I get an \texttt{Int} and the case where I get a \texttt{Bool}. The
\emph{function} gets to pick what type I have to handle (\texttt{Int} or
\texttt{Bool}), and \emph{I} have to adapt to whatever it returns. Sound
familiar?

In fact, you can even imagine that \texttt{OpaqueNet\ i\ o} is implemented like
a fancy \texttt{Either}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{OpaqueNet} \NormalTok{i o }\FunctionTok{=} \DataTypeTok{Either} \NormalTok{(}\DataTypeTok{Network} \NormalTok{i }\CharTok{'[] o) (}
                       \DataTypeTok{Either} \NormalTok{(}\DataTypeTok{Network} \NormalTok{i }\CharTok{'[1] o) (}
                         \DataTypeTok{Either} \NormalTok{(}\DataTypeTok{Network} \NormalTok{i }\CharTok{'[1,1] o) (}
                           \DataTypeTok{Either} \NormalTok{(}\DataTypeTok{Network} \NormalTok{i }\CharTok{'[2] o) (}
                             \DataTypeTok{Either} \NormalTok{(}\DataTypeTok{Network} \NormalTok{i }\CharTok{'[2,1] o) (}
                               \DataTypeTok{Either} \NormalTok{(}\DataTypeTok{Network} \NormalTok{i }\CharTok{'[2,2] o) (}
                                 \CommentTok{-- .. literally infinitely ..}
                               \NormalTok{)}
                             \NormalTok{)}
                           \NormalTok{)}
                         \NormalTok{)}
                       \NormalTok{)}
                     \NormalTok{)}
\end{Highlighting}
\end{Shaded}

In other words, an infinite sum of all of the different combinations of hidden
layer structures.

And, remember that the basic way of handling an \texttt{Either} you get and
figuring out what the type of the value is inside is by \emph{pattern matching}
on it. You can't know if an \texttt{Either\ Int\ Bool} contains an \texttt{Int}
or \texttt{Bool} until you pattern match. But, once you do, all is revealed.

For \texttt{OpaqueNet\ i\ o}, it's the same! You don't know what the actual type
of the \texttt{Network\ i\ hs\ o} it contains is until you \emph{pattern match}
on the \texttt{Sing\ hs}! (Or potentially, the network itself) But, once you
pattern match on it, all is revealed.

\subsection{Reification}\label{reification}

Let's pull it all together!

For simplicity, let's re-write \texttt{randomNet} the more sensible way --- with
the explicit singleton input style:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L48-55}
\OtherTok{randomNet' ::} \NormalTok{forall m i hs o}\FunctionTok{.} \NormalTok{(}\DataTypeTok{MonadRandom} \NormalTok{m, }\DataTypeTok{KnownNat} \NormalTok{i, }\DataTypeTok{KnownNat} \NormalTok{o)}
           \OtherTok{=>} \DataTypeTok{Sing} \NormalTok{hs }\OtherTok{->} \NormalTok{m (}\DataTypeTok{Network} \NormalTok{i hs o)}
\NormalTok{randomNet' }\FunctionTok{=} \NormalTok{\textbackslash{}}\KeywordTok{case} \DataTypeTok{SNil}            \OtherTok{->}     \DataTypeTok{O} \FunctionTok{<$>} \NormalTok{randomWeights}
                   \DataTypeTok{SNat} \OtherTok{`SCons`} \NormalTok{ss }\OtherTok{->} \NormalTok{(}\FunctionTok{:&~}\NormalTok{) }\FunctionTok{<$>} \NormalTok{randomWeights }\FunctionTok{<*>} \NormalTok{randomNet' ss}

\OtherTok{randomNet ::} \NormalTok{forall m i hs o}\FunctionTok{.} \NormalTok{(}\DataTypeTok{MonadRandom} \NormalTok{m, }\DataTypeTok{KnownNat} \NormalTok{i, }\DataTypeTok{SingI} \NormalTok{hs, }\DataTypeTok{KnownNat} \NormalTok{o)}
          \OtherTok{=>} \NormalTok{m (}\DataTypeTok{Network} \NormalTok{i hs o)}
\NormalTok{randomNet }\FunctionTok{=} \NormalTok{randomNet' sing}
\end{Highlighting}
\end{Shaded}

Remember earlier that I recommend (personally, and subjectively) a style where
your external API functions are implemented in
\texttt{SingI\ a\ =\textgreater{}} style, and your internal ones in
\texttt{Sing\ a\ -\textgreater{}} style. This lets all of your internal
functions fit together more nicely (\texttt{Sing\ a\ -\textgreater{}} style
tends to be easier to write in, especially if you stay in it the entire time)
while at the same time removing the burden of calling with explicit singletons
from people using the functionality externally.\footnote{This is a completely
  personal style, and I can't claim to speak for all of the Haskell dependent
  typing community. In fact, I'm not even sure that you could even say that
  there is a consensus at all. But this is the style that has worked personally
  for me in both writing and using libraries! And hey, some libraries I've seen
  in the wild even offer \emph{both} styles in their external API.}

Now, we still need to somehow get our list of integers to the type level
somehow, so we can create a \texttt{Network\ i\ hs\ o} to stuff into our
\texttt{ONet}. And for that, the \emph{singletons} library offers the proper
tooling. It gives us \texttt{SomeSing}, which is a lot like our
\texttt{OpaqueNet} above, wrapping the \texttt{Sing\ a} inside an existential
data constructor. \texttt{toSing} takes the term-level value (for us, an
\texttt{{[}Integer{]}}) and returns a \texttt{SomeSing} wrapping the type-level
value (for us, a \texttt{{[}Nat{]}}). When we pattern match on the
\texttt{SomeSing} constructor, we get \texttt{a} in scope!

In an ideal world, \texttt{SomeSing} would look like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeSing}\OtherTok{ ::} \FunctionTok{*} \OtherTok{->} \FunctionTok{*} \KeywordTok{where}
    \DataTypeTok{SomeSing}\OtherTok{ ::} \DataTypeTok{Sing} \NormalTok{(}\OtherTok{a ::} \NormalTok{k) }\OtherTok{->} \DataTypeTok{SomeSing} \NormalTok{k}
\end{Highlighting}
\end{Shaded}

And you can have

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{foo ::} \DataTypeTok{SomeSing} \DataTypeTok{Bool}
\NormalTok{foo }\FunctionTok{=} \DataTypeTok{SomeSing} \DataTypeTok{STrue}

\OtherTok{bar ::} \DataTypeTok{SomeSing} \DataTypeTok{Nat}
\NormalTok{bar }\FunctionTok{=} \DataTypeTok{SomeSing} \NormalTok{(}\DataTypeTok{SNat}\OtherTok{ ::} \DataTypeTok{Sing} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

But because \emph{singletons} was implemented before the \texttt{TypeInType}
extension in GHC 8, it has to be implemented with clunky ``Kind Proxies''. In a
future version of \emph{singletons}, they'll be implemented this way. But for
now, the usage is more or less identical. It's just right now, in the current
system, \texttt{SomeSing\ STrue\ ::\ SomeSing\ (KProxy\ ::\ KProxy\ Bool)}, and
\texttt{bar\ ::\ SomeSing\ (KProxy\ ::\ KProxy\ Nat)}.\footnote{Gross, right?
  Hopefully some day this will be as far behind us as that whole Monad/Functor
  debacle is now!}

Pattern matching looks like:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{main ::} \DataTypeTok{IO} \NormalTok{()}
\NormalTok{main }\FunctionTok{=} \KeywordTok{do}
    \NormalTok{putStrLn }\StringTok{"How many cats do you own?"}
    \NormalTok{c }\OtherTok{<- readLn ::} \DataTypeTok{IO} \DataTypeTok{Integer}
    \KeywordTok{case} \NormalTok{toSing c }\KeywordTok{of}
      \DataTypeTok{SomeSing} \NormalTok{(}\DataTypeTok{SNat}\OtherTok{ ::} \DataTypeTok{Sing} \NormalTok{n) }\OtherTok{->} \CommentTok{-- ...}
\end{Highlighting}
\end{Shaded}

Now, inside the case statement branch (the \texttt{...}), we have \emph{type}
\texttt{n\ ::\ Nat} in scope! And by pattern matching on the \texttt{SNat}
constructor, we also have a \texttt{Knownnat\ n} instance (As discussed in
{[}previous part{]}{[}new-section){]}. We now have enough to write our
\texttt{randomONet}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L103-107}
\OtherTok{randomONet ::} \NormalTok{(}\DataTypeTok{MonadRandom} \NormalTok{m, }\DataTypeTok{KnownNat} \NormalTok{i, }\DataTypeTok{KnownNat} \NormalTok{o)}
           \OtherTok{=>} \NormalTok{[}\DataTypeTok{Integer}\NormalTok{]}
           \OtherTok{->} \NormalTok{m (}\DataTypeTok{OpaqueNet} \NormalTok{i o)}
\NormalTok{randomONet hs }\FunctionTok{=} \KeywordTok{case} \NormalTok{toSing hs }\KeywordTok{of}
                  \DataTypeTok{SomeSing} \NormalTok{ss }\OtherTok{->} \DataTypeTok{ONet} \NormalTok{ss }\FunctionTok{<$>} \NormalTok{randomNet' ss}
\end{Highlighting}
\end{Shaded}

This process of bringing a term-level value into the type level is known in
Haskell as \textbf{reification}. Witht his, our original goal is (finally)
within reach:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L151-157}
\OtherTok{main ::} \DataTypeTok{IO} \NormalTok{()}
\NormalTok{main }\FunctionTok{=} \KeywordTok{do}
    \NormalTok{putStrLn }\StringTok{"What hidden layer structure do you want?"}
    \NormalTok{hs }\OtherTok{<-} \NormalTok{readLn}
    \DataTypeTok{ONet} \NormalTok{ss (}\OtherTok{net ::} \DataTypeTok{Network} \DecValTok{10} \NormalTok{hs }\DecValTok{3}\NormalTok{) }\OtherTok{<-} \NormalTok{randomONet hs}
    \NormalTok{print net}
    \CommentTok{-- blah blah stuff with our dynamically generated net}
\end{Highlighting}
\end{Shaded}

\subsubsection{The Boundary}\label{the-boundary}

With the power of existentially quantified types (like in \texttt{SomeSing}), we
essentially gained the ability to work with types that depend on runtime
results.

In a way, you can consider the \texttt{toSing} and the \texttt{SomeSing} as our
``boundary'' between the ``untyped world'' and the ``typed world''. This layer
(and the process of reification) cleanly separates the two.

This ``boundary'' can be thought of as a lot like the boundary we talk about
between ``pure'' functions and values and ``impure'' (IO, etc.) ones. We say to
always write as much of your program as possible in the ``pure'' world, and to
separate and pull out as much logic as you can to be pure logic. That's sort of
one of the first things you learn about as a Haskell programmer: how to separate
logic that \emph{can} be pure from logic that is ``impure'' (IO, etc.), and then
``combine them'' at the very end, as late as possible.

Well, if the final program is going to be IO in the end anyway, why bother
separating out pure and impure parts of your logic? You gain separation of
concerns, the increased ability to reason with your code and analyze what it
does, the compiler's ability to check what you write, the limitation of
implementations, and etc. are all reasons any Haskeller should be familiar with
reciting.

You can think of the general philosophy of working with typed/untyped worlds as
being the same thing. You can write as much of your program as possible in the
``typed'' world, like we did in Part 1. Take advantage of the increased ability
to reason with your code, parametric polymorphism helping you \emph{write} your
code, limit your implementations, nab you compiler help, etc. All of those are
benefits of working in the typed world.

Then, write what you must in your ``untyped'' world, such as dealing with values
that pop up at runtime like the \texttt{{[}Integer{]}} above.

Finally, at the end, \emph{unite} them at the boundary. Pass the control
football from the untyped world to the typed world!

\subsection{Continuation-Based
Existentials}\label{continuation-based-existentials}

There's another way in Haskell that we work with existential types that can be
more natural and easy to work with in a lot of cases.

Note that when we pattern match on an existential data type, you have to work
with the values in the constructor in a parametrically polymorphic way. For
example, if we had:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{oNetToFoo ::} \DataTypeTok{OpaqueNet} \NormalTok{i o }\OtherTok{->} \DataTypeTok{Foo}
\NormalTok{oNetToFoo }\FunctionTok{=} \NormalTok{\textbackslash{}}\KeywordTok{case} \DataTypeTok{ONet} \NormalTok{s n }\OtherTok{->} \NormalTok{f s n}
\end{Highlighting}
\end{Shaded}

What does the type of \texttt{f} have to be? It has to take a \texttt{Sing\ hs}
and a \texttt{Network\ i\ hs\ o}, but deal with it in a way that works \emph{for
all} \texttt{hs}. It has to be:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{f ::} \NormalTok{forall (}\OtherTok{hs ::} \NormalTok{[}\DataTypeTok{Nat}\NormalTok{])}\FunctionTok{.} \DataTypeTok{Sing} \NormalTok{hs }\OtherTok{->} \DataTypeTok{Network} \NormalTok{i hs o }\OtherTok{->} \DataTypeTok{Foo}
\end{Highlighting}
\end{Shaded}

That is, it can't be written for \emph{only}
\texttt{Sing\ \textquotesingle{}{[}5{]}} or \emph{only}
\texttt{Sing\ \textquotesingle{}{[}6,3{]}}\ldots{}it has to work for \emph{any}
\texttt{hs}.

Well, we could really also just skip the data type together and represent an
existential type as something \emph{taking} the continuation \texttt{f} and
giving it what it needs.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L113-113}
\KeywordTok{type} \DataTypeTok{OpaqueNet'} \NormalTok{i o r }\FunctionTok{=} \NormalTok{(forall hs}\FunctionTok{.} \DataTypeTok{Sing} \NormalTok{hs }\OtherTok{->} \DataTypeTok{Network} \NormalTok{i hs o }\OtherTok{->} \NormalTok{r) }\OtherTok{->} \NormalTok{r}
\end{Highlighting}
\end{Shaded}

``Tell me how you would make an \texttt{r} if you had a \texttt{Sing\ hs} and a
\texttt{Network\ i\ hs\ o}, and I'll make it for you!''

This ``continuation transformation'' is known as formally
\textbf{skolemization}.\footnote{Skolemization is probably one of the coolest
  words you'll encounter working with dependent types in Haskell, and sometimes
  just knowing that you're ``skolemizing'' something makes you feel cooler.
  Thank you \href{https://en.wikipedia.org/wiki/Thoralf_Skolem}{Thoralf Skolem}.
  If you ever see a ``rigid, skolem'' error in GHC, you can thank him for that
  too! He also inspired me to decide to name my first son Thoralf. (My second
  son's name will be Curry)} We can ``wrap'' a \texttt{Network\ i\ hs\ o} into
an \texttt{OpaqueNet\textquotesingle{}\ i\ o\ r} pretty straightforwardly:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L115-116}
\OtherTok{oNet' ::} \DataTypeTok{Sing} \NormalTok{hs }\OtherTok{->} \DataTypeTok{Network} \NormalTok{i hs o }\OtherTok{->} \DataTypeTok{OpaqueNet'} \NormalTok{i o r}
\NormalTok{oNet' s n }\FunctionTok{=} \NormalTok{\textbackslash{}f }\OtherTok{->} \NormalTok{f s n}
\end{Highlighting}
\end{Shaded}

\end{document}
