\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/introduction-to-singletons-1.html}{in
Code}}.}

Real dependent types are coming to Haskell soon! Until then, we have the great
\emph{\href{http://hackage.haskell.org/package/singletons}{singletons}} library
:)

If you've ever run into dependently typed programming in Haskell, you've
probably encountered mentions of singletons (and the \emph{singletons} library).

I've noticed that there aren't very many comprehensive tutorials or
introductions on the motivation and usage of the singletons library, as well as
integration of it into your programs and how to find ways to use it. (But the
haddocks provide very thorough documentation on how to use it once you already
know what to use it for!) So this series of articles will be my attempt at
giving you the rundown of the library, why you'd want it, and how to start using
it in your Haskell programming today! And maybe also be a nice introduction to
the concept as a whole if you just want to learn.

This series will be based on
\href{http://talks.jle.im/lambdaconf-2017/singletons/}{a talk} I gave over the
summer, and will expand on it eventually.

These posts will assume no knowledge of dependent types, and, for now, only
basic to intermediate Haskell knowledge. (Types, kinds, typeclasses, data types,
functions)

All code is built on \emph{GHC 8.2.1} and with the
\emph{\href{https://www.stackage.org/nightly-2017-07-31}{nightly-2017-07-30}}
snapshot (so, singletons-2.3). However, there are negligible changes in the GHC
type system between GHC 8.0 and 8.2 (the only difference is in the libraries,
more or less), so everything should work on GHC 8.0 as well!

\section{The Phantom of the Types}\label{the-phantom-of-the-types}

Let's start with a very common Haskell trick that most learn early in their
Haskelling journey: the \href{https://wiki.haskell.org/Phantom_type}{phantom
type}.

Phantom types in Haskell are a very easy way to add a layer of ``type safety''
for your types and DSL's. It helps you restrict what values functions can take
and encode pre- and post-conditions directly into your types.

For example, in

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Foo}\NormalTok{ a }\FunctionTok{=} \DataTypeTok{MkFoo}
\end{Highlighting}
\end{Shaded}

The \texttt{a} parameter is phantom, because nothing of type \texttt{a} in the
data type\ldots{}it just exists as a dummy parameter for the \texttt{Foo} type.
We can use \texttt{MkFoo} without ever requiring something of type \texttt{a}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t }\DataTypeTok{MkFoo}\OtherTok{ ::} \DataTypeTok{Foo} \DataTypeTok{Int}
\DataTypeTok{Foo} \DataTypeTok{Int}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t }\DataTypeTok{MkFoo}\OtherTok{ ::} \DataTypeTok{Foo} \DataTypeTok{Bool}
\DataTypeTok{Foo} \DataTypeTok{Bool}
\end{Highlighting}
\end{Shaded}

A common use case of phantom type parameters is to tag data as ``sanitized'' or
``unsanitized'', for instance. For a simple example, let's check out a simple
DSL for a type-safe door:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{DoorState} \FunctionTok{=} \DataTypeTok{Opened} \FunctionTok{|} \DataTypeTok{Closed} \FunctionTok{|} \DataTypeTok{Locked}
  \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Show}\NormalTok{, }\DataTypeTok{Eq}\NormalTok{)}

\KeywordTok{data} \DataTypeTok{Door}\NormalTok{ (}\OtherTok{s ::} \DataTypeTok{DoorState}\NormalTok{) }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor}
\end{Highlighting}
\end{Shaded}

A couple things going on here:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  We're using the \texttt{DataKinds} extension to create both the \emph{type}
  \texttt{DoorState} as well as the \emph{kind} \texttt{DoorState}.

  Normally,
  \texttt{data\ DoorState\ =\ Opened\ \textbar{}\ Closed\ \textbar{}\ Locked} in
  Haskell defines the type \texttt{DoorState} and the value constructors
  \texttt{Opened}, \texttt{Closed}, and \texttt{Locked}.

  However, with \texttt{DataKinds}, that statement also defines a new
  \emph{kind} \texttt{DoorState}, with \emph{type} constructors
  \texttt{\textquotesingle{}Opened}, \texttt{\textquotesingle{}Closed}, and
  \texttt{\textquotesingle{}Locked}. (note the \texttt{\textquotesingle{}}
  ticks!)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{k }\CharTok{'Opened}
\DataTypeTok{DoorState}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{k }\CharTok{'Locked}
\DataTypeTok{DoorState}
\end{Highlighting}
\end{Shaded}
\item
  We're defining the \texttt{Door} type with a \emph{phantom parameter}
  \texttt{s}. It's a phantom type because we don't actually have any
  \emph{values} of type \texttt{s} in our data type\ldots{}the \texttt{s} is
  only just there as a dummy parameter for the type.

  We can use \texttt{UnsafeMkDoor} without ever using anything of type
  \texttt{s}. In reality, a real \texttt{Door} type would be a bit more
  complicated (and the direct \texttt{MkDoor} constructor would be hidden).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t }\DataTypeTok{UnsafeMkDoor}\OtherTok{ ::} \DataTypeTok{Door} \CharTok{'Opened}
\DataTypeTok{Door} \CharTok{'Opened}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t }\DataTypeTok{UnsafeMkDoor}\OtherTok{ ::} \DataTypeTok{Door} \CharTok{'Locked}
\DataTypeTok{Door} \CharTok{'Locked}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

We'll take a \texttt{Door\ s} to mean the type of a door with that current
status. So a \texttt{Door\ \textquotesingle{}Opened} is the type of an opened
door, a \texttt{Door\ \textquotesingle{}Closed} is the type of a closed (and
unlocked) door, etc.

Alternatively, we can define \texttt{Door} using
\href{https://en.wikibooks.org/wiki/Haskell/GADT\#Syntax}{\emph{GADT} syntax}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Door}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{UnsafeMkDoor}\OtherTok{ ::} \DataTypeTok{Door}\NormalTok{ s}
\end{Highlighting}
\end{Shaded}

This is defining the exact same type in the alternate GADT syntax -- here, we
define types by giving the type of its constructors.

\subsection{Phantoms in Action}\label{phantoms-in-action}

At first, this seems a bit silly. Why even have the extra type parameter if you
don't ever use it?

Well, right off the bat, we can write functions that expect only a certain type
of \texttt{Door}, and return a specific type of \texttt{Door}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{closeDoor ::} \DataTypeTok{Door} \CharTok{'Opened -> Door '}\DataTypeTok{Closed}
\NormalTok{closeDoor }\DataTypeTok{UnsafeMkDoor} \FunctionTok{=} \DataTypeTok{UnsafeMkDoor}
\end{Highlighting}
\end{Shaded}

So, the \texttt{closeDoor} function will \emph{only} take a
\texttt{Door\ \textquotesingle{}Opened} (an opened door). And it will return a
\texttt{Door\ \textquotesingle{}Closed} (a closed door).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ myDoor }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor}\OtherTok{ ::} \DataTypeTok{Door} \CharTok{'Opened}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t closeDoor myDoor}
\DataTypeTok{Door} \CharTok{'Closed}
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ yourDoor }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor}\OtherTok{ ::} \DataTypeTok{Door} \CharTok{'Closed}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t closeDoor yourDoor}
\DataTypeTok{TYPE} \DataTypeTok{ERROR}\FunctionTok{!}  \DataTypeTok{TYPE} \DataTypeTok{ERROR}\FunctionTok{!}
\end{Highlighting}
\end{Shaded}

You can think of this as a nice way of catching \emph{logic errors} at
compile-time. If your door type did not have its status in the type, the
\texttt{closeDoor} could have been given a closed or locked door, and you'd have
to reject it at runtime!

By adding the state of the door into its type, we can encode our pre-conditions
and post-conditions directly into the type. And any opportunity to move runtime
errors to compiletime errors should be celebrated with a little party!

This would also stop you from doing silly things like closing a door twice in a
row:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t closeDoor }\FunctionTok{.}\NormalTok{ closeDoor}
\DataTypeTok{TYPE} \DataTypeTok{ERROR}\FunctionTok{!}  \DataTypeTok{TYPE} \DataTypeTok{ERROR}\FunctionTok{!}
\end{Highlighting}
\end{Shaded}

Do you see why?

With a couple of state transitions, we can write compositions that are
typechecked to all be legal:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{lockDoor ::} \DataTypeTok{Door} \CharTok{'Closed -> Door '}\DataTypeTok{Locked}
\NormalTok{lockDoor }\DataTypeTok{UnsafeMkDoor} \FunctionTok{=} \DataTypeTok{UnsafeMkDoor}

\OtherTok{openDoor ::} \DataTypeTok{Door} \CharTok{'Closed -> Door '}\DataTypeTok{Opened}
\NormalTok{openDoor }\DataTypeTok{UnsafeMkDoor} \FunctionTok{=} \DataTypeTok{UnsafeMkDoor}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t closeDoor }\FunctionTok{.}\NormalTok{ openDoor}
\DataTypeTok{Door} \CharTok{'Closed -> Door '}\DataTypeTok{Closed}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t lockDoor }\FunctionTok{.}\NormalTok{ closeDoor }\FunctionTok{.}\NormalTok{ openDoor}
\DataTypeTok{Door} \CharTok{'Closed -> Door '}\DataTypeTok{Locked}
\end{Highlighting}
\end{Shaded}

\subsection{The Phantom Menace}\label{the-phantom-menace}

However, in standard Haskell, we quickly run into some practical problems if we
program with phantom types this way.

For example, how could we write a function to get the state of a door?

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{doorStatus ::} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{DoorState}
\NormalTok{doorStatos _ }\FunctionTok{=} \CommentTok{-- ?}
\end{Highlighting}
\end{Shaded}

(It can be done with an ad-hoc typeclass, but it's not simple, and it's prone to
implementation bugs)

And, perhaps even more important, how can you create a \texttt{Door} with a
given state that isn't known until runtime? If we know the type of our doors at
compiletime, we can just explicitly write
\texttt{UnsafeMkDoor\ ::\ Door\ \textquotesingle{}Opened}. But what if we wanted
to make a door based on a \texttt{DoorState} input?

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mkDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Door}\NormalTok{ s}
\NormalTok{mkDoor }\DataTypeTok{Opened} \FunctionTok{=} \CommentTok{-- ?}
\NormalTok{mkDoor }\DataTypeTok{Closed} \FunctionTok{=} \CommentTok{-- ?}
\NormalTok{mkDoor }\DataTypeTok{Locked} \FunctionTok{=} \CommentTok{-- ?}
\end{Highlighting}
\end{Shaded}

Ah hah, you say. That's easy!

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mkDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Door}\NormalTok{ s}
\NormalTok{mkDoor }\DataTypeTok{Opened} \FunctionTok{=} \DataTypeTok{UnsafeMkDoor}
\NormalTok{mkDoor }\DataTypeTok{Closed} \FunctionTok{=} \DataTypeTok{UnsafeMkDoor}
\NormalTok{mkDoor }\DataTypeTok{Locked} \FunctionTok{=} \DataTypeTok{UnsafeMkDoor}
\end{Highlighting}
\end{Shaded}

Unfortunately, that's not how types work in haskell. Remember that for a
polymorphic type \texttt{forall\ s.\ DoorState\ -\textgreater{}\ Door\ s}, the
\emph{caller} picks the type variable.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t mkDoor }\DataTypeTok{Opened}\OtherTok{ ::} \DataTypeTok{Door} \CharTok{'Closed}
\DataTypeTok{Door} \CharTok{'Closed}
\end{Highlighting}
\end{Shaded}

Oops. What about

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mkDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Door}\NormalTok{ s}
\NormalTok{mkDoor }\DataTypeTok{Opened} \FunctionTok{=} \DataTypeTok{UnsafeMkDoor}\OtherTok{ ::} \DataTypeTok{Door} \CharTok{'Opened}
\NormalTok{mkDoor }\DataTypeTok{Closed} \FunctionTok{=} \DataTypeTok{UnsafeMkDoor}\OtherTok{ ::} \DataTypeTok{Door} \CharTok{'Closed}
\NormalTok{mkDoor }\DataTypeTok{Locked} \FunctionTok{=} \DataTypeTok{UnsafeMkDoor}\OtherTok{ ::} \DataTypeTok{Door} \CharTok{'Locked}
\end{Highlighting}
\end{Shaded}

Here, you get a similar problem. The type variable \texttt{s} \emph{must be able
to be freely chosen} by the caller. And for all of those branches, we return an
\texttt{s} that is potentially different than one asked for by the caller. In
fact, this one doesn't even compile.

\subsection{The Fundamental Issue in
Haskell}\label{the-fundamental-issue-in-haskell}

We've hit upon a fundamental issue in Haskell's type system: \textbf{type
erasure}. In Haskell, types only exist \emph{at compiletime}, for help with
typechecking. They are completely erased at runtime.

This is usually what we want. It's great for performance, and you can bypass
things like the ad-hoc runtime type checking that you have to deal with in
dynamic languages like python.

But in our case, it makes functions like \texttt{doorState} fundamentally
impossible. Or, does it?

\section{The Singleton Pattern}\label{the-singleton-pattern}

A singleton in Haskell is a type that has exactly one inhabitant, and whose
constructor (when pattern matched on) reveals its type.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SingDS}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{SOpened}\OtherTok{ ::} \DataTypeTok{SingDS} \CharTok{'Opened}
    \DataTypeTok{SClosed}\OtherTok{ ::} \DataTypeTok{SingDS} \CharTok{'Closed}
    \DataTypeTok{SLocked}\OtherTok{ ::} \DataTypeTok{SingDS} \CharTok{'Locked}
\end{Highlighting}
\end{Shaded}

Here we're using GADT syntax again. Note that, if we use \texttt{SOpened}, we
will get a \texttt{SingDS\ \textquotesingle{}Opened}. And if we have a
\texttt{SingDS\ \textquotesingle{}Opened}, we know that it was constructed using
\texttt{SOpened}. Essentially, this gives us three values:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{SOpened}\OtherTok{ ::} \DataTypeTok{SingDS} \CharTok{'Opened}
\DataTypeTok{SClosed}\OtherTok{ ::} \DataTypeTok{SingDS} \CharTok{'Closed}
\DataTypeTok{SLocked}\OtherTok{ ::} \DataTypeTok{SingDS} \CharTok{'Locked}
\end{Highlighting}
\end{Shaded}

\subsection{The Power of the Pattern
Match}\label{the-power-of-the-pattern-match}

The power of singletons is that we can now \emph{pattern match} on types,
essentially.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{doorStatus ::} \DataTypeTok{SingDS}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{DoorState}
\NormalTok{doorStatus }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SOpened} \OtherTok{->} \CommentTok{-- in this branch, `s` is `'Opened`}
\NormalTok{        \textbackslash{}_ }\OtherTok{->} \StringTok{"Door is opened"}
    \DataTypeTok{SClosed} \OtherTok{->} \CommentTok{-- in this branch, `s` is `'Closed`}
\NormalTok{        \textbackslash{}_ }\OtherTok{->} \StringTok{"Door is closed"}
    \DataTypeTok{SLocked} \OtherTok{->} \CommentTok{-- in this branch, `s` is `'Locked`}
\NormalTok{        \textbackslash{}_ }\OtherTok{->} \StringTok{"Door is locked"}
\end{Highlighting}
\end{Shaded}

(using LambdaCase syntax because why not)

We can rewrite \texttt{doorStats} to take an additional \texttt{SingDS}, which
we can use to figure out what \texttt{s} is. When we pattern match on it, we
reveal what \texttt{s} is.

The singleton property of \texttt{SingDS} ensures us that whatever \texttt{s}
the \texttt{SingDS} has is the \emph{same} \texttt{s} that the \texttt{Door}
has.

Not only do \emph{we} know what \texttt{s} is, but GHC can also take advantage
of it. In the scope of the case statement branch, GHC \emph{knows} what
\texttt{s} must be:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{closeDoor ::} \DataTypeTok{Door} \CharTok{'Opened -> Door '}\DataTypeTok{Closed}
\OtherTok{lockDoor  ::} \DataTypeTok{Door} \CharTok{'Closed -> Door '}\DataTypeTok{Locked}

\OtherTok{lockAnyDoor ::} \DataTypeTok{SingDS}\NormalTok{ s }\OtherTok{->}\NormalTok{ (}\DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door} \CharTok{'Locked)}
\NormalTok{lockAnyDoor }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SOpened} \OtherTok{->}\NormalTok{ lockDoor }\FunctionTok{.}\NormalTok{ closeDoor}
    \DataTypeTok{SClosed} \OtherTok{->}\NormalTok{ lockDoor}
    \DataTypeTok{SLocked} \OtherTok{->}\NormalTok{ id}
\end{Highlighting}
\end{Shaded}

Note that
\texttt{lockDoor\ .\ closeDoor\ ::\ Door\ \textquotesingle{}Opened\ -\textgreater{}\ Door\ \textquotesingle{}Locked}.
GHC will only allow you to compile that if it \emph{knew} that the input is
\texttt{Door\ \textquotesingle{}Opened}\ldots{}and, because of the GADT pattern
match, it does!

Similar for the \texttt{SLocked\ -\textgreater{}\ id} branch --- \texttt{id} is
only a valid response if \texttt{s} is \texttt{\textquotesingle{}Locked} (and so
\texttt{id\ ::\ Door\ \textquotesingle{}Locked\ -\textgreater{}\ Door\ \textquotesingle{}Locked}).
But, because we pattern matched on \texttt{SLocked}, GHC knows that this is
legal!

We say that \texttt{SOpened} is a runtime \emph{witness} to \texttt{s} being
\texttt{\textquotesingle{}Opened}.

\subsection{Recovering Implicit Passing}\label{recovering-implicit-passing}

One downside is that we are required to manually pass in our witness. Wouldn't
it be nice if we could have it be passed implicitly? We can do something with
typeclasses:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{SingDSI}\NormalTok{ s }\KeywordTok{where}
\OtherTok{    singDS ::} \DataTypeTok{SingDSI}\NormalTok{ s}

\KeywordTok{instance} \DataTypeTok{SingDSI} \CharTok{'Opened where}
\NormalTok{    singDS }\FunctionTok{=} \DataTypeTok{SOpened}
\KeywordTok{instance} \DataTypeTok{SingDSI} \CharTok{'Closed where}
\NormalTok{    singDS }\FunctionTok{=} \DataTypeTok{SClosed}
\KeywordTok{instance} \DataTypeTok{SingDSI} \CharTok{'Locked where}
\NormalTok{    singDS }\FunctionTok{=} \DataTypeTok{SLocked}
\end{Highlighting}
\end{Shaded}

And so now we can do:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{doorStatus_ ::} \DataTypeTok{SingDSI}\NormalTok{ s }\OtherTok{=>} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{DoorState}
\NormalTok{doorStatus_ }\FunctionTok{=}\NormalTok{ doorStatus singDS}

\OtherTok{lockAnyDoor ::} \DataTypeTok{SingDSI}\NormalTok{ s }\OtherTok{=>} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door} \CharTok{'Locked}
\NormalTok{lockAnyDoor_ }\FunctionTok{=}\NormalTok{ lockAnyDoor singDS}
\end{Highlighting}
\end{Shaded}

Here, type inference will tell GHC that you want \texttt{singDS\ ::\ Sing\ s},
and it will pull out the proper singleton for the door you want to check!

\subsubsection{The Same Power}\label{the-same-power}

In Haskell, a constraint \texttt{SingDSI\ s\ =\textgreater{}} is essentially the
same as passing in \texttt{SingDS\ s} explicitly. Either way, you are passing in
a runtime witness that your function can use. You can think of
\texttt{SingDSI\ s\ =\textgreater{}} as passing it in \emph{implicitly}, and
\texttt{SingDS\ s\ -\textgreater{}} as passing it in \emph{explicitly}.

Earlier, I disparaged the ``ad-hoc typeclass'' approach. But, here, the
typeclass isn't quite ad-hoc; it's basically exactly carrying around an implicit
witness of \texttt{s} that we can grab at any time.

\subsection{Fun with Witnesses}\label{fun-with-witnesses}

We can write a nice version of \texttt{mkDoor} this way:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mkDoor ::} \DataTypeTok{SingDS}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s}
\NormalTok{mkDoor }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SOpened} \OtherTok{->} \DataTypeTok{UnsafeMkDoor}
    \DataTypeTok{SClosed} \OtherTok{->} \DataTypeTok{UnsafeMkDoor}
    \DataTypeTok{SLocked} \OtherTok{->} \DataTypeTok{UnsafeMkDoor}
\end{Highlighting}
\end{Shaded}

So we can call it values of \texttt{SingDS}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t mkDoor }\DataTypeTok{SOpened}
\DataTypeTok{Door} \CharTok{'Opened}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t mkDoor }\DataTypeTok{SLocked}
\DataTypeTok{Door} \CharTok{'Locked}
\end{Highlighting}
\end{Shaded}

And now we can't do something silly like pass in \texttt{SLocked} to get a
\texttt{Door\ \textquotesingle{}Opened}!

However, this is still a step away from a \texttt{Door} whose status can vary at
runtime.

\section{Ditching the Phantom}\label{ditching-the-phantom}

Now, sometimes we don't actually care about the state of the door, and we don't
\emph{want} the state of the door in its type. Our \texttt{closeAnyDoor}
function earlier was an example.

We can make a new type, \texttt{SomeDoor}, that contains a door of \emph{some}
status.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeDoor}\OtherTok{ ::} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{MkSomeDoor}\OtherTok{ ::} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ myDoor }\FunctionTok{=} \DataTypeTok{MkSomeDoor}\NormalTok{ (mkDoor }\DataTypeTok{SClosed}\NormalTok{)}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t myDoor}
\OtherTok{myDoor ::} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

But, this isn't too ideal. This is because when we pattern match on the
\texttt{MkSomeDoor} constructor, we have no idea what the original actual status
of the door actually was. This is because of, again, type erasure --- once we
put a \texttt{Door\ s} into
\texttt{MkSomeDoor\ ::\ Door\ s\ -\textgreater{}\ SomeDoor}, the \texttt{s} is
lost to the typechecker forever.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t }\KeywordTok{case}\NormalTok{ myDoor }\KeywordTok{of}
           \DataTypeTok{MkSomeDoor}\NormalTok{ d }\OtherTok{->}\NormalTok{ lockDoor d}
\DataTypeTok{TYPE} \DataTypeTok{ERROR}\FunctionTok{!}  \DataTypeTok{TYPE} \DataTypeTok{ERROR}\FunctionTok{!}  \DataTypeTok{Is}\NormalTok{ d a closed door}\FunctionTok{?}  \DataTypeTok{Who}\NormalTok{ knows}\FunctionTok{!}
\end{Highlighting}
\end{Shaded}

Even though we know we created \texttt{myDoor} with \texttt{SClosed}, once it
becomes a \texttt{SomeDoor}, it's basically indistinguishable from any other
door type, and has to be treated as if we didn't know what the original door
type was.

\subsection{Can I get a witness?}\label{can-i-get-a-witness}

Luckily for us, though, we now have a way to ``store'' \texttt{s} and ``pattern
match'' on it later, using a runtime witness. So, here is our new
\texttt{SomeDoor}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeDoor}\OtherTok{ ::} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{MkSomeDoor}\OtherTok{ ::} \DataTypeTok{SingDS}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ myDoor }\FunctionTok{=} \DataTypeTok{MkSomeDoor} \DataTypeTok{SClosed}\NormalTok{ (mkDoor }\DataTypeTok{SClosed}\NormalTok{)}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t myDoor}
\OtherTok{myDoor ::} \DataTypeTok{SomeDoor}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t }\KeywordTok{case}\NormalTok{ myDoor }\KeywordTok{of}
           \DataTypeTok{MkSomeDoor} \DataTypeTok{SOpened}\NormalTok{ d }\OtherTok{->}\NormalTok{ lockDoor (closeDoor d)}
           \DataTypeTok{MkSomeDoor} \DataTypeTok{SClosed}\NormalTok{ d }\OtherTok{->}\NormalTok{ lockDoor d}
           \DataTypeTok{MkSomeDoor} \DataTypeTok{SLocked}\NormalTok{ d }\OtherTok{->}\NormalTok{ d}
\DataTypeTok{Door} \CharTok{'Locked}
\CommentTok{-- alternatively}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t }\KeywordTok{case}\NormalTok{ myDoor }\KeywordTok{of}
           \DataTypeTok{MkSomeDoor}\NormalTok{ sd d }\OtherTok{->}\NormalTok{ lockAnyDoor sd d}
\DataTypeTok{Door} \CharTok{'Locked}
\end{Highlighting}
\end{Shaded}

By storing the witness of the state of the door inside \texttt{MkSomeDoor}, we
have a way to recover the original type information!

\subsection{An Existential Quandary}\label{an-existential-quandary}

Those who have been exposed to dependent types before might recognize
\texttt{MkSomeDoor} as an existential type constructor. It ``hides'' a type
variable inside it. In our case, using
\texttt{MkSomeDoor\ ::\ SingDS\ s\ -\textgreater{}\ Door\ s\ -\textgreater{}\ SomeDoor}
essentially hides the type variable \texttt{s} from the outside world. To the
type system, a \texttt{SomeDoor} is the same type as any other
\texttt{SomeDoor}. We say that \texttt{SomeDoor} is a \texttt{Door\ s} that is
\emph{existentially quantified} over \texttt{s}.

By pattern matching into \texttt{MkSomeDoor\ sd\ d}, we get the value of the
door (\texttt{d}) back. However, you can't know the \emph{type} of the door (the
\texttt{s} in \texttt{d\ ::\ Door\ s}) because its source could have been
\emph{any} type. The type system requires you to treat \texttt{d} as if it could
be a door of \emph{any} status.

However, because we have \texttt{sd}, we can pattern match on it to recover the
original \emph{type} of the door, as well. This is because whatever type
\texttt{d} originally had, \texttt{sd} \emph{had} to use the constructor
corresponding to it. So if \texttt{d} was originally a
\texttt{Door\ \textquotesingle{}Opened}, \texttt{sd} would have to be
\texttt{SOpened}.

\subsubsection{Some Lingo}\label{some-lingo}

In the language of dependently typed programming, we call \texttt{SomeDoor} a
\textbf{dependent sum}, because you can imagine it basically as:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeDoor} \FunctionTok{=} \DataTypeTok{SDOpened}\NormalTok{ (}\DataTypeTok{SingDS} \CharTok{'Opened) (Door '}\DataTypeTok{Opened}\NormalTok{)}
              \FunctionTok{|} \DataTypeTok{SDClosed}\NormalTok{ (}\DataTypeTok{SingDS} \CharTok{'Closed) (Door '}\DataTypeTok{Closed}\NormalTok{)}
              \FunctionTok{|} \DataTypeTok{SDLocked}\NormalTok{ (}\DataTypeTok{SingDS} \CharTok{'Locked) (Door '}\DataTypeTok{Locked}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

A three-way sum between a \texttt{Door\ \textquotesingle{}Opened}, a
\texttt{Door\ \textquotesingle{}Closed}, and a
\texttt{Door\ \textquotesingle{}Locked}, essentially. If you have a
\texttt{SomeDoor}, it's \emph{either} an opened door, a closed door, or a locked
door.

You might also see \texttt{SomeDoor} called a \textbf{dependent pair}, because
it's basically an existentially quantified tuple of the type (the \texttt{s},
witnessed by the \texttt{SingDS\ s}) with a value (the \texttt{Door\ s}).

\subsection{Types at Runtime}\label{types-at-runtime}

With this last tool, we finally have enough to build a function to ``make'' a
door with the status unknown until runtime:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mkSomeDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{mkSomeDoor }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{Opened} \OtherTok{->} \DataTypeTok{MkSomeDoor} \DataTypeTok{SOpened}\NormalTok{ (mkDoor }\DataTypeTok{SOpened}\NormalTok{)}
    \DataTypeTok{Closed} \OtherTok{->} \DataTypeTok{MkSomeDoor} \DataTypeTok{SClosed}\NormalTok{ (mkDoor }\DataTypeTok{SClosed}\NormalTok{)}
    \DataTypeTok{Locked} \OtherTok{->} \DataTypeTok{MkSomeDoor} \DataTypeTok{SLocked}\NormalTok{ (mkDoor }\DataTypeTok{SLocked}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ mySomeDoor }\FunctionTok{=}\NormalTok{ mkSomeDoor }\DataTypeTok{Opened}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t mySomeDoor}
\DataTypeTok{SomeDoor}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ putStrLn }\FunctionTok{$} \KeywordTok{case}\NormalTok{ mySomeDoor }\KeywordTok{of}
        \DataTypeTok{MkSomeDoor} \DataTypeTok{SOpened}\NormalTok{ _ }\OtherTok{->} \StringTok{"mySomeDoor was opened!"}
        \DataTypeTok{MkSomeDoor} \DataTypeTok{SClosed}\NormalTok{ _ }\OtherTok{->} \StringTok{"mySomeDoor was closed!"}
        \DataTypeTok{MkSomeDoor} \DataTypeTok{SLocked}\NormalTok{ _ }\OtherTok{->} \StringTok{"mySomeDoor was locked!"}
\NormalTok{mySomeDoor was opened}\FunctionTok{!}
\end{Highlighting}
\end{Shaded}

Using \texttt{mkSomeDoor}, we can truly pass in a \texttt{DoorState} that we
generate at runtime (from IO, or a user prompt, or a configuration file, maybe),
and create a \texttt{Door} based on it.

\section{The Singletons Library}\label{the-singletons-library}

Now that we understand some of the benefits of singletons as they relate to
phantom types, we can appreciate what the singletons \emph{library} has to
offer: a fully unified, coherent system for working with singletons of almost
\emph{all} Haskell types!

First, there's Template Haskell for generating our singletons given our type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{DoorState} \FunctionTok{=} \DataTypeTok{Opened} \FunctionTok{|} \DataTypeTok{Closed} \FunctionTok{|} \DataTypeTok{Locked}
  \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Show}\NormalTok{, }\DataTypeTok{Eq}\NormalTok{)}

\NormalTok{genSingletons [}\CharTok{''}\DataTypeTok{DoorState}\NormalTok{]}

\CommentTok{-- or}

\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  data DoorState = Opened | Closed | Locked}
\NormalTok{    deriving (Show, Eq)}
\NormalTok{  |])}
\end{Highlighting}
\end{Shaded}

This generates, for us:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- not the actual code, but essentially what happens}
\KeywordTok{data} \DataTypeTok{Sing}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{SOpened}\OtherTok{ ::} \DataTypeTok{Sing} \CharTok{'Opened}
    \DataTypeTok{SClosed}\OtherTok{ ::} \DataTypeTok{Sing} \CharTok{'Closed}
    \DataTypeTok{SLocked}\OtherTok{ ::} \DataTypeTok{Sing} \CharTok{'Locked}
\end{Highlighting}
\end{Shaded}

\texttt{Sing} is a poly-kinded type constructor (family).
\texttt{STrue\ ::\ Sing\ \textquotesingle{}True} is the singleton for
\texttt{True},
\texttt{SJust\ SOpened\ ::\ Sing\ (\textquotesingle{}Just\ \textquotesingle{}Opened)}
is the singleton for \texttt{Just\ Opened}, etc.

It also generates us instances for \texttt{SingI}, a poly-kinded typeclass:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{SingI} \CharTok{'Opened where}
\NormalTok{    sing }\FunctionTok{=} \DataTypeTok{SOpened}
\KeywordTok{instance} \DataTypeTok{SingI} \CharTok{'Closed where}
\NormalTok{    sing }\FunctionTok{=} \DataTypeTok{SClosed}
\KeywordTok{instance} \DataTypeTok{SingI} \CharTok{'Locked where}
\NormalTok{    sing }\FunctionTok{=} \DataTypeTok{SLocked}
\end{Highlighting}
\end{Shaded}

Which is basically our \texttt{SingDSI} typeclass, except we have instances for
singletons of all kinds! (heh) There's a \texttt{SingI} instance for
\texttt{\textquotesingle{}True}, a \texttt{SingI} instance for \texttt{10}, a
\texttt{SingI} instance for
\texttt{\textquotesingle{}Just\ \textquotesingle{}Opened}, etc.:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\OtherTok{ sing ::} \DataTypeTok{Sing} \CharTok{'True}
\DataTypeTok{STrue}
\NormalTok{ghci}\FunctionTok{>}\OtherTok{ sing ::} \DataTypeTok{Sing}\NormalTok{ (}\CharTok{'Just '}\DataTypeTok{Opened}\NormalTok{)}
\DataTypeTok{SJust} \DataTypeTok{SOpened}
\end{Highlighting}
\end{Shaded}

The great thing about the library is that these types and instances are
generated, that they're correct (note that I could have implemented
\texttt{SingDSI} incorrectly\ldots{}using the library guarantees that I don't),
and that they all work together.

Note that if you have singletons for a kind \texttt{k}, you also have instances
for kind \texttt{Maybe\ k}, as well. And also for \texttt{{[}k{]}}, even!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t }\DataTypeTok{SOpened} \OtherTok{`SCons`} \DataTypeTok{SClosed} \OtherTok{`SCons`} \DataTypeTok{SLocked} \OtherTok{`SCons`} \DataTypeTok{SNil}
\DataTypeTok{Sing} \CharTok{'[ '}\DataTypeTok{Opened}\NormalTok{, }\CharTok{'Closed, '}\DataTypeTok{Locked}\NormalTok{ ]}
\end{Highlighting}
\end{Shaded}

(Remember that, because of \texttt{DataKinds}, \texttt{Maybe} is a kind
constructor, who has two type constructors, the type
\texttt{\textquotesingle{}Nothing} and the type constructor
\texttt{\textquotesingle{}Just\ ::\ k\ -\textgreater{}\ Maybe\ k})

Singletons for all integrate together seamlessly, and you have mechanisms to
generate them for your own type and roll it all into the system!

\subsection{Extra Goodies}\label{extra-goodies}

In addition to generating singletons for our libraries, it gives us convenient
functions for working with the different ``manifestations'' of our types.

Recall that \texttt{DoorState} has four different things associated with it now:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The \emph{type} \texttt{DoorState}, whose value constructors are
  \texttt{Opened}, \texttt{Closed}, and \texttt{Locked}.
\item
  The \emph{kind} \texttt{DoorState}, whose type constructors are
  \texttt{\textquotesingle{}Opened}, \texttt{\textquotesingle{}Closed}, and
  \texttt{\textquotesingle{}Locked}
\item
  The singletons for \texttt{\textquotesingle{}Opened},
  \texttt{\textquotesingle{}Closed}, and \texttt{\textquotesingle{}Locked}.
\item
  The \texttt{SingI} instances for \texttt{\textquotesingle{}Opened},
  \texttt{\textquotesingle{}Closed}, and
  \texttt{\textquotesingle{}Locked\textquotesingle{}}
\end{enumerate}

Kind of confusing, and in the future, when we have real dependent types, we can
hopefully combine all of these manifestations into the same thing. But for now,
we do have to deal with converting between them, and for that, we have,
generated for us:

\begin{itemize}
\item
  \texttt{fromSing\ ::\ Sing\ (s\ ::\ DoorState)\ -\textgreater{}\ DoorState}
  takes us from singletons to values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ fromSing }\DataTypeTok{SOpened}
\DataTypeTok{Opened}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{toSing\ ::\ DoorState\ -\textgreater{}\ SomeSing\ DoorState} takes us
  from values to their (existentially quantified) singletons

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ s }\FunctionTok{=}\NormalTok{ toSing }\DataTypeTok{Opened}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t s}
\OtherTok{s ::} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ putStrLn }\FunctionTok{$} \KeywordTok{case}\NormalTok{ s }\KeywordTok{of}
        \DataTypeTok{SomeSing} \DataTypeTok{SOpened} \OtherTok{->} \StringTok{"Opened."}
        \DataTypeTok{SomeSing} \DataTypeTok{SClosed} \OtherTok{->} \StringTok{"SClosed."}
        \DataTypeTok{SomeSing} \DataTypeTok{SLocked} \OtherTok{->} \StringTok{"SLocked."}
\StringTok{"Opened."}
\end{Highlighting}
\end{Shaded}

  \texttt{SomeSing} is like \texttt{SomeDoor}, an existentially quantified
  singleton:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}\OtherTok{ ::} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{SomeSing}\OtherTok{ ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}

\CommentTok{-- or, more accurately, since `SomeSing` is polykinded}
\KeywordTok{data} \DataTypeTok{SomeSing}\OtherTok{ ::}\NormalTok{ k }\OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{SomeSing}\OtherTok{ ::} \DataTypeTok{Sing}\NormalTok{ (a ;}\FunctionTok{:}\NormalTok{ k) }\OtherTok{->} \DataTypeTok{SomeSing}\NormalTok{ k}
\end{Highlighting}
\end{Shaded}
\end{itemize}

It does this by defining a type class (actually, a ``kind class''),
\texttt{SingKind}, associating each type to the corresponding
datakinds-generated kind. The \texttt{SingKind} instance for \texttt{DoorState}
links the type \texttt{DoorState} to the kind \texttt{DoorState}.

There are definitely more useful utility functions, but we will investigate
these later on in the series! For now, you can look at the
\href{http://hackage.haskell.org/package/singletons/docs/Data-Singletons.html}{documentation}
for the library to see more interesting utility functions!

\section{The Singularity}\label{the-singularity}

In this post, we looked the opportunity for using the singleton pattern to give
us more power when using phantom types, enabling us to do things that we
normally couldn't do. Then, we looked at how the \emph{singletons} library makes
using this pattern extremely easy and smooth to integrate into your existing
code.

You can see all of the ``manual singletons'' code in this post
\href{https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs}{here},
and then see the code re-implemented using the \emph{singletons} library
{[}here{]}{[}singletons-door{]}.

Today we almost exclusively looked at using the \emph{singletons} package and
the singleton pattern as it applies to programming with phantom types. However,
you also might have heard about singletons enabling ``type-level programming'',
as well, and providing tools for writing writing full programs at the type
level.

Be sure to come back as we go deeper into more advanced techniques for
programming with singletons for phantom types, and then also into the wonderful
world that is type-level programming!

To me, before I began using the singletons library, I had all sorts of ad-hoc
trickery everywhere, and every single thing I did at the type level was a bunch
of one-off hacks and tricks. Once I found singletons, however, everything was
revealed, and all became unified, neat, and tidy, utilizing the same mechanisms
for everything. I hope you could see this during this post, but if you didn't,
it will definitely become a recurring theme in this series!

As always, let me know in the comments if you have any questions! You can also
usually find me idling on the freenode \texttt{\#haskell} channel, as well, as
\emph{jle`}. Happy haskelling!