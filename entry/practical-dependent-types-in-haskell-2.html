<!DOCTYPE HTML>
<html><head><title>Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 2) · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="We’re back to continue on our journey in using practical dependent types to write type-safe neural networks! In Part 1, we wrote things out in normal, untyped Haskell, and looked at red flags and general design principles that nudged us in the direction of adding dependent types to our program. We learned to appreciate what dependent types offered in terms of guiding us in writing our code, helping the compiler check our correctness, providing a better interface for users, and more. We also learned how to use singletons to work around some of Haskell’s fundamental limitations to let us pattern match on the structure of types, and how to use typeclasses to generate singletons reflecting the structure of types we are dealing with. (If you read Part 1 before the singletons section was re-written to use the singletons library, here’s a link to the section in specific. This tutorial will assume familiarity with what is discussed there!) All of what we’ve dealt with so far has essentially been with types that are fixed at compile-time. All the networks we’ve made have had static types, with their sizes in their types indicated directly in the source code. Today, we’re going to dive into the world of types that depend on factors unknown until runtime, and see how dependent types in a strongly typed language like Haskell helps us write safer, more correct, and more maintainable code. Along the way, we’ll encounter and learn first-hand about techniques and guiding high-level principles that we can apply to our other dependently typed coding endeavours."><meta property="og:type" content="article"><meta property="og:title" content="Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 2)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 2)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/dependent-haskell-2.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/practical-dependent-types-in-haskell-2.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled…really just the king of great languages.">Haskell</a>, <a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category" title="My slight ramblings on subjects of interest (to me and hopefully to you too!).
Lots of surveys and introducts to new subjects.">Ramblings</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>We’re back to continue on <a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html">our journey</a> in using practical dependent types to write type-safe neural networks! In <a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html">Part 1</a>, we wrote things out in normal, untyped Haskell, and looked at red flags and general design principles that nudged us in the direction of adding dependent types to our program. We learned to appreciate what dependent types offered in terms of guiding us in writing our code, helping the compiler check our correctness, providing a better interface for users, and more.</p>
<p>We also learned how to use singletons to work around some of Haskell’s fundamental limitations to let us “pattern match” on the structure of types, and how to use typeclasses to generate singletons reflecting the structure of types we are dealing with.</p>
<p>(If you read <a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html">Part 1</a> <em>before</em> the singletons section was re-written to use the <a href="https://hackage.haskell.org/package/singletons">singletons</a> library, <a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html#singletons-and-induction">here’s a link to the section</a> in specific. This tutorial will assume familiarity with what is discussed there!)</p>
<p>All of what we’ve dealt with so far has essentially been with types that are fixed at compile-time. All the networks we’ve made have had “static” types, with their sizes in their types indicated directly in the source code.</p>
<p>Today, we’re going to dive into the world of types that <em>depend</em> on factors unknown until runtime, and see how dependent types in a strongly typed language like Haskell helps us write safer, more correct, and more maintainable code. Along the way, we’ll encounter and learn first-hand about techniques and guiding high-level principles that we can apply to our other dependently typed coding endeavours.</p>
<h2 id="run-time-types">Run-time Types</h2>
<p>Recall the type we had for our neural networks:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">Network</span>
<span class="dt">Network</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> [<span class="dt">Nat</span>] <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre></div>
<p>They’re of the form <code>Network i hs o</code>, where <code>i</code> is the size of the input vector it expects, <code>hs</code> is the list of hidden layer sizes, and <code>o</code> is the size of the output vector it produces. Something of type <code>Network 10 '[6, 4] 3</code> is a network with 10 input nodes, two input layers of size 6 and 4, and 3 output nodes.</p>
<p>This is great and all, but there’s an apparent severe limitation to this: Haskell is a statically typed language, right? So doesn’t this mean that using a network requires that you know the entire structure of the network at compile-time?</p>
<p>It’s conceivable that you might be able to have the input and output sizes known at compile-time, but it’s probably likely that you <em>don’t</em> know the what you want your hidden layer structure to be in advance. You might want to load it from a configuration file, or have it depend on user input. But can a type really depend on things that you can’t know until runtime?</p>
<p>To illustrate more clearly:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="st">&quot;What hidden layer structure do you want?&quot;</span>
    hs  <span class="ot">&lt;- readLn        ::</span> <span class="dt">IO</span> [<span class="dt">Integer</span>]
    net <span class="ot">&lt;- randomNetwork ::</span> <span class="dt">IO</span> <span class="dv">10</span> <span class="fu">???</span> <span class="dv">3</span>   <span class="co">-- what is ???</span>
    <span class="co">-- ...?</span></code></pre></div>
<p>You would <em>want</em> to put <code>hs</code> there where <code>???</code> is, but…<code>???</code> has to be a type (of kind <code>[Nat]</code>). <code>hs</code> is a value (of type <code>[Integer]</code>). It’s clear here that the <em>type</em> of our network depends on something we can’t write down or decide until runtime.</p>
<h3 id="an-existential-crisis">An Existential Crisis</h3>
<p>There are a couple of ways to go about this, actually — we’ll go through them, and we’ll also see at the end how they are all really fundamentally the same thing.</p>
<h4 id="types-hiding-behind-constructors">Types hiding behind constructors</h4>
<p>Now, having the entire structure of your neural network in the type is nice and all for cool tricks like <code>randomNet</code>…but do you <em>really</em> want to work with this directly? After all, from the user’s perspective, the user really only ever needs to know <code>i</code> and <code>o</code>: What vectors the network <em>expects</em>, and what vectors the network <em>outputs</em>. In the end, all a (feed-forward) Neural Network really is is an abstraction over a function <code>R i -&gt; R o</code>.</p>
<p>Remember, the main benefits of having the entire structure in the type was to help us <em>implement</em> our functions more safely, with the compiler’s help, and also for cute return type polymorphism tricks like <code>randomNet</code> and <code>getNet</code>. The first type of benefit really doesn’t benefit the <em>user</em> of the network.</p>
<p>Imagine that we had written a <code>Network</code> type that <em>didn’t</em> have the internal structure in the type —</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">OpaqueNet</span> i o</code></pre></div>
<p>Recall that our issue earlier was that we had to write <code>Network i ??? o</code>, but we had no idea what to put in for <code>???</code>. But, what if we worked with an <code>OpaqueNet i o</code>, we wouldn’t even care! We wouldn’t have to tell GHC what the internal structure is.</p>
<p>We can implement it as an “existential” wrapper over <code>Network</code>, actually:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L84-85</span>
<span class="kw">data</span> <span class="dt">OpaqueNet</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
    <span class="dt">ONet</span><span class="ot"> ::</span> <span class="dt">Network</span> i hs o <span class="ot">-&gt;</span> <span class="dt">OpaqueNet</span> i o</code></pre></div>
<p>So, if you have <code>net :: Network 6 '[10,6,3] 2</code>, you can create <code>ONet net :: OpaqueNet 6 2</code>. When you use the <code>ONet</code> constructor, the structure of the hidden layers disappears from the type!</p>
<p>How do we use this type? We <em>pattern match</em> on <code>ONet</code> to get the net back, and we can use them:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L87-92</span>
<span class="ot">numHiddens ::</span> <span class="dt">OpaqueNet</span> i o <span class="ot">-&gt;</span> <span class="dt">Int</span>
numHiddens <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">ONet</span> n <span class="ot">-&gt;</span> go n
  <span class="kw">where</span>
<span class="ot">    go ::</span> <span class="dt">Network</span> i hs o <span class="ot">-&gt;</span> <span class="dt">Int</span>
    go <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">O</span> _      <span class="ot">-&gt;</span> <span class="dv">0</span>
               _ <span class="fu">:&amp;~</span> n&#39; <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">+</span> go n&#39;</code></pre></div>
<p>With the <em>ScopedTypeVariables</em> extension, we can even bring <code>hs</code> back into scope, as in <code>ONet (n :: Network i hs o) -&gt; ...</code></p>
<p>This pattern is sometimes called the <strong>dependent pair</strong>, because pattern matching on <code>ONet</code> gives yields the hidden existential (<code>hs</code>) and also a type that is based on it (<code>Network i hs o</code>). It’s like <code>hs</code> “paired” with <code>Network i hs o</code>. Pattern match on the results to give both the type (<code>hs</code>) <em>and</em> the data structure. (If we had implemented it as <code>ONet :: Sing hs -&gt; Network i hs o -&gt; OpaqueNet i o</code>, this would be slightly clearer!)</p>
<p>And here’s the key to making this all work: once you <em>do</em> pattern match on <code>ONet</code>, you have to handle the <code>hs</code> in a <em>completely polymorphic way</em>. You’re not allowed to assume anything about <code>hs</code>…you have to provide a completely parametrically polymorphic way of dealing with it!</p>
<p>For example, this function is completely <em>not</em> ok:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bad ::</span> <span class="dt">OpaqueNet</span> i o <span class="ot">-&gt;</span> <span class="dt">Network</span> i hs o
bad <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">ONet</span> n <span class="ot">-&gt;</span> n          <span class="co">-- nope, not ok at all.</span></code></pre></div>
<p>Why not? Well, a type signature like <code>OpaqueNet i o -&gt; Network i hs o</code> means that the <em>caller</em> can decide what <code>hs</code> can be — just like <code>read :: Read a =&gt; String -&gt; a</code>, where the caller decides what <code>a</code> is.</p>
<p>Of course, this <em>isn’t</em> the case with the way we’ve written the function…the function only returns a <em>specific</em> <code>hs</code> that the <em>function</em> decides. The <em>caller</em> has to accommodate whatever is inside <code>ONet</code>.</p>
<h4 id="the-universal-and-the-existential">The Universal and the Existential</h4>
<p>We just brushed here on something at the heart of using existential types in Haskell: the issue of who has the power to decide what the types will be instantiated as.</p>
<p>Most polymorphic functions you work with in Haskell are “universally qualified”. For example, for a function like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</code></pre></div>
<p><code>a</code> and <code>b</code> are universally quantified, which means that the person who <em>uses</em> <code>map</code> gets to decide what <code>a</code> and <code>b</code> are. To be more explicit, that type signature can be written as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> forall a b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</code></pre></div>
<p>This means that <code>map</code> is defined in a way that will work for <em>any</em> <code>a</code> and <code>b</code> that the <em>caller</em> wants. As a caller, you can request:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)    <span class="ot">-&gt;</span> [<span class="dt">Int</span>]    <span class="ot">-&gt;</span> [<span class="dt">Bool</span>]
map<span class="ot"> ::</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Void</span>) <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Void</span>]
map<span class="ot"> ::</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>)) <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> [<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>]</code></pre></div>
<p>Consequentially, the function has to be implemented in a way that will work for <em>any</em> <code>a</code> and <code>b</code>. The function’s implementation has the burden of being flexible enough to handle whatever the caller asks for.</p>
<p>But, for a function like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foo ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">OpaqueNet</span> i o</code></pre></div>
<p>While the caller can choose what <code>i</code> and <code>o</code> are, the <em>function</em> gets to choose what <code>hs</code> (in the hidden <code>Network i hs o</code>) is.</p>
<p>If I want to <em>use</em> the thing that <code>foo</code> returns…then <em>I</em> have to be flexible. <em>I</em> have the burden of being flexible enough to handle whatever the <em>function</em> returns.</p>
<p>In summary:</p>
<ul>
<li><p>For universally quantified types, the <em>caller</em> chooses the type being instanced, and the <em>function’s implementation</em> has to accommodate any choice.</p></li>
<li><p>For existentially quantified types, the <em>function’s implementation</em> chooses the type being instanced, and the <em>caller</em> has to accommodate any choice.</p></li>
</ul>
<p>Indeed, we saw earlier that if we ever wanted to <em>use</em> the <code>Network i hs o</code> inside the <code>OpaqueNet i o</code>, we were forced to deal with it in a parametrically polymorphic way. We had to be able to handle <em>any</em> <code>hs</code> that the <code>ONet</code> could throw at us!</p>
<h4 id="a-familiar-friend">A familiar friend</h4>
<p>I called <code>OpaqueNet i o</code> a “dependent pair” earlier, which existentially quantifies over <code>hs</code>. But there’s another common term for it: a <strong>dependent sum</strong>.</p>
<p>People familiar with Haskell might recognize that “sum types” are <code>Either</code>-like types that can be one thing or another. Sum types are one of the first things you learn about in Haskell — heck, even <code>Maybe a</code> is the sum of <code>a</code> and <code>()</code>. Dependent pairs/existential types actually are very similar to <code>Either</code>/sum types, in spirit, and it might help to see the parallel so that you can see that they’re nothing scary, and that the fundamentals/intuition of working with existential types in Haskell is no different than working with <code>Either</code>!</p>
<p>If I had:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foo ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">Bool</span></code></pre></div>
<p>I have to handle the result…but I have to handle it for both the case where I get an <code>Int</code> and the case where I get a <code>Bool</code>. The <em>function</em> gets to pick what type I have to handle (<code>Int</code> or <code>Bool</code>), and <em>I</em> have to adapt to whatever it returns. Sound familiar? In fact, you can even imagine that <code>OpaqueNet i o</code> as being just a recursive <em>Either</em> over <code>'[]</code>, <code>'[1]</code>, <code>'[1,2]</code>, etc.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>And, remember that the basic way of handling an <code>Either</code> and figuring out what the type of the value is inside is through <em>pattern matching</em> on it. You can’t know if an <code>Either Int Bool</code> contains an <code>Int</code> or <code>Bool</code> until you pattern match. But, once you do, all is revealed, and GHC lets you take advantage of knowing the type.</p>
<p>For <code>OpaqueNet i o</code>, it’s the same! You don’t know the actual type of the <code>Network i hs o</code> it contains until you <em>pattern match</em> on the <code>Sing hs</code>! (Or potentially, the network itself) But, once you pattern match on it, all is revealed…and GHC lets you take advantage of knowing the type!</p>
<h3 id="reification">Reification</h3>
<p>Time to pull it all together.</p>
<p>For simplicity, let’s re-write <code>randomNet</code> the more sensible way — with the explicit singleton input style:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L49-56</span>
<span class="ot">randomNet&#39; ::</span> forall m i hs o<span class="fu">.</span> (<span class="dt">MonadRandom</span> m, <span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o)
           <span class="ot">=&gt;</span> <span class="dt">Sing</span> hs <span class="ot">-&gt;</span> m (<span class="dt">Network</span> i hs o)
randomNet&#39; <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">SNil</span>            <span class="ot">-&gt;</span>     <span class="dt">O</span> <span class="fu">&lt;$&gt;</span> randomWeights
                   <span class="dt">SNat</span> <span class="ot">`SCons`</span> ss <span class="ot">-&gt;</span> (<span class="fu">:&amp;~</span>) <span class="fu">&lt;$&gt;</span> randomWeights <span class="fu">&lt;*&gt;</span> randomNet&#39; ss

<span class="ot">randomNet ::</span> forall m i hs o<span class="fu">.</span> (<span class="dt">MonadRandom</span> m, <span class="dt">KnownNat</span> i, <span class="dt">SingI</span> hs, <span class="dt">KnownNat</span> o)
          <span class="ot">=&gt;</span> m (<span class="dt">Network</span> i hs o)
randomNet <span class="fu">=</span> randomNet&#39; sing</code></pre></div>
<p>We use <code>sing :: SingI hs =&gt; Sing hs</code> to go call the <code>Sing hs -&gt;</code>-style function from the <code>SingI hs =&gt;</code> one.</p>
<p>Recall that I recommend (personally, and subjectively) a style where your external API functions (and typeclass instances) are implemented in <code>SingI a =&gt;</code> style, and your internal ones in <code>Sing a -&gt;</code> style. This lets all of your internal functions fit together more nicely (<code>Sing a -&gt;</code> style tends to be easier to write in, especially if you stay in it the entire time) while at the same time removing the burden of calling with explicit singletons from people using the functionality externally.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> A <code>Sing a</code> is a normal Haskell value, but <code>SingI hs</code> is a typeclass instance, and typeclasses in Haskell are magical, global, potentially incoherent, and not really fun to work with!</p>
<p>Now, we still need to somehow get our list of integers to the type level, so we can create a <code>Network i hs o</code> to stuff into our <code>ONet</code>. And for that, the <em>singletons</em> library offers the necessary tooling. It gives us <code>SomeSing</code>, which is a lot like our <code>OpaqueNet</code> above, wrapping the <code>Sing a</code> inside an existential data constructor. <code>toSing</code> takes the term-level value (for us, an <code>[Integer]</code>) and returns a <code>SomeSing</code> wrapping the type-level value (for us, a <code>[Nat]</code>). When we pattern match on the <code>SomeSing</code> constructor, we get <code>a</code> in scope!</p>
<p>In an ideal world, <code>SomeSing</code> would look like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeSing</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
    <span class="dt">SomeSing</span><span class="ot"> ::</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> k) <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> k</code></pre></div>
<p>And you can have</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foo ::</span> <span class="dt">SomeSing</span> <span class="dt">Bool</span>
foo <span class="fu">=</span> <span class="dt">SomeSing</span> <span class="dt">STrue</span>

<span class="ot">bar ::</span> <span class="dt">SomeSing</span> <span class="dt">Nat</span>
bar <span class="fu">=</span> <span class="dt">SomeSing</span> (<span class="dt">SNat</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="dv">10</span>)</code></pre></div>
<p>But because <em>singletons</em> was implemented before the <em>TypeInType</em> extension in GHC 8, it has to be implemented with clunky “Kind Proxies”. In a future version of <em>singletons</em>, they’ll be implemented this way. Right now, in the current system, <code>SomeSing STrue :: SomeSing (KProxy :: KProxy Bool)</code>, and <code>bar :: SomeSing (KProxy :: KProxy Nat)</code>.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> However, for the most part, the actual <em>usage</em> of <code>SomeSing</code>, so we can ignore this slight wart when we are actually writing code.</p>
<p>Pattern matching looks like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="st">&quot;How many cats do you own?&quot;</span>
    c <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Integer</span>
    <span class="kw">case</span> toSing c <span class="kw">of</span>
      <span class="dt">SomeSing</span> (<span class="dt">SNat</span><span class="ot"> ::</span> <span class="dt">Sing</span> n) <span class="ot">-&gt;</span> <span class="co">-- ...</span></code></pre></div>
<p>Now, inside the case statement branch (the <code>...</code>), we have <em>type</em> <code>n :: Nat</code> in scope! And by pattern matching on the <code>SNat</code> constructor, we also have a <code>KnownNat n</code> instance (As discussed in <a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html#singletons-and-induction">previous part</a>).</p>
<p>(<code>toSing</code> works using a simple typeclass mechanism with associated types whose job is to associate <em>value</em>’s types with the kinds of their singletons. It associates <code>Bool</code> the type with <code>Bool</code> the kind, <code>Integer</code> the type with <code>Nat</code> the kind, <code>[Integer]</code> the type with <code>[Nat]</code> the kind, etc., and it does it with straightforward plane jane applications of type families — here’s a <a href="https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html">nice tutorial on type families</a> courtesy of Oliver Charles.)</p>
<p>We now have enough to write our <code>randomONet</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L116-120</span>
<span class="ot">randomONet ::</span> (<span class="dt">MonadRandom</span> m, <span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o)
           <span class="ot">=&gt;</span> [<span class="dt">Integer</span>]
           <span class="ot">-&gt;</span> m (<span class="dt">OpaqueNet</span> i o)
randomONet hs <span class="fu">=</span> <span class="kw">case</span> toSing hs <span class="kw">of</span>
                  <span class="dt">SomeSing</span> ss <span class="ot">-&gt;</span> <span class="dt">ONet</span> <span class="fu">&lt;$&gt;</span> randomNet&#39; ss</code></pre></div>
<p>This process of bringing a term-level value into the type level is known in Haskell as <strong>reification</strong>. With this, our original goal is (finally) within reach:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L158-164</span>
<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="st">&quot;What hidden layer structure do you want?&quot;</span>
    hs <span class="ot">&lt;-</span> readLn
    <span class="dt">ONet</span> (<span class="ot">net ::</span> <span class="dt">Network</span> <span class="dv">10</span> hs <span class="dv">3</span>) <span class="ot">&lt;-</span> randomONet hs
    print net
    <span class="co">-- blah blah stuff with our dynamically generated net</span></code></pre></div>
<h4 id="the-boundary">The Boundary</h4>
<p>With the power of existentially quantified types (like in <code>SomeSing</code>), we essentially gained the ability to work with types that depend on runtime results.</p>
<p>In a way, you can consider the <code>toSing</code> and the <code>SomeSing</code> as our “boundary” between the “untyped world” and the “typed world”. This layer (and the process of reification) cleanly separates the two.</p>
<p>This “boundary” can be thought of as a lot like the boundary we talk about between “pure” functions and values and “impure” (IO, etc.) ones. We say to always write as much of your program as possible in the “pure” world, and to separate and pull out as much logic as you can to be pure logic. That’s sort of one of the first things you learn about as a Haskell programmer: how to separate logic that <em>can</em> be pure from logic that is “impure” (IO, etc.), and then “combine them” at the very end, as late as possible.</p>
<p>The common response to this is: “Well, if the final program is going to be IO in the end anyway, why bother separating out pure and impure parts of your logic?”</p>
<p>But, we know that we gain separation of concerns, the increased ability to reason with your code and analyze what it does, the compiler’s ability to check what you write, the limitation of implementations, etc. … all reasons any Haskeller should be familiar with reciting.</p>
<p>You can think of the general philosophy of working with typed/untyped worlds as being the same thing. You can write as much of your program as possible in the “typed” world, like we did in Part 1. Take advantage of the increased ability to reason with your code, parametric polymorphism helping you <em>write</em> your code, limit your implementations, nab you compiler help, etc. All of those are benefits of working in the typed world.</p>
<p>Then, write what you must in your “untyped” world, such as dealing with values that pop up at runtime like the <code>[Integer]</code> above.</p>
<p>Finally, at the end, <em>unite</em> them at the boundary. Pass the control football from the untyped world to the typed world!</p>
<h3 id="continuation-based-existentials">Continuation-Based Existentials</h3>
<p>There’s another way in Haskell that we work with existential types that can be more natural and easy to work with in a lot of cases.</p>
<p>Remember that when we pattern match on an existential data type, you have to work with the values in the constructor in a parametrically polymorphic way. For example, if we had:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">oNetToFoo ::</span> <span class="dt">OpaqueNet</span> i o <span class="ot">-&gt;</span> <span class="dt">Foo</span>
oNetToFoo <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">ONet</span> n <span class="ot">-&gt;</span> f n</code></pre></div>
<p><code>f</code> has to take a <code>Sing hs</code> and a <code>Network i hs o</code>, but deal with it in a way that works <em>for all</em> <code>hs</code>. It has to be:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> forall hs<span class="fu">.</span> <span class="dt">Network</span> i hs o <span class="ot">-&gt;</span> <span class="dt">Foo</span></code></pre></div>
<p>That is, it can’t be written for <em>only</em> <code>'[5]</code> or <em>only</em> <code>'[6,3]</code>…it has to work for <em>any</em> <code>hs</code>. That’s the whole “existential vs. universal quantification” thing we just talked about.</p>
<p>Well, we could really also just skip the data type together and represent an existential type as something <em>taking</em> the continuation <code>f</code> and giving it what it needs.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L126-126</span>
<span class="kw">type</span> <span class="dt">OpaqueNet&#39;</span> i o r <span class="fu">=</span> (forall hs<span class="fu">.</span> <span class="dt">Network</span> i hs o <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</code></pre></div>
<p>“Tell me how you would make an <code>r</code> if you had a <code>Network i hs o</code> (that works for any <code>hs</code>) and I’ll make it for you!”</p>
<p>(This takes advantage of Rank-N types. If you’re unfamiliar with it, Gregor Riegler has a <a href="http://sleepomeno.github.io/blog/2014/02/12/Explaining-Haskell-RankNTypes-for-all/">nice tutorial</a> on it.)</p>
<p>This “continuation transformation” is known as formally <strong>skolemization</strong>.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> We can “wrap” a <code>Network i hs o</code> into an <code>OpaqueNet' i o r</code> pretty straightforwardly:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L128-129</span>
<span class="ot">oNet&#39; ::</span> <span class="dt">Network</span> i hs o <span class="ot">-&gt;</span> <span class="dt">OpaqueNet&#39;</span> i o r
oNet&#39; n <span class="fu">=</span> \f <span class="ot">-&gt;</span> f n</code></pre></div>
<p>Let’s write a version of <code>randomONet</code> that returns a continuation-style existential, instead:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withRandomONet&#39; ::</span> (<span class="dt">MonadRandom</span> m, <span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o)
                <span class="ot">=&gt;</span> [<span class="dt">Integer</span>]
                <span class="ot">-&gt;</span> (forall hs<span class="fu">.</span> <span class="dt">Sing</span> hs <span class="ot">-&gt;</span> <span class="dt">Network</span> i hs o <span class="ot">-&gt;</span> m r)
                <span class="ot">-&gt;</span> m r
<span class="co">--         aka, =&gt; [Integer]</span>
<span class="co">--              -&gt; OpaqueNet&#39; i o (m r)</span>
withRandomONet&#39; hs f <span class="fu">=</span> <span class="kw">case</span> toSing hs <span class="kw">of</span>
                         <span class="dt">SomeSing</span> ss <span class="ot">-&gt;</span> <span class="kw">do</span>
                           net <span class="ot">&lt;-</span> randomNet&#39; ss
                           f ss net</code></pre></div>
<p>But, hey, because we’re skolemizing everything, let’s do it with the skolemized version of <code>toSing</code>, <code>withSomeSing</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- the skolemized `toSing`/`SomeSing`:</span>
<span class="ot">withSomeSing ::</span> [<span class="dt">Integer</span>]
             <span class="ot">-&gt;</span> (forall (<span class="ot">hs ::</span> [<span class="dt">Nat</span>])<span class="fu">.</span> <span class="dt">Sing</span> hs <span class="ot">-&gt;</span> r)
             <span class="ot">-&gt;</span> r</code></pre></div>
<p>Because why not? Skolemize all the things!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L148-156</span>
<span class="ot">withRandomONet&#39; ::</span> (<span class="dt">MonadRandom</span> m, <span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o)
                <span class="ot">=&gt;</span> [<span class="dt">Integer</span>]
                <span class="ot">-&gt;</span> (forall hs<span class="fu">.</span> <span class="dt">Network</span> i hs o <span class="ot">-&gt;</span> m r)
                <span class="ot">-&gt;</span> m r
<span class="co">--         aka, =&gt; [Integer]</span>
<span class="co">--              -&gt; OpaqueNet&#39; i o (m r)</span>
withRandomONet&#39; hs f <span class="fu">=</span> withSomeSing hs <span class="fu">$</span> \ss <span class="ot">-&gt;</span> <span class="kw">do</span>
                         net <span class="ot">&lt;-</span> randomNet&#39; ss
                         f net</code></pre></div>
<p>We can use it to do the same things we used the constructor-based existential for, as well…and, in a way, it actually seems (oddly) more natural.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L166-172</span>
<span class="ot">main&#39; ::</span> <span class="dt">IO</span> ()
main&#39; <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="st">&quot;What hidden layer structure do you want?&quot;</span>
    hs <span class="ot">&lt;-</span> readLn
    withRandomONet&#39; hs <span class="fu">$</span> \(<span class="ot">net ::</span> <span class="dt">Network</span> <span class="dv">10</span> hs <span class="dv">3</span>) <span class="ot">-&gt;</span> <span class="kw">do</span>
      print net
      <span class="co">-- blah blah stuff with our dynamically generated net</span></code></pre></div>
<p>You can sort of see that, like the case statement pattern match represented the lexical “wall”/“boundary” between the untyped and typed world when using constructor-style existentials, the <code>... $ \net -&gt; ...</code> can be thought of the “wall” for the continuation-style existentials.</p>
<h2 id="a-tale-of-two-styles">A Tale of Two Styles</h2>
<p>So, we’ve just discussed two ways of doing the same thing, essentially. Two styles of representing/working with existential types. The two are equivalent, in that you can always “convert” between one or the other, but the choice of which one you use/reach for/offer can make a difference in code clarity.</p>
<p>I don’t have much general advice for which one to provide. After working with both styles a lot (sometimes, libraries only offer one style), you sort of start to get a feel for which one you like more in which situations. In the end, I don’t think there are any hard or fast rules. Just use whichever one you feel is more readable!</p>
<p>That being said, here are some general Pros and Cons that I’ve encountered over the years. This list is by no means exhaustive.</p>
<ul>
<li><p>Most obviously, continuation-style doesn’t require you to define a throwaway data type/constructor. While new types are cheap in Haskell, they force your users to learn a new set of types and constructors for every single existential type you return. If you or the library you’re writing uses/returns a <em>lot</em> of different existentially qualified types, all those extra dumb wrappers are a huge hassle.</p></li>
<li><p>When you have to use several existentials at once, continuation-style is much better because each nested existential doesn’t force another level of indentation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foo <span class="fu">=</span> withSomeSing x <span class="fu">$</span> \sx <span class="ot">-&gt;</span>
      withSomeSing y <span class="fu">$</span> \sy <span class="ot">-&gt;</span>
      withSomeSing z <span class="fu">$</span> \sz <span class="ot">-&gt;</span>
        <span class="co">-- ...</span></code></pre></div>
<p>vs.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foo <span class="fu">=</span> <span class="kw">case</span> toSing x <span class="kw">of</span>
        <span class="dt">SomeSing</span> sx <span class="ot">-&gt;</span>
          <span class="kw">case</span> toSing y <span class="kw">of</span>
            <span class="dt">SomeSing</span> sy <span class="ot">-&gt;</span>
              <span class="kw">case</span> toSing z <span class="kw">of</span>
                <span class="dt">SomeSing</span> sz <span class="ot">-&gt;</span>
                  <span class="co">-- ...</span></code></pre></div>
<p>Every time you nest a case statement, you actually waste <em>two</em> levels of indentation, which can be annoying even at 2-space indentation. But you don’t need <em>any</em> to nest in the continuation style!</p></li>
<li><p>If you’re working monadically, though, you can take advantage of do notation and <em>ScopedTypeVariables</em> for a nicer style that doesn’t require any nesting at all:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
    <span class="dt">ONet</span> n1 <span class="ot">&lt;-</span> randomONet [<span class="dv">7</span>,<span class="dv">5</span>,<span class="dv">3</span>]<span class="ot"> ::</span> <span class="dt">IO</span> (<span class="dt">OpaqueNet</span> <span class="dv">10</span> <span class="dv">1</span>)
    <span class="dt">ONet</span> n2 <span class="ot">&lt;-</span> randomONet [<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>]<span class="ot"> ::</span> <span class="dt">IO</span> (<span class="dt">OpaqueNet</span> <span class="dv">10</span> <span class="dv">1</span>)
    <span class="dt">ONet</span> n3 <span class="ot">&lt;-</span> randomONet [<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>]<span class="ot"> ::</span> <span class="dt">IO</span> (<span class="dt">OpaqueNet</span> <span class="dv">10</span> <span class="dv">1</span>)
    hs <span class="ot">&lt;-</span> readLn
    <span class="dt">ONet</span> (<span class="ot">n4 ::</span> <span class="dt">Network</span> <span class="dv">10</span> hs <span class="dv">1</span>) <span class="ot">&lt;-</span> randomONet hs
    <span class="co">-- ...</span></code></pre></div>
<p>Which is arguably nicer than</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> withRandomONet&#39; [<span class="dv">7</span>,<span class="dv">5</span>,<span class="dv">3</span>] <span class="fu">$</span> \n1 <span class="ot">-&gt;</span>
       withRandomONet&#39; [<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>] <span class="fu">$</span> \n2 <span class="ot">-&gt;</span>
       withRandomONet&#39; [<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>] <span class="fu">$</span> \n3 <span class="ot">-&gt;</span> <span class="kw">do</span>
         hs <span class="ot">&lt;-</span> readLn
         withRandomONet&#39; hs <span class="fu">$</span> \(<span class="ot">n4 ::</span> <span class="dt">Network</span> <span class="dv">10</span> hs <span class="dv">1</span>) <span class="ot">-&gt;</span> <span class="kw">do</span>
           <span class="co">-- ...</span></code></pre></div>
<p>A lot of libraries return existentials in <code>Maybe</code>’s (<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-TypeLits.html#v:someNatVal">base is guilty</a>), so it can be useful for those, too!</p>
<p>This is less useful for things like <code>toSing</code> where things are <em>not</em> returned in a monad. You could wrap it in Identity, but that’s kind of silly:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foo <span class="fu">=</span> runIdentity <span class="fu">$</span> <span class="kw">do</span>
        <span class="dt">SomeSing</span> sx <span class="ot">&lt;-</span> <span class="dt">Identity</span> <span class="fu">$</span> toSing x
        <span class="dt">SomeSing</span> sy <span class="ot">&lt;-</span> <span class="dt">Identity</span> <span class="fu">$</span> toSing y
        <span class="dt">SomeSing</span> sz <span class="ot">&lt;-</span> <span class="dt">Identity</span> <span class="fu">$</span> toSing z
        return <span class="fu">$</span> <span class="co">-- ...</span></code></pre></div></li>
<li><p>Constructor-style is necessary for writing typeclass instances. You can’t write a <code>Show</code> instance for <code>(forall hs. Network i hs o -&gt; r) -&gt; r</code>, but you can write one for <code>OpaqueNet i o</code>. We’ll also be writing <code>Binary</code> instances later for serialization/deserialization, and we’ll need the wrapper for sure.</p></li>
<li><p>When writing functions that <em>take</em> existentials as inputs, the constructor-style is arguably more natural.</p>
<p>For example, we wrote a function to find the number of hidden layers in a network earlier:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">numHiddens ::</span> <span class="dt">OpaqueNet</span> i o <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre></div>
<p>But the continuation-style version would have a slightly messier type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">numHiddens&#39; ::</span> ((forall hs<span class="fu">.</span> <span class="dt">Network</span> i hs o <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span>)
            <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre></div>
<p>Even with with the type synonym, it’s a little weird.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">numHiddens&#39; ::</span> <span class="dt">OpaqueNet&#39;</span> i o <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre></div>
<p>This is why you’ll encounter more functions <em>returning</em> continuation-style existentials than <em>taking</em> them in the wild, for the most part.</p></li>
</ul>
<p>These are just general principals, and they’re not hard-fast rules. This list isn’t exhaustive, and reflects my current progress in my journey towards a dependently typed lifestyle and also the things I can think of as I’m writing. If you come back in a month, you might see more things listed here!</p>
<p>All said, I do find myself very happy when I see that a library I’m using offers <em>both</em> styles for me to use. And I’ve been known to submit PR’s to a library to have it offer one style or another, if it’s lacking.</p>
<p>Be judicious. If you’re writing a library, don’t spam it with too many throwaway constructors. If you’re writing an application, be wary of indentation creep. After a while, you’ll begin to intuitively see which style shines in which situations! (And, in some case, there might not even be a definitive “better” style to use.)</p>
<h2 id="serializing-networks">Serializing Networks</h2>
<p>Let’s apply what we learned about existential types and reification to another simple application: serialization.</p>
<h3 id="recap-on-the-binary-library">Recap on the Binary Library</h3>
<p>Serializing networks of <em>known</em> size — whose sizes are statically in their types — is pretty straightforward. I’m going to be using the <em><a href="https://hackage.haskell.org/package/binary">binary</a></em> library, which offers a very standard typeclass-based approach for serializing and deserializing data. There are a lot of tutorials online (and I even <a href="https://blog.jle.im/entry/streaming-huffman-compression-in-haskell-part-2-binary.html">wrote a small one</a> myself a few years ago), but a very high-level view is that the library offers a typeclass for describing serialization schemes for different types.</p>
<p>In practice, we usually don’t write our own instances from scratch. Instead, we use GHC’s generics features to give us instances for free:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L22-38</span>
<span class="kw">data</span> <span class="dt">Weights</span> i o <span class="fu">=</span> <span class="dt">W</span> {<span class="ot"> wBiases ::</span> <span class="fu">!</span>(<span class="dt">R</span> o)
                     ,<span class="ot"> wNodes  ::</span> <span class="fu">!</span>(<span class="dt">L</span> o i)
                     }
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="kw">instance</span> (<span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o) <span class="ot">=&gt;</span> <span class="dt">Binary</span> (<span class="dt">Weights</span> i o)</code></pre></div>
<p>For simple types like <code>Weights</code>, which simply “contain” serializable things, the <em>binary</em> library is smart enough to write your instances automatically for you!</p>
<h3 id="serializing-network">Serializing <code>Network</code></h3>
<p>Writing <code>putNet</code> and <code>getNet</code> to put/get <code>Network</code>s is pretty nice because the entire structure is already known ahead of time:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L58-62</span>
<span class="ot">putNet ::</span> (<span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o)
       <span class="ot">=&gt;</span> <span class="dt">Network</span> i hs o
       <span class="ot">-&gt;</span> <span class="dt">Put</span>
putNet <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">O</span> w     <span class="ot">-&gt;</span> put w
               w <span class="fu">:&amp;~</span> n <span class="ot">-&gt;</span> put w <span class="fu">*&gt;</span> putNet n</code></pre></div>
<p>If it’s an <code>O w</code>, just serialize the <code>w</code>. If it’s a <code>w :&amp;~ net</code>, serialize the <code>w</code> then the rest of the <code>net</code>. The reason we can get away without any flags is because we already <em>know</em> how many <code>:&amp;~</code> layers to expect <em>just from the type</em>. If we want to deserialize/load a <code>Network 5 '[10,6,3] 2</code>, we <em>know</em> we want three <code>(:&amp;~)</code>’s and one <code>O</code> — no need for dynamically sized networks like we had to handle for lists.</p>
<p>We’ll write <code>getNet</code> similarly to how wrote <a href="https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L49-52"><code>randomNet'</code></a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L64-68</span>
<span class="ot">getNet ::</span> forall i hs o<span class="fu">.</span> (<span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o)
       <span class="ot">=&gt;</span> <span class="dt">Sing</span> hs
       <span class="ot">-&gt;</span> <span class="dt">Get</span> (<span class="dt">Network</span> i hs o)
getNet <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">SNil</span>            <span class="ot">-&gt;</span>     <span class="dt">O</span> <span class="fu">&lt;$&gt;</span> get
               <span class="dt">SNat</span> <span class="ot">`SCons`</span> ss <span class="ot">-&gt;</span> (<span class="fu">:&amp;~</span>) <span class="fu">&lt;$&gt;</span> get <span class="fu">&lt;*&gt;</span> getNet ss</code></pre></div>
<p>We have to “pattern match” on <code>hs</code> using singletons to see what constructor we are expecting to deserialize.</p>
<p>Let’s write our <code>Binary</code> instance for <code>Network</code>. Of course, we can’t have <code>put</code> or <code>get</code> take a <code>Sing hs</code> (that’d change the arity/type of the function), so we have to switch to <code>SingI</code>-style had have their <code>Binary</code> instances require a <code>SingI hs</code> constraint.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L70-72</span>
<span class="kw">instance</span> (<span class="dt">KnownNat</span> i, <span class="dt">SingI</span> hs, <span class="dt">KnownNat</span> o) <span class="ot">=&gt;</span> <span class="dt">Binary</span> (<span class="dt">Network</span> i hs o) <span class="kw">where</span>
    put <span class="fu">=</span> putNet
    get <span class="fu">=</span> getNet sing</code></pre></div>
<h3 id="serializating-opaquenet">Serializating <code>OpaqueNet</code></h3>
<p>Armed with all that we learned during our long and winding journey through “run-time types”, writing a serializing plan for <code>OpaqueNet</code> is straightforward. (We are doing it for <code>OpaqueNet</code>, the constructor-style existential, because we can’t directly write instances for the continuation-style one)</p>
<p>Because the complete structure of the network is not in the type, we have to encode it as a flag in the binary serialization. We can write a simple function to get the <code>[Integer]</code> of a network’s structure:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L78-82</span>
<span class="ot">hiddenStruct ::</span> <span class="dt">Network</span> i hs o <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
hiddenStruct <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">O</span> _    <span class="ot">-&gt;</span> []
                     _ <span class="fu">:&amp;~</span> (<span class="ot">n&#39; ::</span> <span class="dt">Network</span> h hs&#39; o)
                            <span class="ot">-&gt;</span> natVal (<span class="dt">Proxy</span> <span class="fu">@</span>h)
                             <span class="fu">:</span> hiddenStruct n&#39;</code></pre></div>
<p>Recall that <code>natVal :: KnownNat n =&gt; Proxy n -&gt; Integer</code> returns the value-level <code>Integer</code> corresponding to the type-level <code>n :: Nat</code>. (I’m also using GHC 8’s fancy <em>TypeApplications</em> syntax, and <code>Proxy @h</code> is the same as <code>Proxy :: Proxy h</code>).</p>
<p>It is interesting to note that <code>natVal</code> and <code>hiddenStruct</code> take type-level information (<code>n</code>, <code>hs</code>) and turns them into term-level values (<code>Integer</code>s, <code>[Integer]</code>s). In fact, they are kind of the opposites of our reification functions like <code>toSing</code>. Going from the “type level” to the “value level” is known in Haskell as <strong>reflection</strong>, and is the dual concept of reification. (The <em>singletons</em> library offers reflectors for all of its singletons, as <code>fromSing</code>.)</p>
<p>And that’s all we need!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L101-106</span>
<span class="ot">putONet ::</span> (<span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o)
        <span class="ot">=&gt;</span> <span class="dt">OpaqueNet</span> i o
        <span class="ot">-&gt;</span> <span class="dt">Put</span>
putONet <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">ONet</span> net <span class="ot">-&gt;</span> <span class="kw">do</span>
                  put (hiddenStruct net)
                  putNet net</code></pre></div>
<p>Put the structure (as a flag), and then put the network itself.</p>
<p>Now, to deserialize, we want to <em>load</em> the list of <code>Integer</code>s and reify it back to the type level to know what type of network we’re expecting to load:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L108-114</span>
<span class="ot">getONet ::</span> (<span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o)
        <span class="ot">=&gt;</span> <span class="dt">Get</span> (<span class="dt">OpaqueNet</span> i o)
getONet <span class="fu">=</span> <span class="kw">do</span>
    hs <span class="ot">&lt;-</span> get
    withSomeSing hs <span class="fu">$</span> \ss <span class="ot">-&gt;</span>
      n <span class="ot">&lt;-</span> getNet ss
      return (<span class="dt">ONet</span> n)</code></pre></div>
<p>We load our flag, reify it, and once we’re back in the typed land again, we can do our normal business.</p>
<p>Our final instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L122-124</span>
<span class="kw">instance</span> (<span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o) <span class="ot">=&gt;</span> <span class="dt">Binary</span> (<span class="dt">OpaqueNet</span> i o) <span class="kw">where</span>
    put <span class="fu">=</span> putONet
    get <span class="fu">=</span> getONet</code></pre></div>
<h2 id="living-life-on-the-run-time-edge">Living Life on the Run-Time Edge</h2>
<!-- sameNat and existentials -->
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>A bit of a stretch, because the set of all <code>[Nat]</code>s is non-enumerable and uncountable, but you get the picture, right?<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>This is a completely personal style, and I can’t claim to speak for all of the Haskell dependent typing community. In fact, I’m not even sure that you could even say that there is a consensus at all. But this is the style that has worked personally for me in both writing and using libraries! And hey, some libraries I’ve seen in the wild even offer <em>both</em> styles in their external API.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Gross, right? Hopefully some day this will be as far behind us as that whole Monad/Functor debacle is now!<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Skolemization is probably one of the coolest words you’ll encounter when learning/using Haskell, and sometimes just knowing that you’re “skolemizing” something makes you feel cooler. Thank you <a href="https://en.wikipedia.org/wiki/Thoralf_Skolem">Thoralf Skolem</a>. If you ever see a “rigid, skolem” error in GHC, you can thank him for that too! He is also the inspiration behind my decision to name my first-born son Thoralf. (My second son’s name will be Curry)<a href="#fnref4">↩</a></p></li>
</ol>
</section></div><footer><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Practical Dependent Types in Haskell&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series" title="+Practical Dependent Types in Haskell"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/artificial-neural-networks.html" class="tag-a-tag">#artificial neural networks</a></li><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/linear-algebra.html" class="tag-a-tag">#linear algebra</a></li><li><a href="https://blog.jle.im/entries/tagged/machine-learning.html" class="tag-a-tag">#machine learning</a></li><li><a href="https://blog.jle.im/entries/tagged/numerical.html" class="tag-a-tag">#numerical</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category">@RAMBLINGS</a></li><li><a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series">+Practical Dependent Types in Haskell</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing “in Code”!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html';
    this.page.identifier = 'dependent-haskell-2';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>