<!DOCTYPE HTML>
<html><head><title>Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 2) · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="We’re back to continue on our journey in using practical dependent types to write type-safe neural networks! In Part 1, we wrote things out in normal, untyped Haskell, and looked at red flags and general design principles that nudged us in the direction of adding dependent types to our program. We learned to appreciate what dependent types offered in terms of guiding us in writing our code, helping the compiler check our correctness, providing a better interface for users, and more. We also learned how to use singletons to work around some of Haskell’s fundamental limitations to let us pattern match on the structure of types, and how to use typeclasses to generate singletons reflecting the structure of types we are dealing with. (If you read Part 1 before the singletons section was re-written to use the singletons library, here’s a link to the section in specific. This tutorial will assume familiarity with what is discussed there!) All of what we’ve dealt with so far has essentially been with types that are fixed at compile-time. All the networks we’ve made have had static types, with their sizes in their types indicated directly in the source code. Today, we’re going to dive into the world of types that depend on factors unknown until runtime, and see how dependent types in a strongly typed language like Haskell helps us write safer, more correct, and more maintainable code. Along the way, we’ll encounter and learn first-hand about techniques and guiding high-level principles that we can apply to our other dependently typed coding endeavours."><meta property="og:type" content="article"><meta property="og:title" content="Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 2)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 2)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/dependent-haskell-2.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/practical-dependent-types-in-haskell-2.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled…really just the king of great languages.">Haskell</a>, <a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category" title="My slight ramblings on subjects of interest (to me and hopefully to you too!).
Lots of surveys and introducts to new subjects.">Ramblings</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>We’re back to continue on <a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html">our journey</a> in using practical dependent types to write type-safe neural networks! In <a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html">Part 1</a>, we wrote things out in normal, untyped Haskell, and looked at red flags and general design principles that nudged us in the direction of adding dependent types to our program. We learned to appreciate what dependent types offered in terms of guiding us in writing our code, helping the compiler check our correctness, providing a better interface for users, and more.</p>
<p>We also learned how to use singletons to work around some of Haskell’s fundamental limitations to let us “pattern match” on the structure of types, and how to use typeclasses to generate singletons reflecting the structure of types we are dealing with.</p>
<p>(If you read <a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html">Part 1</a> <em>before</em> the singletons section was re-written to use the <a href="https://hackage.haskell.org/package/singletons">singletons</a> library, <a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html#singletons-and-induction">here’s a link to the section</a> in specific. This tutorial will assume familiarity with what is discussed there!)</p>
<p>All of what we’ve dealt with so far has essentially been with types that are fixed at compile-time. All the networks we’ve made have had “static” types, with their sizes in their types indicated directly in the source code.</p>
<p>Today, we’re going to dive into the world of types that <em>depend</em> on factors unknown until runtime, and see how dependent types in a strongly typed language like Haskell helps us write safer, more correct, and more maintainable code. Along the way, we’ll encounter and learn first-hand about techniques and guiding high-level principles that we can apply to our other dependently typed coding endeavours.</p>
<h2 id="serializing-networks">Serializing Networks</h2>
<p>Just to warm up, let’s talk about serializing networks: writing them to binary and re-reading them.</p>
<h3 id="recap-on-the-binary-library">Recap on the Binary Library</h3>
<p>Serializing networks of <em>known</em> size — whose sizes are statically in their types — is pretty straightforward. I’m going to be using the <em><a href="https://hackage.haskell.org/package/binary">binary</a></em> library, which offers a very standard typeclass-based approach for serializing and deserializing data. There are a lot of tutorials online (and I even <a href="https://blog.jle.im/entry/streaming-huffman-compression-in-haskell-part-2-binary.html">wrote a small one</a> myself a few years ago), but a very high-level view is that the library offers a typeclass for describing serialization schemes for different types.</p>
<p>For example, for serializing lists, you have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">putList ::</span> <span class="dt">Binary</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Put</span>
putList []     <span class="fu">=</span>
    put <span class="dt">False</span>           <span class="co">-- signal the end</span>
putList (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">do</span>
    put <span class="dt">True</span>            <span class="co">-- signal a cons</span>
    put x
    putList xs</code></pre></div>
<p>Where <code>put :: Binary a =&gt; a -&gt; Put</code> is a polymorphic way of describing serialization of things with a <code>Binary</code> instance — every type provides its own <code>put</code>. Sequencing <code>Put</code>s using do notation is saying “put this, then that, then that”.</p>
<p>We can deserialize by describing a monadic <code>Get</code> plan:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getList ::</span> <span class="dt">Binary</span> a <span class="ot">=&gt;</span> <span class="dt">Get</span> [a]
getList <span class="fu">=</span> <span class="kw">do</span>
    isCons <span class="ot">&lt;-</span> get
    <span class="kw">if</span> isCons
      <span class="kw">then</span> <span class="kw">do</span>
        x  <span class="ot">&lt;-</span> get
        xs <span class="ot">&lt;-</span> getList
        return (x<span class="fu">:</span>xs)
      <span class="kw">else</span>
        return []</code></pre></div>
<p>And <code>get :: Binary a =&gt; Get a</code> is a polymorphic way of describing a strategy of deserializing things with a <code>Binary</code> instance — again, every type provides its own <code>get</code>. Sequencing <code>Get</code>s is again simply “do-this-then-that”.</p>
<p>We can write our own instances for our own types by providing <code>put</code> and <code>get</code> together:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Binary</span> a <span class="ot">=&gt;</span> <span class="dt">Binary</span> [a] <span class="kw">where</span>
    put <span class="fu">=</span> putList
    get <span class="fu">=</span> getList</code></pre></div>
<p>In practice, we usually don’t write our own instances from scratch, and use GHC’s generics features to give us instances for free:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L19-33</span>
<span class="kw">data</span> <span class="dt">Weights</span> i o <span class="fu">=</span> <span class="dt">W</span> {<span class="ot"> wBiases ::</span> <span class="fu">!</span>(<span class="dt">R</span> o)
                     ,<span class="ot"> wNodes  ::</span> <span class="fu">!</span>(<span class="dt">L</span> o i)
                     }
  <span class="kw">deriving</span> (<span class="dt">Generic</span>)

<span class="kw">instance</span> (<span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o) <span class="ot">=&gt;</span> <span class="dt">Binary</span> (<span class="dt">Weights</span> i o)</code></pre></div>
<p>For simple types like <code>Weights</code>, which simply “contain” serializable things, the <em>binary</em> is smart enough to write your instances automatically!</p>
<h3 id="binary-for-network"><code>Binary</code> for <code>Network</code></h3>
<p>Writing <code>putNet</code> and <code>getNet</code> is pretty nice because the entire structure is already known ahead of time, and we don’t need to do any tricks with flags like for lists.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L54-58</span>
<span class="ot">putNet ::</span> (<span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o)
       <span class="ot">=&gt;</span> <span class="dt">Network</span> i hs o
       <span class="ot">-&gt;</span> <span class="dt">Put</span>
putNet <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">O</span> w     <span class="ot">-&gt;</span> put w
               w <span class="fu">:&amp;~</span> n <span class="ot">-&gt;</span> put w <span class="fu">*&gt;</span> putNet n</code></pre></div>
<p>Even simpler than for lists! If it’s an <code>O w</code>, just serialize the <code>w</code>. If it’s a <code>w :&amp;~ net</code>, serialize the <code>w</code> then the rest of the <code>net</code>. The reason we can get away without any flags is because we already <em>know</em> how many <code>:&amp;~</code> layers to expect <em>just from the type</em>. If we want to deserialize/load a <code>Network 5 '[10,6,3] 2</code>, we <em>know</em> we want three <code>(:&amp;~)</code>’s and one <code>O</code> — no need for dynamically sized networks like we had to handle for lists.</p>
<p>We’ll write <code>getNet</code> the similarly to how wrote <a href="https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L67-75"><code>randomNet</code></a> from the last post:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L60-64</span>
<span class="ot">getNet ::</span> forall i hs o<span class="fu">.</span> (<span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o)
       <span class="ot">=&gt;</span> <span class="dt">Sing</span> hs
       <span class="ot">-&gt;</span> <span class="dt">Get</span> (<span class="dt">Network</span> i hs o)
getNet <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">SNil</span>            <span class="ot">-&gt;</span>     <span class="dt">O</span> <span class="fu">&lt;$&gt;</span> get
               <span class="dt">SNat</span> <span class="ot">`SCons`</span> ss <span class="ot">-&gt;</span> (<span class="fu">:&amp;~</span>) <span class="fu">&lt;$&gt;</span> get <span class="fu">&lt;*&gt;</span> getNet ss</code></pre></div>
<p>Now would be a good time to refresh on the <a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html#singletons-and-induction">singletons section</a> of my last post again. To deserialize a <code>Network i hs o</code>, we have to “pattern match” on <code>hs</code> to see what constructor we are expecting to deserialize, and we do that by using singletons with constructors we <em>can</em> literally pattern match on (<code>SNil</code> and <code>SCons</code>), which tell GHC what type to expect through “dependent pattern matching”.</p>
<p>If you see a <code>SNil :: Sing '[]</code>, that means that <code>hs</code> is <code>'[]</code>, so expect a <code>O</code> constructor. If you see <code>SCons s ss :: Sing (h ': hs)</code>, that means that <code>hs</code> is <code>h ': h'</code>, so expect a <code>(:&amp;~)</code> constructor. (If this is a little confusing still, try re-reading the <a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html#singletons-and-induction">singleton section</a> from the last post again for a more thorough description!)</p>
<p>Note that here we decide to implement <code>getNet</code> by asking for an explicit singleton input (<code>Sing hs -&gt;</code>) instead of an implicit one (<code>SingI hs =&gt;</code>) like we did for <code>randomNet</code>. Remember that the two methods are technically equivalent, really, and compile to the same thing at runtime. We need one or the other because of type erasure — so either we pass in <code>Sing hs</code>, or provide a <code>SingI hs</code> constraint so that we can use <code>sing :: Sing hs</code> to construct the <code>Sing hs</code>.</p>
<p>There’s a trade-off either way, and it can be a bit annoying because switching between different modes can potentially be diverse. For the most part, always try to <em>take explicit singleton arguments</em> where you can, especially for internal functions. The simple reason is because in Haskell, we like to really only do typeclass-level programming as a last, last resort. Typeclasses in Haskell are very magical and not really first-class in a satisfying way. Normal values (like singletons) <em>are</em> first-class and easily passed.</p>
<p>Explicit singleton arguments can sometimes pose a burden for the caller, so my personal approach is to <em>always</em> use explicit <code>Sing a</code> whenever possible for <em>internal functions</em>, and to expose a <code>SingI a =&gt;</code> interface for <em>user-facing functions</em> (including for typeclass instances)</p>
<p>So, we’re going to write our <code>Binary</code> instance for <code>Network</code>. Of course, we can’t have <code>put</code> or <code>get</code> take a <code>Sing hs</code> (that’d change the arity/type of the function), so what we can do is have their <code>Binary</code> instances require a <code>SingI hs</code> constraint, essentially doing the same thing:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L66-68</span>
<span class="kw">instance</span> (<span class="dt">KnownNat</span> i, <span class="dt">SingI</span> hs, <span class="dt">KnownNat</span> o) <span class="ot">=&gt;</span> <span class="dt">Binary</span> (<span class="dt">Network</span> i hs o) <span class="kw">where</span>
    put <span class="fu">=</span> putNet
    get <span class="fu">=</span> getNet sing</code></pre></div>
<p>To go from “<code>SingI</code> world” to “<code>Sing</code> world”, we use <code>sing</code> to generate the explicit <code>Sing hs</code> from <code>SingI hs =&gt;</code>.</p>
<!-- #### `Sing` to `SingI` -->
<!-- As a quick aside, note that we can go "backwards" too by using `withSingI :: -->
<!-- Sing a -> (SingI a => r) -> r`: -->
<!-- ~~~haskell -->
<!-- !!!dependent-haskell/NetworkTyped2.hs "sillyGetNet ::" -->
<!-- ~~~ -->
<!-- `withSingI` takes a `Sing a` and a "thing you can evaluate if only you had a -->
<!-- `SingI a` instance available", and evaluates it.  We can only evaluate `get :: -->
<!-- (KnownNat i, SingI hs, KnownNat o) => Get (Network i hs o)` if we have that -->
<!-- `SingI` instance, so we can pass it into `withSingI` as the second argument, -->
<!-- and, voilà --- we get that `Get (Network i hs o)` right out. -->
<h2 id="existential-crisis">Existential Crisis</h2>
<p>Now, having the entire structure of your neural network in the type is nice and all for cool tricks like <code>randomNet</code>…but do you <em>really</em> want to work with this directly? After all, from the user’s perspective, the user really only ever needs to know <code>i</code> and <code>o</code>: What vectors the network <em>expects</em>, and what vectors the network <em>outputs</em>. In the end, all a (feed-forward) Neural Network really is is an abstraction over a function <code>R i -&gt; R o</code>.</p>
<p>Remember, the main benefits of having the entire structure in the type was to help us <em>implement</em> our functions more safely, with the compiler’s help, and also for cute return type polymorphism tricks like <code>randomNet</code> and <code>getNet</code>. The <em>first</em> type of benefit really doesn’t benefit the <em>user</em> of the network. So let’s talk about a way to “abstract” away the internal structure of hidden nodes from the type, and maybe even have it depend on runtime values!</p>
<p>The big key to “hiding” parts of types and letting them depend on runtime values is called the <em>existential type</em>. Existential types are sort of the “opposite” of the normal polymorphic (universally quantified) types you normally see in Haskell.</p>
<p>For a function like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</code></pre></div>
<p><code>a</code> and <code>b</code> are universally quantified, which means that the person who <em>uses</em> <code>map</code> gets to <em>decide</em> what <code>a</code> and <code>b</code> are. To be more explicit, that type signature can be written as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> forall a b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</code></pre></div>
<p>For a universally quantified type, the <em>caller</em> gets to decide what is what…and the function has to <em>adapt</em> to handle it.</p>
<p>For the <em>existentially</em> quantified type, the <em>function</em> gets to decide what is what, and the <em>caller</em> has to adapt to handle it.</p>
<p>There are two main ways to work with existential types in Haskell, and we’ll go over both of them now and talk about their relative strengths and weaknesses and what situations to use either of them in. It pays to be aware of both!</p>
<h3 id="existential-data-type">Existential Data Type</h3>
<p>Arguably the more natural way in Haskell to work with existential types is to wrap them in a data type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L75-76</span>
<span class="kw">data</span> <span class="dt">OpaqueNet</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
    <span class="dt">ONet</span><span class="ot"> ::</span> <span class="dt">Sing</span> hs <span class="ot">-&gt;</span> <span class="dt">Network</span> i hs o <span class="ot">-&gt;</span> <span class="dt">OpaqueNet</span> i o</code></pre></div>
<p>So, if you have <code>net :: Network 6 '[10,6,3] 2</code>, you can create <code>ONet sing net :: OpaqueNet 6 2</code>. When you use the <code>ONet</code> constructor, the structure of the hidden layers disappears from the type!</p>
<p>How do we use this type? When we <em>pattern match</em> on <code>ONet</code>, we get the singleton and the net back!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L78-83</span>
<span class="ot">numHiddens ::</span> <span class="dt">OpaqueNet</span> i o <span class="ot">-&gt;</span> <span class="dt">Int</span>
numHiddens <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">ONet</span> ss _ <span class="ot">-&gt;</span> lengthSing ss
  <span class="kw">where</span>
<span class="ot">    lengthSing ::</span> <span class="dt">Sing</span> (<span class="ot">hs ::</span> [<span class="dt">Nat</span>]) <span class="ot">-&gt;</span> <span class="dt">Int</span>
    lengthSing <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">SNil</span>         <span class="ot">-&gt;</span> <span class="dv">0</span>
                       _ <span class="ot">`SCons`</span> ss <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">+</span> lengthSing ss</code></pre></div>
<p>Note that it’s important for us to stuff in the singleton in addition to the network itself, because of type erasure. If we didn’t pop the singleton in, there’d be no way for us to recover the original <code>hs</code>! (Note that we could have had <code>ONet :: SingI hs =&gt; Network i hs o -&gt; OpaqueNet i o</code>, which is essentially the same thing)</p>
<!-- Typically, for an existential type to be *useful*, we usually have to add a -->
<!-- typeclass constraint or a singleton so that whoever pattern matches on the -->
<!-- constructor has *something* to work with. -->
<p>Once you <em>do</em> pattern match on <code>ONet</code>, you have to handle the <code>hs</code> in a <em>completely polymorphic way</em>. You’re not allowed to assume anything about <code>hs</code>…you have to provide a completely parametrically polymorphic way of dealing with it!</p>
<p>Note that this function is completely not ok:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bad ::</span> <span class="dt">OpaqueNet</span> i o <span class="ot">-&gt;</span> <span class="dt">Network</span> i hs o
bad <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">ONet</span> _ n <span class="ot">-&gt;</span> n</code></pre></div>
<p>Why not? Because a type signature like <code>OpaqueNet i o -&gt; Network i hs o</code> means that the <em>caller</em> can decide what <code>hs</code> can be — just like <code>read :: Read a =&gt; String -&gt; a</code>, where the caller decides what <code>a</code> is.</p>
<p>Of course, this <em>isn’t</em> the case with the way we’ve written the function…the function only returns a <em>specific</em> <code>hs</code> that the <em>function</em> decides. The <em>caller</em> has to accommodate whatever is inside <code>ONet</code>.</p>
<h4 id="binary">Binary</h4>
<p>Now, let’s find out a way to serialize this type! Now, the structure of our network is <em>not</em> known in the type, so we do have to plant flags in our data somehow. We need to store a witness to the structure of the network, as well.</p>
<p>To do this, we can move <code>hs</code> from the type level to the value level. In Haskell, this is called <strong>reflection</strong>. The <em>singletons</em> library provides the <code>fromSing</code> function for this purpose:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> fromSing (<span class="ot">sing ::</span> <span class="dt">Sing</span> <span class="ch">&#39;[1,2,3])</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
ghci<span class="fu">&gt;</span> fromSing (<span class="ot">sing ::</span> <span class="dt">Sing</span> <span class="ch">&#39;[True, False])</span>
[<span class="dt">True</span>, <span class="dt">False</span>]</code></pre></div>
<p>And with that, we can write a serializer for <code>OpaqueNet</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L85-90</span>
<span class="ot">putONet ::</span> (<span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o)
        <span class="ot">=&gt;</span> <span class="dt">OpaqueNet</span> i o
        <span class="ot">-&gt;</span> <span class="dt">Put</span>
putONet <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">ONet</span> ss net <span class="ot">-&gt;</span> <span class="kw">do</span>
                  put (fromSing ss)
                  putNet net</code></pre></div>
<p>Put the structure (as a flag), and then put the network itself.</p>
<p>Now, to deserialize, we want to <em>load</em> the list of <code>Integer</code>s and move that <em>back</em> into the type level. In Haskell, this is called <strong>reification</strong>, the dual of reflection.</p>
<p>The <em>singletons</em> library provides the <code>toSing</code> function, which returns a <code>SomeSing</code> (an existentially quantified <code>Sing</code> wrapped in a constructor that we can pattern match on):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L92-99</span>
<span class="ot">getONet ::</span> (<span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o)
        <span class="ot">=&gt;</span> <span class="dt">Get</span> (<span class="dt">OpaqueNet</span> i o)
getONet <span class="fu">=</span> <span class="kw">do</span>
    hs <span class="ot">&lt;-</span> get
    <span class="kw">case</span> toSing hs <span class="kw">of</span>
      <span class="dt">SomeSing</span> ss <span class="ot">-&gt;</span> <span class="kw">do</span>
        n <span class="ot">&lt;-</span> getNet ss
        return (<span class="dt">ONet</span> ss n)</code></pre></div>
<p>We first <code>get</code> the <code>[Integer]</code>, then <em>reify</em> the list of integers into the type level by getting our <code>ss :: Sing hs</code>. Then we <code>getNet ss</code>, remembering that <code>getNet</code> takes a singleton to figure out what structure to get. Then we wrap it all up in the <code>ONet</code> constructor.</p>
<p>Phew! We load our flag, reify it, and once we’re back in the typed land again, we can do our normal business!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L108-110</span>
<span class="kw">instance</span> (<span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o) <span class="ot">=&gt;</span> <span class="dt">Binary</span> (<span class="dt">OpaqueNet</span> i o) <span class="kw">where</span>
    put <span class="fu">=</span> putONet
    get <span class="fu">=</span> getONet</code></pre></div>
<h4 id="the-boundary">The Boundary</h4>
<p>Did you notice what we just did there? The <em>type</em> of <code>Sing hs</code> was <em>dynamically generated</em> based on the <em>value</em> of the <code>[Integer]</code> we load at runtime. We just worked with types that <em>depended</em> on runtime values.</p>
<p>With the power of existentially quantified types (like in <code>SomeSing</code>), we essentially gained the ability to work with types that depend on runtime results.</p>
<p>In a way, you can consider the <code>toSing</code> and the <code>SomeSing</code> as our “boundary” between the “untyped world” and the “typed world”. This layer (and the process of reification) cleanly separates the two.</p>
<p>This “boundary” can be thought of as a lot like the boundary we talk about between “pure” functions and values and “impure” (IO, etc.) ones. We say to always write as much of your program as possible in the “pure” world, and to separate and pull out as much logic as you can to be pure logic. That’s sort of one of the first things you learn about as a Haskell programmer: how to separate logic that <em>can</em> be pure from logic that is “impure” (IO, etc.), and then “combine them” at the very end, as late as possible.</p>
<p>Well, if the final program is going to be IO in the end anyway, why bother separating out pure and impure parts of your logic? Separation of concerns, the increased ability to reason with your code and analyze what it does, the compiler’s ability to check what you write, the limitation of implementations, and etc. are all reasons any Haskeller should be familiar with reciting.</p>
<p>You can think of the general philosophy of working with typed/untyped worlds as being the same thing. You can write as much of your program as possible in the “typed” world, like we did in Part 1. Take advantage of the increased ability to reason with your code, parametric polymorphism helping you <em>write</em> your code, limit your implementations, nab you compiler help, etc. All of those are benefits of working in the typed world.</p>
<p>Then, write what you must in your “untyped” world, such as dealing with values that pop up at runtime like the <code>[Integer]</code> above.</p>
<p>Finally, at the end, <em>unite</em> them at the boundary.</p>
<h3 id="continuation-based-existentials">Continuation-Based Existentials</h3>
<p>There’s another way in Haskell that we work with existential types that can be more natural and easy to work with in a lot of cases.</p>
<p>Note that when we pattern match on an existential data type, you have to work with the values in the constructor in a parametrically polymorphic way. For example, if we had:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toONet ::</span> <span class="dt">OpaqueNet</span> i o <span class="ot">-&gt;</span> <span class="dt">Foo</span>
toONet <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">ONet</span> s n <span class="ot">-&gt;</span> f s n</code></pre></div>
<p>What does the type of <code>f</code> have to be? It has to take a <code>Sing hs</code> and a <code>Network i hs o</code>, but deal with it in a way that works <em>for all</em> <code>hs</code>. It has to be:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> forall (<span class="ot">hs ::</span> [<span class="dt">Nat</span>])<span class="fu">.</span> <span class="dt">Sing</span> hs <span class="ot">-&gt;</span> <span class="dt">Network</span> i hs o <span class="ot">-&gt;</span> <span class="dt">Foo</span></code></pre></div>
<p>That is, it can’t be written for <em>only</em> <code>Sing '[5]</code> or <em>only</em> <code>Sing '[6,3]</code>…it has to work for <em>any</em> <code>hs</code>.</p>
<p>Well, we could really also just skip the data type together and represent an existential type as something <em>taking</em> the continuation <code>f</code> and giving it what it needs.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L112-112</span>
<span class="kw">type</span> <span class="dt">OpaqueNet&#39;</span> i o r <span class="fu">=</span> (forall hs<span class="fu">.</span> <span class="dt">Sing</span> hs <span class="ot">-&gt;</span> <span class="dt">Network</span> i hs o <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</code></pre></div>
<p>This “continuation transformation” is known as formally <strong>skolemization</strong>.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>We can “wrap” a <code>Network i hs o</code> into an <code>OpaqueNet' i o r</code> pretty straightforwardly:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L114-115</span>
<span class="ot">oNet&#39; ::</span> <span class="dt">Sing</span> hs <span class="ot">-&gt;</span> <span class="dt">Network</span> i hs o <span class="ot">-&gt;</span> <span class="dt">OpaqueNet&#39;</span> i o r
oNet&#39; s n <span class="fu">=</span> \f <span class="ot">-&gt;</span> f s n</code></pre></div>
<p>To prove that the two <code>OpaqueNet</code>s are the same (and to help us see more about how they relate), we can write functions that convert back and forth from them:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L117-122</span>
<span class="co">-- withONet :: OpaqueNet i o -&gt; (forall hs. Sing hs -&gt; Network i hs o -&gt; r) -&gt; r</span>
<span class="ot">withONet ::</span> <span class="dt">OpaqueNet</span> i o <span class="ot">-&gt;</span> <span class="dt">OpaqueNet&#39;</span> i o r
withONet <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">ONet</span> s n <span class="ot">-&gt;</span> (\f <span class="ot">-&gt;</span> f s n)

<span class="ot">toONet ::</span> <span class="dt">OpaqueNet&#39;</span> i o (<span class="dt">OpaqueNet</span> i o) <span class="ot">-&gt;</span> <span class="dt">OpaqueNet</span> i o
toONet oN&#39; <span class="fu">=</span> oN&#39; (\s n <span class="ot">-&gt;</span> <span class="dt">ONet</span> s n)</code></pre></div>
<p>Note that <code>withONet</code> is <em>really</em>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withONet ::</span> <span class="dt">OpaqueNet</span> i o
         <span class="ot">-&gt;</span> (forall hs<span class="fu">.</span> <span class="dt">Sing</span> hs <span class="ot">-&gt;</span> <span class="dt">Network</span> i hs o <span class="ot">-&gt;</span> r)
         <span class="ot">-&gt;</span> r</code></pre></div>
<p>Which you can sort of interpret as, “do <em>this function</em> on the existentially quantified contents of an <code>OpaqueNet</code>.”</p>
<h4 id="binary-again">Binary again</h4>
<p>To sort of compare how the two methods look like in practice, we’re going to Rosetta stone it up and re-implement serialization with the continuation-based existentials:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L124-137</span>
<span class="ot">putONet&#39; ::</span> (<span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o)
         <span class="ot">=&gt;</span> <span class="dt">OpaqueNet&#39;</span> i o <span class="dt">Put</span>
         <span class="ot">-&gt;</span> <span class="dt">Put</span>
putONet&#39; oN <span class="fu">=</span> oN <span class="fu">$</span> \ss net <span class="ot">-&gt;</span> <span class="kw">do</span>
                      put (fromSing ss)
                      putNet net

<span class="ot">getONet&#39; ::</span> (<span class="dt">KnownNat</span> i, <span class="dt">KnownNat</span> o)
         <span class="ot">=&gt;</span> <span class="dt">OpaqueNet&#39;</span> i o (<span class="dt">Get</span> r)
getONet&#39; f <span class="fu">=</span> <span class="kw">do</span>
    hs <span class="ot">&lt;-</span> get
    withSomeSing (<span class="ot">hs ::</span> [<span class="dt">Integer</span>]) <span class="fu">$</span> \ss <span class="ot">-&gt;</span> <span class="kw">do</span>
      n <span class="ot">&lt;-</span> getNet ss
      f ss n</code></pre></div>
<h3 id="a-tale-of-two-existentials">A Tale of Two Existentials</h3>
<!-- sameNat and existentials -->
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Skolemization is probably one of the coolest words you’ll encounter working with dependent types in Haskell, and sometimes just knowing that you’re “skolemizing” something makes you feel cooler. Thank you <a href="https://en.wikipedia.org/wiki/Thoralf_Skolem">Thoralf Skolem</a>. If you ever see a “rigid, skolem” error in GHC, you can thank him too!<a href="#fnref1">↩</a></p></li>
</ol>
</section></div><footer><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Practical Dependent Types in Haskell&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series" title="+Practical Dependent Types in Haskell"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/artificial-neural-networks.html" class="tag-a-tag">#artificial neural networks</a></li><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/linear-algebra.html" class="tag-a-tag">#linear algebra</a></li><li><a href="https://blog.jle.im/entries/tagged/machine-learning.html" class="tag-a-tag">#machine learning</a></li><li><a href="https://blog.jle.im/entries/tagged/numerical.html" class="tag-a-tag">#numerical</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category">@RAMBLINGS</a></li><li><a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series">+Practical Dependent Types in Haskell</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing “in Code”!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html';
    this.page.identifier = 'dependent-haskell-2';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-facebook" title="Friend me on Facebook!" href="https://facebook.com/mstksg">Facebook</a></li><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>