<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>in Code — Entries</title><link>http://blog.jle.im/</link><description>Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge.</description><item><title>Blog Rewrite with Hakyll and Purescript</title><link>http://blog.jle.im/entry/blog-rewrite-with-hakyll-and-purescript.html</link><description>&lt;p&gt;It’s been almost a year since my last post! Things have been a bit hectic with research and related things, and with the unrelenting academia publishing cycle, any time I can get to write or explore has been a nice escape.&lt;/p&gt;
&lt;p&gt;Admittedly, I’ve also run into some friction updating my blog because it was a compiled web server with some delicate dependencies and required environment configuration to build/deploy. It was written/built at a time when a lot of the infrastructure we have now in the Haskell ecosystem either wasn’t there, or wasn’t mature. We didn’t have easy &lt;a href=&quot;https://haskellonheroku.com/&quot;&gt;Heroku deployment&lt;/a&gt;, and we didn’t have great tools like &lt;a href=&quot;http://haskellstack.org/&quot;&gt;stack&lt;/a&gt; to let us create reproducible builds. One of my &lt;a href=&quot;http://blog.jle.im/entry/deploying-medium-to-large-haskell-apps-to-heroku.html&quot;&gt;first posts&lt;/a&gt; in 2013 was actually about hoops to jump through &lt;em&gt;just&lt;/em&gt; to get a simple Heroku deployment. I’ve had to maintain a virtual machine just to compile and push changes!&lt;/p&gt;
&lt;p&gt;My blog was one of my first Haskell projects ever, and if I had started it now, in 2016, things would definitely be a bit different. By this point, it’s been long enough and the slight inconveniences have been building up enough that I thought it’d be time to sit down and finally migrate my “first large-ish Haskell project” and bring it into modern times, by using &lt;a href=&quot;https://jaspervdj.be/hakyll/&quot;&gt;hakyll&lt;/a&gt; and &lt;a href=&quot;http://www.purescript.org/&quot;&gt;purescript&lt;/a&gt;. Here are my thoughts and observations on how the migration went, with insight on Haskell migrations in general!&lt;/p&gt;
&lt;h2 id=&quot;hakyll&quot;&gt;Hakyll&lt;/h2&gt;
&lt;p&gt;To be fair, there was little actual practical reasons why my site wasn’t static to begin with. The main reason, feature-wise, was for me to be able to schedule blog posts and updates without requiring me to actually re-render and re-push every time I wanted to make a post. The real underlying reason, however, was that this blog was my first major Haskell project, and I wanted to take the opportunity to be able to learn how to interface with databases in Haskell.&lt;/p&gt;
&lt;p&gt;Now that that learning impetus is behind me, I felt free to throw it all out the window and rewrite things to be a completely 100% static site!&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaspervdj.be/hakyll/&quot;&gt;Hakyll&lt;/a&gt; was great; it’s basically like a very specialized &lt;em&gt;make&lt;/em&gt;-like tool for building sites. It takes a bit of time to get used to “thinking in Hakyll” — generating standalone pages instead of just ones based off of files, getting used to the identifier/snapshot system — but once you do, things go pretty smoothly. I started thinking about snapshots as customized “object files” that you can leave behind in the process of creating pages that other pages can use. Hakyll manages all the dependencies for you, so pages that depend on the things left from other pages will be sequenced properly, and rebuilding your website only requires rebuilding pages that depend on files you changed. Neat!&lt;/p&gt;
&lt;p&gt;Before, I had gotten the impression that Hakyll was mostly for generating “simple”, pre-built blog layouts, but I was able to use Hakyll (without much friction, at all) to generate the complex, intricate, and arbitrary site map that I had designed for my scotty-based blog. I definitely recommend it for any static site generating needs, blogs or not.&lt;/p&gt;
&lt;p&gt;An unexpected consequence of the static-site-hosted-by-github-pages approach, however, is that I don’t have any control over MIME types anymore (or 301 redirects), so I had to do some migrations to move pages over to “.html” and set up redirects and stuff (and get redirects to work with google analytics), but those were made super simple with Hakyll.&lt;/p&gt;
&lt;h2 id=&quot;refactoring-haskell-code&quot;&gt;Refactoring Haskell Code&lt;/h2&gt;
&lt;p&gt;One thing that did not disappoint me was how &lt;em&gt;easy&lt;/em&gt; and &lt;em&gt;painless&lt;/em&gt; it is to refactor Haskell code. This is something I always trumpet/brag about Haskell, and getting the opportunity to actually refactor a major-ish codebase.&lt;/p&gt;
&lt;p&gt;And, yes, I was not disappointed! For the most part, I already had my html templates, CSS, static javascript, etc. in place. All of the mechanisms were extremely modular and very easy to port. The type system made sure everything fit together well at the boundaries. They also instantly told me what did what, and ensured that sweeping changes in my code were safe. The “if it compiles, it works” mantra served me greatly here. I can’t even begin to imagine migrating one of my old ruby projects in the same way. With this, I was confident that my compiled code was correct and did what I wanted. The types were a guide and also a avenue of insight into my 3-years-removed past self.&lt;/p&gt;
&lt;p&gt;Thanks to the types, I was able to pick up something I hadn’t touched in 3 years, figure out how all things fit together, and completely gut everything apart and use them for a new build system … with compile-time assurances that I didn’t do anything incorrectly!&lt;/p&gt;
&lt;p&gt;It’s hard for me to really explain how amazing the feeling of refactoring Haskell code is. I used to dread refactors and migrations, but now I look forward to them and find any opportunity to do one! :D It’s something that’s difficult to convey the sublime joy of until you actually try it, so I recommend trying it some day :)&lt;/p&gt;
&lt;h2 id=&quot;purescript&quot;&gt;Purescript&lt;/h2&gt;
&lt;h3 id=&quot;on-fay&quot;&gt;on Fay&lt;/h3&gt;
&lt;p&gt;I figured I’d move away from &lt;a href=&quot;https://github.com/faylang/fay/wiki&quot;&gt;fay&lt;/a&gt;, because it was slightly clunky to build/get working/integrate in the way that GHCJS spoiled me to be accustomed to. In the future, I might return … but at this point in time, Fay seems as awkward in the ecosystem to me as haste did when I first started using it. GHCJS lets you use the full power of Haskell (including all of &lt;em&gt;base&lt;/em&gt;’s concurrency mechanisms and almost every library on hackage), at the expense of creating large and unreadable javascript blobs.&lt;/p&gt;
&lt;p&gt;Fay seemed like just a &lt;em&gt;weaker&lt;/em&gt; GHCJS to me, but in all the ways that mattered. It doesn’t have all of the awesome GHC things that make modern Haskell what it is (not just the lack of base’s identical API, but also … no typeclasses? Lens abstactions? Hackage libraries?), so almost all of my normal Haskell programming flow is thrown out the window. It’s a subset of Haskell, but lacks most of the tools people use to write &lt;em&gt;actual&lt;/em&gt; Haskell like they’d write everyday. The generated javascript blobs are still decently opaque.&lt;/p&gt;
&lt;p&gt;So, if you’re going to be spending your time writing something that is like Haskell, but forces you to write it in a way that is nothing like any actual Haskell code you’d normally write… why even bother keeping up with Haskell semantics and Haskell compatibility? Why not break out and try something new and fresh, unbound by Haskell and compatibility issues?&lt;/p&gt;
&lt;h3 id=&quot;on-purescript&quot;&gt;on Purescript&lt;/h3&gt;
&lt;p&gt;With that mindset, I looked at &lt;em&gt;&lt;a href=&quot;http://www.purescript.org/&quot;&gt;purescript&lt;/a&gt;&lt;/em&gt;, which is a language that’s inspired by Haskell, with a lot of Haskell features we use every day, and throws in things we all wish we had in Haskell, like extensible records!&lt;/p&gt;
&lt;p&gt;(Fair note — I did rewrite all of my fay in GHCJS at first. This resulted in a javascript blob that was &lt;em&gt;1.4 MB&lt;/em&gt; in size, for a bunch of small DOM manipulation scripts. Definitely not practical, unfortunately!)&lt;/p&gt;
&lt;p&gt;I liked that purescript was able to throw away a lot of warts in the Haskell ecosystem, with a cleaner typeclass hierarchy and just a lot of design decisions “done right”, that we’d all change in Haskell if we could. And extensible records being built into the language is quite refreshing; not having to deal with fancy GADT’s in Haskell was a nice step back from the craziness that is type-level programming in Haskell.&lt;/p&gt;
&lt;p&gt;I often felt like writing in Purescript felt like writing in &lt;em&gt;the language that Haskell should have been&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;But one of my favorite aspects about purescript ended up being the sheer beauty and conciseness of the generated javascript. Look at how&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&quot;purescript&quot;&gt;&lt;code&gt;appendTopLinks doc = do
    hs &amp;lt;- querySelectorAll headers (documentToParentNode doc)
    flip traverseNodeList_ hs \h -&amp;gt; do
      topLink &amp;lt;- createElement &amp;quot;a&amp;quot; doc
      let topLinkNode = elementToNode topLink
      setAttribute &amp;quot;href&amp;quot; &amp;quot;#title&amp;quot; topLink
      setClassName &amp;quot;top-link&amp;quot; topLink
      setTextContent &amp;quot;top&amp;quot; topLinkNode
      appendChild topLinkNode (elementToNode h)
      return unit&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gets translated to:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode javascript&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; appendTopLinks &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (doc) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;__do&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; v &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;querySelectorAll&lt;/span&gt;(headers)(&lt;span class=&quot;at&quot;&gt;documentToParentNode&lt;/span&gt;(doc))()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;flip&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;traverseNodeList_&lt;/span&gt;(monadEffEff))(v)(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (h) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;__do&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; v1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;createElement&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;)(doc)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; topLinkNode &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;elementToNode&lt;/span&gt;(v1)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;at&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;href&amp;quot;&lt;/span&gt;)(&lt;span class=&quot;st&quot;&gt;&amp;quot;#title&amp;quot;&lt;/span&gt;)(v1)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;at&quot;&gt;setClassName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;top-link&amp;quot;&lt;/span&gt;)(v1)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;at&quot;&gt;setTextContent&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;top&amp;quot;&lt;/span&gt;)(topLinkNode)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;at&quot;&gt;appendChild&lt;/span&gt;(topLinkNode)(&lt;span class=&quot;at&quot;&gt;elementToNode&lt;/span&gt;(h))()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; unit&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And it’s not just the IO-based imperative code that looks nice, too. Everything gets compiled to clean, readable javascript that you’d be happy to import in your node or normal js project.&lt;/p&gt;
&lt;p&gt;The total exported javascript blob is only &lt;em&gt;88 kB&lt;/em&gt;, even smaller than fay’s &lt;em&gt;100 kB&lt;/em&gt; output (but not significantly so), and much smaller than GHCJS’s &lt;em&gt;100 MB&lt;/em&gt; output (which has to also contain the entire Haskell runtime, implementing haskell semantics, as well).&lt;/p&gt;
&lt;p&gt;Interestingly enough, the &lt;em&gt;original&lt;/em&gt; raw javacript I wrote in 2013 came out to about the same size, about &lt;em&gt;80 kB&lt;/em&gt;. (Well, it is about &lt;em&gt;2 kB&lt;/em&gt; of actual script, but it utilized all of &lt;em&gt;jquery&lt;/em&gt;, which implements a lot of the functionality.) Getting comparable filesizes to jquery bundles is something that’s pretty impressive to me!&lt;/p&gt;
&lt;p&gt;I’d recommend purescript to anyone who has to write simple javascript &lt;em&gt;scripts&lt;/em&gt; and wants to do it in a sane, beautiful language. I still use &lt;em&gt;ghcjs&lt;/em&gt; for actual &lt;em&gt;applications&lt;/em&gt;, for now, because I still love Haskell and its ecosystem, along with the free data type sharing and code re-usage. But for small scripts like these, purescript might just be the ideal and perfect solution!&lt;/p&gt;
&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;My main takeways —&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;I will never be able to never work on a Haskell project/application without &lt;em&gt;stack&lt;/em&gt; again (how did we even survive before &lt;em&gt;stack&lt;/em&gt;?)&lt;/li&gt;
&lt;li&gt;Hakyll is a fun little library that is a great specialized &lt;em&gt;make&lt;/em&gt; for building static websites&lt;/li&gt;
&lt;li&gt;Refactoring Haskell is an amazing experience; I would recommend it to anyone to try it out at least once in their lives&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Purescript&lt;/em&gt; is an amazing and beautiful technology that I had the pleasure of learning during this process, and generates elegant, readable javascript scripts.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This reflection post has been to help me organize my thoughts, but I hope they can be useful for those of you looking for new technologies to learn and ways to implement/approach your stack or next programming project, as well!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Unfortunately, &lt;em&gt;&lt;a href=&quot;https://github.com/jgm/highlighting-kate&quot;&gt;highlighting-kate&lt;/a&gt;&lt;/em&gt; doesn’t yet support purescript syntax highlighting?&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Meta</category><guid isPermaLink="true">http://blog.jle.im/entry/blog-rewrite-with-hakyll-and-purescript.html</guid><pubDate>Fri, 25 Mar 2016 15:59:18 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Meta</dc:subject><dc:date>2016-03-25</dc:date></item><item><title>Introducing the “Prompt” library</title><link>http://blog.jle.im/entry/introducing-the-prompt-library.html</link><description>&lt;p&gt;&lt;strong&gt;Prompt&lt;/strong&gt;: &lt;a href=&quot;https://github.com/mstksg/prompt/blob/master/README.md&quot;&gt;README&lt;/a&gt; / &lt;a href=&quot;http://hackage.haskell.org/package/prompt&quot;&gt;hackage&lt;/a&gt; / &lt;a href=&quot;https://github.com/mstksg/prompt&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Have you ever wanted to specify a computation involving some limited form of IO — like querying a database, or asking stdio — but didn’t want a computation in the &lt;code&gt;IO&lt;/code&gt; monad, opening the entire can of worms that is arbitrary &lt;code&gt;IO&lt;/code&gt;? Have you ever looked at complicated &lt;code&gt;IO a&lt;/code&gt; you wrote last week at 4am and prayed that it didn’t launch missiles if you decided to execute it? Do you want to be able to run an effectful computation and explicitly &lt;em&gt;say&lt;/em&gt; what IO it can or cannot do?&lt;/p&gt;
&lt;p&gt;Introducing the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/prompt&quot;&gt;prompt&lt;/a&gt;&lt;/em&gt; library! It’s a small little lightweight library that allows you to specify and describe computations involving forms of effects where you “ask” with a value and receive a value in return (such as a database query, etc.), but not ever care about how the effects are fulfilled — freeing you from working directly with IO.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; fooBar ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
               ,&lt;span class=&quot;ot&quot;&gt; fooBaz ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
               } &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- ask with a String, receive a String as an answer&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;promptFoo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Prompt&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
promptFoo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; fmap length (prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;running&quot;&gt;Running&lt;/h2&gt;
&lt;p&gt;You can now “run it” in IO, by talking to stdio —&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runPromptM promptFoo &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \str &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; putStrLn str &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; getLine
bar                 &lt;span class=&quot;co&quot;&gt;-- stdout prompt&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;            &lt;span class=&quot;co&quot;&gt;-- stdin response typed in&lt;/span&gt;
baz                 &lt;span class=&quot;co&quot;&gt;-- stdout prompt&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; i am baz          &lt;span class=&quot;co&quot;&gt;-- stdin response typed in&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;-- result&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(this is also just &lt;code&gt;interactP promptFoo&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;Or you can maybe request it from the environment variables:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;System.Environment&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; setEnv &lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; setEnv &lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;i am baz&amp;quot;&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runPromptM promptFoo getEnv
&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or maybe you want to fulfill the prompts purely:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;import qualified&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Data.Map&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;M&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; testMap &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; M.fromList [(&lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt;), (&lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;i am baz&amp;quot;&lt;/span&gt;)]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runPrompt promptFoo (testMap &lt;span class=&quot;fu&quot;&gt;M.!&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With &lt;code&gt;Prompt&lt;/code&gt;, specify the computation and your logic &lt;em&gt;without involving any IO&lt;/em&gt;, so you can write safe code without arbitrary side effects. If you ever receive a &lt;code&gt;Prompt&lt;/code&gt;, you know it can’t wipe out your hard drive or do any IO other than exactly what you allow it to do! I’d feel more safe running a &lt;code&gt;Prompt a b r&lt;/code&gt; than an &lt;code&gt;IO r&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can also do some cute tricks; &lt;code&gt;Prompt a () r&lt;/code&gt; with a “prompt response function” like &lt;code&gt;putStrLn&lt;/code&gt; lets you do streaming logging, and defer &lt;em&gt;how&lt;/em&gt; the logging is done — to IO, to a list?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; logHelloWord &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mapM_ prompt [&lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt;]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runPromptM logHelloWorld putStrLn
hello
world
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; execWriter &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; runPromptM logHelloWorld tell
&lt;span class=&quot;st&quot;&gt;&amp;quot;helloworld&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Prompt () b r&lt;/code&gt; is like a fancy &lt;code&gt;ReaderT b m r&lt;/code&gt;, where you “defer” the choice of the Monad.&lt;/p&gt;
&lt;h2 id=&quot;combining-with-other-effects&quot;&gt;Combining with other effects&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Prompt&lt;/code&gt; can be used as an underlying “effects” source for libraries like &lt;em&gt;pipes&lt;/em&gt;, &lt;em&gt;conduit&lt;/em&gt;, and &lt;em&gt;auto&lt;/em&gt;. If your effects are only ever asking and prompting and receiving, there’s really no need to put the entire power of &lt;code&gt;IO&lt;/code&gt; underneath your DSL as an effects source. That’s just crazy!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Prompt&lt;/code&gt; can be used with monad transformers to give you safe underlying effect sources, like &lt;code&gt;StateT s (Prompt a b) r&lt;/code&gt;, which is a stateful computation which can sometimes sequence “prompty” effects. &lt;code&gt;Prompt&lt;/code&gt; is also itself a “Traversable transformer”, with &lt;code&gt;PrompT a b t r&lt;/code&gt;. It can perform computations in the context of a Traversable &lt;code&gt;t&lt;/code&gt;, to be able to incorporate built-in short-circuiting and logging, etc.&lt;/p&gt;
&lt;p&gt;This is all abstracted over with &lt;code&gt;MonadPrompt&lt;/code&gt;, &lt;code&gt;MonadError&lt;/code&gt;, &lt;code&gt;MonadPlus&lt;/code&gt;, etc., typeclasses —&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;promptFoo2 ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadPlus&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;MonadPrompt&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; m) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
promptFoo2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    bar &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;
    str &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; readMaybe str &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; baz &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; bar baz
        &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; mzero

&lt;span class=&quot;co&quot;&gt;-- more polymorphic&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;promptFoo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadPrompt&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
promptFoo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; fmap length (prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can run &lt;code&gt;promptFoo&lt;/code&gt; as a &lt;code&gt;MaybeT (Prompt String String) Foo&lt;/code&gt;, and manually unwrap:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; interactP &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; runMaybeT &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; promptFoo2
bar
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
baz
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; i am baz
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; interactP &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; runMaybeT &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; promptFoo2
bar
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
baz
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or you can run it as a &lt;code&gt;PromptT String String MaybeT Foo&lt;/code&gt;, to have &lt;code&gt;PromptT&lt;/code&gt; handle the wrapping/unwrapping itself:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; interactPT promptFoo2
bar
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
baz
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; i am baz
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; interactPT &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; promptFoo2 &lt;span class=&quot;fu&quot;&gt;&amp;lt;|&amp;gt;&lt;/span&gt; promptFoo
bar
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
baz
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; i am baz
bar                 &lt;span class=&quot;co&quot;&gt;-- failed to parse --- retrying with promptFoo!&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
baz
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; i am baz
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The previous example of &lt;code&gt;logHelloWorld&lt;/code&gt;?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runPromptT (&lt;span class=&quot;ot&quot;&gt;logHelloWorld ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; () (&lt;span class=&quot;dt&quot;&gt;Writer&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;) ()) tell
&lt;span class=&quot;st&quot;&gt;&amp;quot;helloworld&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;runners&quot;&gt;Runners&lt;/h2&gt;
&lt;p&gt;The “runners” are:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;interactP   ::&lt;/span&gt;                  &lt;span class=&quot;dt&quot;&gt;Prompt&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;   r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; r
&lt;span class=&quot;ot&quot;&gt;interactPT  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; t &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; t r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (t r)

&lt;span class=&quot;ot&quot;&gt;runPrompt   ::&lt;/span&gt;                  &lt;span class=&quot;dt&quot;&gt;Prompt&lt;/span&gt;  a b   r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;   b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r
&lt;span class=&quot;ot&quot;&gt;runPromptM  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Prompt&lt;/span&gt;  a b   r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m r

&lt;span class=&quot;ot&quot;&gt;runPromptT  ::&lt;/span&gt;                  &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; a b t r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;    t b)  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; t r
&lt;span class=&quot;ot&quot;&gt;runPromptTM ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; a b t r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (t b)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (t r)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;runPromptM&lt;/code&gt; and &lt;code&gt;runPromptTM&lt;/code&gt; can run in monads (like &lt;code&gt;IO&lt;/code&gt;) that are &lt;em&gt;completely unrelated&lt;/em&gt; to the &lt;code&gt;Prompt&lt;/code&gt; type itself. It sequences them all “after the fact”. It’s also interesting to note that &lt;code&gt;runPrompt&lt;/code&gt; is just a glorified &lt;code&gt;Reader (a -&amp;gt; b) r&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;runPromptTM&lt;/code&gt;, you can incorporate &lt;code&gt;t&lt;/code&gt; in your “prompt response” function, too. Which brings us to our grand finale – environment variable parsing!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad.Error.Class&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad.Prompt&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Text.Read&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import qualified&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Data.Map&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;M&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Val&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MENoParse&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Val&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MENotFound&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;promptRead ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;MonadPrompt&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Val&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;Read&lt;/span&gt; b)
           &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m b
&lt;span class=&quot;co&quot;&gt;-- promptRead :: Read b =&amp;gt; Key -&amp;gt; PromptT Key Val (Either MyError) b&lt;/span&gt;
promptRead k &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    resp &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; prompt k
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; readMaybe resp &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; throwError &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MEParse&lt;/span&gt; k resp
      &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; v  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; return v

&lt;span class=&quot;ot&quot;&gt;promptFoo3 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadPrompt&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Val&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- promptFoo3 :: Applicative t =&amp;gt; PromptT Key Val t Foo&lt;/span&gt;
promptFoo3 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; promptRead &lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- running!&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- Lookup environment variables, and &amp;quot;throw&amp;quot; an error if not found&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;throughEnv ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;)
throughEnv &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runPromptTM parseFoo3 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    env &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; lookupEnv k
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; env &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MENotFound&lt;/span&gt; k)
      &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; v  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; v

&lt;span class=&quot;co&quot;&gt;-- Fulfill the prompt through user input&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;throughStdIO ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;)
throughStdIO &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; interactPT parseFoo3

&lt;span class=&quot;co&quot;&gt;-- Fulfill the prompt through user input; count blank responses as &amp;quot;not found&amp;quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;throughStdIOBlankIsError ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;)
throughStdIOBlankIsError &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runPromptTM parseFoo3 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    putStrLn k
    resp &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getLine
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; null resp
      &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MENotFound&lt;/span&gt; k)
      &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; resp

&lt;span class=&quot;co&quot;&gt;-- Fulfill the prompt purely through a Map lookup&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;throughMap ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;M.Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Val&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
throughMap m &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runPromptT parseFoo3 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; M.lookup k m &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MENotFound&lt;/span&gt; k)
      &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; v  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; v&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hope you enjoy! Please feel free to leave a comment, find me on &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;twitter&lt;/a&gt;, leave an issue on the &lt;a href=&quot;https://github.com/mstksg/prompt&quot;&gt;github&lt;/a&gt;, etc. — and I’m usually on freenode’s &lt;em&gt;#haskell&lt;/em&gt; as &lt;em&gt;jle`&lt;/em&gt; if you have any questions!&lt;/p&gt;
&lt;h2 id=&quot;comparisons&quot;&gt;Comparisons&lt;/h2&gt;
&lt;p&gt;To lay it all on the floor,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; a b t r &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; runPromptTM ::&lt;/span&gt; forall m&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (t b)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (t r) }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There is admittedly a popular misconception that I’ve seen going around that equates this sort of type to &lt;code&gt;Free&lt;/code&gt; from the &lt;em&gt;free&lt;/em&gt; package. However, &lt;code&gt;Free&lt;/code&gt; doesn’t really have anything significant to do with this. Sure, you might be able to generate this type by using &lt;code&gt;FreeT&lt;/code&gt; over a specifically chosen Functor, but…this is the case for literally any Monad ever, so that doesn’t really mean much :)&lt;/p&gt;
&lt;p&gt;It’s also unrelated in this same manner to &lt;code&gt;Prompt&lt;/code&gt; from the &lt;em&gt;MonadPrompt&lt;/em&gt; package, and &lt;code&gt;Program&lt;/code&gt; from &lt;em&gt;operational&lt;/em&gt; too.&lt;/p&gt;
&lt;p&gt;One close relative to this type is &lt;code&gt;forall m. ReaderT (a -&amp;gt; m b) m r&lt;/code&gt;, where &lt;code&gt;prompt k = ReaderT ($ k)&lt;/code&gt;. This is more or less equivalent to &lt;code&gt;Prompt&lt;/code&gt;, but still can’t do the things that &lt;code&gt;PromptT&lt;/code&gt; can do without a special instance of Monad.&lt;/p&gt;
&lt;p&gt;This type is also similar in structure to &lt;code&gt;Bazaar&lt;/code&gt;, from the &lt;em&gt;lens&lt;/em&gt; package. The biggest difference that makes &lt;code&gt;Bazaar&lt;/code&gt; unusable is because the RankN constraint is only &lt;code&gt;Applicative&lt;/code&gt;, not &lt;code&gt;Monad&lt;/code&gt;, so a &lt;code&gt;Monad&lt;/code&gt; instance is impossible. Ignoring that (or if it’s okay for you to only use the &lt;code&gt;Applicative&lt;/code&gt; instance), &lt;code&gt;Bazaar&lt;/code&gt; forces the “prompting effect” to take place in the same context as the &lt;code&gt;Traversable&lt;/code&gt; &lt;code&gt;t&lt;/code&gt;…which really defeats the purpose of this whole thing in the first place (the idea is to be able to separate your prompting effect from your application logic). If the &lt;code&gt;Traversable&lt;/code&gt; you want to transform has a “monad transformer” version, then you can somewhat simulate &lt;code&gt;PromptT&lt;/code&gt; for that specifc &lt;code&gt;t&lt;/code&gt; with the transformer version.&lt;/p&gt;
&lt;p&gt;It’s also somewhat similar to the &lt;code&gt;Client&lt;/code&gt; type from &lt;em&gt;pipes&lt;/em&gt;, but it’s also a bit tricky to use that with a different effect type than the logic &lt;code&gt;Traversable&lt;/code&gt;, as well…so it has a lot of the same difference as &lt;code&gt;Bazaar&lt;/code&gt; here.&lt;/p&gt;
&lt;p&gt;But this type is common/simple enough that I’m sure someone has it somewhere in a library that I haven’t been able to find. If you find it, let me know!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Projects</category><guid isPermaLink="true">http://blog.jle.im/entry/introducing-the-prompt-library.html</guid><pubDate>Tue, 30 Jun 2015 16:42:11 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Projects</dc:subject><dc:date>2015-06-30</dc:date></item><item><title>Fixed-Length Vector Types in Haskell, 2015</title><link>http://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html</link><description>&lt;p&gt;Fixed-length vector types (vector types that indicate the length of the vector in the type itself) are one of the more straightforward applications of the “super-Haskell” GHC type extensions. There’s a lot of magic you can do with GHC’s advanced type mechanisms, but I think fixed length vectors are a good first step to beginning to understand several extensions, including (potentially):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ConstraintKinds&lt;/li&gt;
&lt;li&gt;DataKinds&lt;/li&gt;
&lt;li&gt;GADTs&lt;/li&gt;
&lt;li&gt;KindSignatures&lt;/li&gt;
&lt;li&gt;TypeFamilies&lt;/li&gt;
&lt;li&gt;TypeOperators&lt;/li&gt;
&lt;li&gt;OverloadedLists&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And using type system plugins. (And of course the usual &lt;code&gt;UndecidableInstances&lt;/code&gt; etc.) We’ll be discussing two different ways to implement this — using type-level nats, and using the &lt;em&gt;GHC.TypeLits&lt;/em&gt; model to actually be able to use numeric literals in your types. These things are seen in the wild like with the popular &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/linear-1.18.0.1/docs/Linear-V.html&quot;&gt;linear&lt;/a&gt;&lt;/em&gt; package’s &lt;code&gt;V&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;There are a few great tutorials/writeups on this topic, but many of them are from the time before we had some of these extensions, or only discuss a few. I hope to provide a nice comprehensive look about the tools available today to really approach this topic. That being said, I am no expert myself, so I would appreciate any tips/edits/suggestions for things that I’ve missed or done not-the-best :) This post has a lot of open questions that I’m sure people who know more about this than me can answer.&lt;/p&gt;
&lt;p&gt;Most of the code in this article can be &lt;a href=&quot;https://github.com/mstksg/inCode/blob/master/code-samples/fixvec&quot;&gt;downloaded and tried out&lt;/a&gt;, so follow along if you want!&lt;/p&gt;
&lt;h2 id=&quot;the-idea&quot;&gt;The Idea&lt;/h2&gt;
&lt;p&gt;The basic idea is we’ll have a type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is a vector with items of type &lt;code&gt;a&lt;/code&gt;, whose length is somehow encoded in the &lt;code&gt;n&lt;/code&gt;. We’ll then discuss ways to do useful operations on this, as if it were a list.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; can really only be a certain “kind” of thing — a type that encodes a length. We can represent this by giving it a “kind signature”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which says that our &lt;code&gt;Vec&lt;/code&gt; type constructor takes two arguments: something of kind &lt;code&gt;Nat&lt;/code&gt; (so it can’t be any type…it has to be a type of kind &lt;code&gt;Nat&lt;/code&gt;), something of kind &lt;code&gt;*&lt;/code&gt; (the “normal” kind, of things that have values, like &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Maybe Bool&lt;/code&gt;, etc.), and returns something of kind &lt;code&gt;*&lt;/code&gt; (our vector itself).&lt;/p&gt;
&lt;h2 id=&quot;using-datakinds-for-type-level-nats&quot;&gt;Using DataKinds for Type-Level Nats&lt;/h2&gt;
&lt;p&gt;(The code in this section for this type is &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs&quot;&gt;available online&lt;/a&gt;, if you wanted to play along!)&lt;/p&gt;
&lt;p&gt;There are a couple of ways to find something for that &lt;code&gt;n&lt;/code&gt; &lt;code&gt;Nat&lt;/code&gt; kind, and one way is to use the simple inductive &lt;code&gt;Nat&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L26-27&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
         &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You might have seen this type before…it gives us value-level natural numbers, where &lt;code&gt;Z&lt;/code&gt; is zero, &lt;code&gt;S Z&lt;/code&gt; is one, &lt;code&gt;S (S Z)&lt;/code&gt; is two, &lt;code&gt;S (S (S Z))&lt;/code&gt; is three, etc. So if we had something of type &lt;code&gt;Nat&lt;/code&gt;, it could represent any natural number. This declaration gives you:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A type &lt;code&gt;Nat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A value constructor &lt;code&gt;Z :: Nat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A value constructor &lt;code&gt;S :: Nat -&amp;gt; Nat&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, with the &lt;em&gt;DataKinds&lt;/em&gt; extension, when you define this, you also define some extra fancy things. You also define a &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;Nat&lt;/code&gt;! More specifically, you get:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A kind &lt;code&gt;Nat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A type &lt;code&gt;Z :: Nat&lt;/code&gt; (&lt;code&gt;Z&lt;/code&gt;, of &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;Nat&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;A type constructor &lt;code&gt;S :: Nat -&amp;gt; Nat&lt;/code&gt; (&lt;code&gt;S&lt;/code&gt;, which takes something of kind &lt;code&gt;Nat&lt;/code&gt;, and returns a new thing of kind &lt;code&gt;Nat&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(Note that, to be principled, GHC would prefer us to use &lt;code&gt;&#39;Z&lt;/code&gt; and &lt;code&gt;&#39;S&lt;/code&gt; when we are referring to the &lt;em&gt;types&lt;/em&gt;, and this is how it’ll print them out in error messages. But we’re going to run with this for now…mostly for aesthetic reasons)&lt;/p&gt;
&lt;p&gt;We can check this out in GHCi:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;set &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XDataKinds&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So now we have a &lt;em&gt;type&lt;/em&gt; that can encode numbers. Something of type &lt;code&gt;Z&lt;/code&gt; represents zero…something of type &lt;code&gt;S Z&lt;/code&gt; represents 1…something of type &lt;code&gt;S (S Z)&lt;/code&gt; represents two.&lt;/p&gt;
&lt;p&gt;Note that you can’t ever have anything like &lt;code&gt;S Bool&lt;/code&gt;…that doesn’t work, because &lt;code&gt;Bool&lt;/code&gt; is of kind &lt;code&gt;*&lt;/code&gt;, but &lt;code&gt;S&lt;/code&gt; expects only &lt;code&gt;Nat&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;Now we can make our &lt;code&gt;Vec&lt;/code&gt; data type, with the &lt;em&gt;GADTs&lt;/em&gt; extension, or “generalized algebraic data types”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L37-44&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; a
&lt;span class=&quot;ot&quot;&gt;    (:#) ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n) a

&lt;span class=&quot;kw&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)
&lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you’ve never seen GADTs before, think of it as a way of declaring a type by giving the type of your constructors instead of just the normal boring form. It’s nothing too crazy…it’s basically like defining &lt;code&gt;Maybe&lt;/code&gt; as:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a
    &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;instead of&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In both cases, they create constructors of type &lt;code&gt;Nothing :: Maybe a&lt;/code&gt; and &lt;code&gt;Just :: a -&amp;gt; Maybe a&lt;/code&gt; anyway…so the GADT form just gives us a way to state it explicitly.&lt;/p&gt;
&lt;p&gt;Oh, we also used the &lt;em&gt;KindSignatures&lt;/em&gt; extension to be able to give a kind signature to &lt;code&gt;Vec&lt;/code&gt;…this is important because we want to make sure the first argument has to be a &lt;code&gt;Nat&lt;/code&gt;. That is, we can’t have anything silly like &lt;code&gt;Vec Bool Int&lt;/code&gt;. We also have to put a separate &lt;em&gt;StandaloneDeriving&lt;/em&gt;-extension standalone deriving clause instead of just having &lt;code&gt;deriving Show&lt;/code&gt; because &lt;code&gt;Vec&lt;/code&gt; isn’t a type that can be expressed in “normal Haskell”.&lt;/p&gt;
&lt;p&gt;Note that our type is basically like a list:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; []&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    []&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; [a]
&lt;span class=&quot;ot&quot;&gt;    (:) ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Except now our type constructor actually has a new &lt;code&gt;Nat&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This means that, because of type erasure, everything “runtime” on our new type is basically going to be identical to &lt;code&gt;[]&lt;/code&gt; (not considering compiler tricks). In-memory, this new type is essentially exactly &lt;code&gt;[]&lt;/code&gt;, but its type has an extra tag that is erased at compile-time.&lt;/p&gt;
&lt;p&gt;Okay, let’s define some useful methods:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L93-97&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;headV ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n) a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
headV (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; _)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x

&lt;span class=&quot;ot&quot;&gt;tailV ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n) a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a
tailV (_ &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ah, the classic &lt;code&gt;head&lt;/code&gt;/&lt;code&gt;tail&lt;/code&gt; duo from the days pre-dating Haskell. &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; are somewhat of a sore spot or wart in Haskell’s list API&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;, because they’re &lt;em&gt;partial functions&lt;/em&gt;. You tell people all about how Haskell is great because it can prevent run-time errors by ensuring completeness and having the type system enforce null-pointer checks…but then you go ahead and put unsafe functions that throw errors for empty lists anyways in Prelude.&lt;/p&gt;
&lt;p&gt;But here…this will never happen! We can only use &lt;code&gt;headV&lt;/code&gt; and &lt;code&gt;tailV&lt;/code&gt; on non-empty lists…it won’t typecheck for empty lists. Do you see why?&lt;/p&gt;
&lt;p&gt;It’s because all empty lists are of type &lt;code&gt;Vec Z a&lt;/code&gt;. But &lt;code&gt;headV&lt;/code&gt; and &lt;code&gt;tailV&lt;/code&gt; only take things of &lt;em&gt;type&lt;/em&gt; &lt;code&gt;Vec (S n) a&lt;/code&gt;, for any &lt;code&gt;Nat&lt;/code&gt; &lt;code&gt;n&lt;/code&gt;. So, if you ever try to use it on an empty list, it won’t even compile! No more pesky runtime bugs. &lt;code&gt;headV&lt;/code&gt; and &lt;code&gt;tailV&lt;/code&gt; are safe and will never crash at runtime!&lt;/p&gt;
&lt;p&gt;Note that the return type of &lt;code&gt;tailV&lt;/code&gt; is a vector of a length one less than the given vector. &lt;code&gt;tailV :: Vec (S Z) a -&amp;gt; Vec Z a&lt;/code&gt;, for instance…or &lt;code&gt;tailV :: Vec (S (S Z)) a -&amp;gt; Vec (S Z) a&lt;/code&gt;. Just like we want!&lt;/p&gt;
&lt;p&gt;If you tried implementing this yourself, you might notice that you actually get an &lt;em&gt;error&lt;/em&gt; from GHC if you even &lt;em&gt;try&lt;/em&gt; to handle the &lt;code&gt;Nil&lt;/code&gt; case for &lt;code&gt;tailV&lt;/code&gt; or &lt;code&gt;headV&lt;/code&gt;. GHC will know when you’ve handled all possible cases, and get mad at you if you try to handle a case that doesn’t even make sense!&lt;/p&gt;
&lt;h3 id=&quot;type-families-and-appending&quot;&gt;Type families and appending&lt;/h3&gt;
&lt;p&gt;We can also “append” vectors. But we need a way to add &lt;code&gt;Nat&lt;/code&gt;s together first. For that, we can use a type family, using the &lt;em&gt;TypeFamilies&lt;/em&gt; extension (with &lt;code&gt;TypeOperators&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L29-31&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; family (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;y ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;ch&quot;&gt;&amp;#39;Z   + y = y&lt;/span&gt;
    &lt;span class=&quot;ch&quot;&gt;&amp;#39;S x + y = &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A “type family” is like a type level function. Compare this to defining &lt;code&gt;(+)&lt;/code&gt; on the value level to the &lt;code&gt;Nat&lt;/code&gt; &lt;em&gt;data&lt;/em&gt; type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L33-35&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;(+#) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- types!&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;   &lt;span class=&quot;fu&quot;&gt;+#&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; y
&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+#&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;+#&lt;/span&gt; y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, we’re defining a new type-level function &lt;code&gt;(+)&lt;/code&gt; on two types &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, both of kind &lt;code&gt;Nat&lt;/code&gt;…and the result is their “sum”. Convince yourself that this “addition” is actually addition. Now, let’s use it for &lt;code&gt;appendV&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L99-101&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;appendV ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; m) a
appendV &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;       ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ys
appendV (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; appendV xs ys&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v1 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; v1 &lt;span class=&quot;ot&quot;&gt;`appendV`&lt;/span&gt; v2
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t v1 &lt;span class=&quot;ot&quot;&gt;`appendV`&lt;/span&gt; v2
v1 &lt;span class=&quot;ot&quot;&gt;`appendV` v2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;generating&quot;&gt;Generating&lt;/h3&gt;
&lt;p&gt;It’d be nice to have type-safe methods of &lt;em&gt;generating&lt;/em&gt; these things, too…functions like &lt;code&gt;iterate&lt;/code&gt;, or &lt;code&gt;enumFrom&lt;/code&gt;. One of the ways to do this is by using a typeclass. (Available in a &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs&quot;&gt;separate file&lt;/a&gt; to try out).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L7-8&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; v &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    unfold ::&lt;/span&gt; (b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a, b)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We’re going to call &lt;code&gt;v&lt;/code&gt; an &lt;code&gt;Unfoldable&lt;/code&gt; if you can build a &lt;code&gt;v&lt;/code&gt; from an “unfolding function” and an “initial state”. Run the function on the initial value and get the first item and a new state. Run the function on the new state and get the second item and the next state.&lt;/p&gt;
&lt;p&gt;The list instance should make it more clear:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L11-13&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; [] &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    unfold f x0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, x1) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x0
                  &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  y &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; unfold f x1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; take &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; unfold (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (x &lt;span class=&quot;ot&quot;&gt;`mod`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)) &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
[&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we can have an instance for any fixed-length vector type…where the thing “cuts off” after it’s filled the entire vector:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L46-51&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    unfold _ _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    unfold f x0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, x1) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x0
                  &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  y &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; unfold f x1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Take a moment to think about what these instances are doing.&lt;/p&gt;
&lt;p&gt;You can create a &lt;code&gt;Vec Z a&lt;/code&gt; from an unfolding function pretty easily, because the only thing with type &lt;code&gt;Vec Z a&lt;/code&gt; is &lt;code&gt;Nil&lt;/code&gt;. So just ignore the function/initial state and return &lt;code&gt;Nil&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The instance for &lt;code&gt;Vec (S n)&lt;/code&gt; is slightly more involved. To make a &lt;code&gt;Vec (S n) a&lt;/code&gt;, you need an &lt;code&gt;a&lt;/code&gt; and a &lt;code&gt;Vec n a&lt;/code&gt;. You can get the &lt;code&gt;a&lt;/code&gt; from the unfolding function…but where will you get the &lt;code&gt;Vec n a&lt;/code&gt; from? Well, you can use &lt;code&gt;unfold&lt;/code&gt; to make a &lt;code&gt;Vec n a&lt;/code&gt;! But that only makes sense if &lt;code&gt;Vec n&lt;/code&gt; is an &lt;code&gt;Unfoldable&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So, that’s why in the instance for &lt;code&gt;Vec (S n)&lt;/code&gt;, we constrain that &lt;code&gt;Vec n&lt;/code&gt; must also be an &lt;code&gt;Unfoldable&lt;/code&gt;. We make our result by using our function to create an &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;unfold&lt;/code&gt; to create a &lt;code&gt;Vec n a&lt;/code&gt; (provided &lt;code&gt;Vec n&lt;/code&gt; is an &lt;code&gt;Unfoldable&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Note that this style of declaration looks a lot like induction. We define our instance for zero…and then we say, “if &lt;code&gt;n&lt;/code&gt; is an instance, then so is &lt;code&gt;S n&lt;/code&gt;”. Induction!&lt;/p&gt;
&lt;p&gt;Let’s see this in action.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L15-24&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;replicateU ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; v &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v a
replicateU &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; unfold (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (x, x))

&lt;span class=&quot;ot&quot;&gt;iterateU ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; v &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v a
iterateU f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; unfold (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (x, f x))

&lt;span class=&quot;ot&quot;&gt;fromListMaybes ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; v &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a)
fromListMaybes &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; unfold &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \l &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; l &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                                  []   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, [])
                                  x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; x , xs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; replicateU &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;       ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; replicateU &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;       ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; iterateU succ &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;      ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListMaybes [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; tailV (iterateU succ &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;replicateU&lt;/code&gt; doesn’t need to take in an &lt;code&gt;Int&lt;/code&gt; parameter, like the on in Prelude, to say how many items to have. It just replicates enough to fill the entire vector we want!&lt;/p&gt;
&lt;h3 id=&quot;common-typeclasses&quot;&gt;Common Typeclasses&lt;/h3&gt;
&lt;p&gt;We can go in and implement common typeclasses, too. All the ones you’d expect.&lt;/p&gt;
&lt;p&gt;We can actually use the &lt;em&gt;DeriveFunctor&lt;/em&gt; extension to write a &lt;code&gt;Functor&lt;/code&gt; instance, but let’s write one on our own just for learning purposes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L53-55&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fmap _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
    fmap f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; fmap f xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For &lt;code&gt;Applicative&lt;/code&gt;, it isn’t so simple. The Applicative instance is going to be the “ZipList” instance…so we have to be able to make a &lt;code&gt;pure&lt;/code&gt; that depends on the type, and a &lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt; that depends on the type, too.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L57-63&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    pure _    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    pure x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; pure x
    (f &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; fs) &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; (fs &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; xs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For &lt;code&gt;Vec Z&lt;/code&gt;, it’s just &lt;code&gt;Nil&lt;/code&gt;. For &lt;code&gt;Vec (S n)&lt;/code&gt;…for pure, you need &lt;code&gt;x :#&lt;/code&gt; something…and that something has to be a &lt;code&gt;Vec n a&lt;/code&gt;. That’s just &lt;code&gt;pure&lt;/code&gt; for &lt;code&gt;Vec n&lt;/code&gt;! Remember, we can’t assume that &lt;code&gt;Vec n&lt;/code&gt; is an &lt;code&gt;Applicative&lt;/code&gt; just because &lt;code&gt;Vec (S n)&lt;/code&gt; is. So we need to add a constraint, that &lt;code&gt;Vec n&lt;/code&gt; an Applicative. Induction, again!&lt;/p&gt;
&lt;p&gt;For &lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt;, we can get the first item easily, it’s just &lt;code&gt;f x&lt;/code&gt;. But for the next item, we need a &lt;code&gt;Vec n a&lt;/code&gt;. Luckily…we have exactly that with the &lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt; for &lt;code&gt;Vec n&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;Remember, at the end, we’re saying “We have an &lt;code&gt;Applicative&lt;/code&gt; instance for &lt;em&gt;any&lt;/em&gt; type &lt;code&gt;Vec n&lt;/code&gt;”. The instance for &lt;code&gt;Vec Z&lt;/code&gt; has &lt;code&gt;pure _ = Nil&lt;/code&gt;. The instance for &lt;code&gt;Vec (S Z)&lt;/code&gt; has &lt;code&gt;pure x = x :# Nil&lt;/code&gt;. The instance for &lt;code&gt;Vec (S (S Z))&lt;/code&gt; has &lt;code&gt;pure x = x :# x :# Nil&lt;/code&gt;, etc. etc.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fmap (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; pure &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;         &lt;span class=&quot;co&quot;&gt;-- like replicateV!&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; liftA2 (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;) (&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;302&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;101&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;203&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;305&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I’ll leave the &lt;code&gt;Monad&lt;/code&gt; instance as an exercise, but it’s in the source files for this post. &lt;code&gt;join&lt;/code&gt; for this instance should be a “diagonal” — the first item of the first vector, the second item of the second vector, the third item of the third vector, etc.&lt;/p&gt;
&lt;p&gt;We can define &lt;code&gt;Foldable&lt;/code&gt; and &lt;code&gt;Traversable&lt;/code&gt; the same way. Like for &lt;code&gt;Functor&lt;/code&gt;, GHC can derive these with &lt;em&gt;DeriveFoldable&lt;/em&gt; and &lt;em&gt;DeriveTraversable&lt;/em&gt;…but we’ll do it again here just to demonstrate.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L65-75&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    foldMap _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mempty

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    foldMap f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; foldMap f xs

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    traverse _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; pure &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    traverse f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftA2 (&lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt;) (f x) (traverse f xs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we can only use &lt;code&gt;foldMap f xs&lt;/code&gt; on &lt;code&gt;xs :: Vec n a&lt;/code&gt;, if &lt;code&gt;Vec n&lt;/code&gt; is a &lt;code&gt;Foldable&lt;/code&gt;. So that’s why we add that constraint.&lt;/p&gt;
&lt;p&gt;Again, &lt;code&gt;liftA2 (:#) :: Applicative f =&amp;gt; f a -&amp;gt; f (Vec n a) -&amp;gt; f (Vec (S n) a)&lt;/code&gt;…so this only makes sense if &lt;code&gt;traverse f s&lt;/code&gt; gives us a &lt;code&gt;Vec n a&lt;/code&gt;. So we have to add that as a constraint.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; toList &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; traverse &lt;span class=&quot;dt&quot;&gt;Identity&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Identity&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; sequence_ &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; sequence &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; sequence &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Traversable&lt;/code&gt; of course opens a whole lot of doors. For example, we can write a “safe &lt;code&gt;fromList&lt;/code&gt;”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L26-27&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;fromListU ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; v, &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; v) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (v a)
fromListU &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sequence &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromListMaybes&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListU [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListU [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListU [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And, if you’re on GHC 7.8+, you have access to the &lt;em&gt;OverloadedLists&lt;/em&gt; language extension, where you can interpret list literals as if they were other structures.&lt;/p&gt;
&lt;p&gt;We’ve already already implemented both &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;toList&lt;/code&gt;, in a way, already, so this should be a breeze. The only trick you might see is that the &lt;code&gt;IsList&lt;/code&gt; typeclass asks for a type family to return the &lt;em&gt;type of the element in the container&lt;/em&gt; from the container type.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L86-91&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n), &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n)) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;L.IsList&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Item&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; a
    fromList xs &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; fromListU xs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; error &lt;span class=&quot;st&quot;&gt;&amp;quot;Demanded vector from a list that was too short.&amp;quot;&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; ys &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; ys
    toList      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; Data.Foldable.toList&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;set &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XOverloadedLists&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demanded&lt;/span&gt; vector from a list that was too short&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat! All of the benefits of list literals that &lt;em&gt;OverloadedLists&lt;/em&gt; offers is now available to us.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; Unfortunately, you now open yourself up to runtime errors, so…it’s actually a really bad idea for safety purposes unless you stick to only using it with infinite lists or are very disciplined. (Unless you really want to use list syntax, &lt;code&gt;fromListU&lt;/code&gt; is probably a safer choice for finite lists!)&lt;/p&gt;
&lt;h3 id=&quot;indexing&quot;&gt;Indexing&lt;/h3&gt;
&lt;p&gt;It’d be nice to be able to index into these, of course. For type-safe indexing, we can take advantage of a trick using the &lt;code&gt;Proxy&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;Many might remember having to get a &lt;code&gt;TypeRep&lt;/code&gt; for a &lt;code&gt;Typeable&lt;/code&gt; instance by doing something like &lt;code&gt;typeOf (undefined :: IO Double)&lt;/code&gt;. That’s because &lt;code&gt;typeOf :: Typeable a =&amp;gt; a -&amp;gt; TypeRep&lt;/code&gt;. If you wanted to get the &lt;code&gt;typeRep&lt;/code&gt; for an &lt;code&gt;IO Double&lt;/code&gt; using &lt;code&gt;typeOf&lt;/code&gt;, you have to pass in an &lt;code&gt;IO Double&lt;/code&gt;. But if you don’t have one at hand, you can just use &lt;code&gt;undefined&lt;/code&gt; with a type annotation. It’s a bit of a dirty hack, but it works because &lt;code&gt;typeOf&lt;/code&gt; doesn’t care about the first argument’s value…just its type.&lt;/p&gt;
&lt;p&gt;These days, we like to be a bit less embarrassing and use something called &lt;code&gt;Proxy&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Proxy a&lt;/code&gt; is a bit like &lt;code&gt;()&lt;/code&gt;. It only has one constructor, and doesn’t take any arguments. But we can use the type signature to “pass in types” to functions, as “arguments”.&lt;/p&gt;
&lt;p&gt;We have a couple of options here. One is to make a typeclass for type level nats to turn them into an &lt;code&gt;Integer&lt;/code&gt; or a value-level &lt;code&gt;Nat&lt;/code&gt;, and then do an “unsafe indexing” after verifying, through types, that the index is smaller than the length.&lt;/p&gt;
&lt;p&gt;However, this is a little bit silly because we’re just doing an unsafe indexing in the end anyway, so the compiler can’t help us at all. Wouldn’t it be nice if we could get the compiler on our side and write a &lt;em&gt;real&lt;/em&gt; safe index?&lt;/p&gt;
&lt;p&gt;There are many ways to approach this problem, but one way is to make a specific &lt;code&gt;Index&lt;/code&gt; typeclass: (or make another typeclass like &lt;code&gt;Take&lt;/code&gt;, and write &lt;code&gt;index&lt;/code&gt; in terms of it)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L77-78&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;n ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;) v &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    index ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, we can say that &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are instances of &lt;code&gt;Index n v&lt;/code&gt; if and only if you can safely (totally) index into &lt;code&gt;v a&lt;/code&gt; at index &lt;code&gt;n&lt;/code&gt;. That is, if every value of type &lt;code&gt;v a&lt;/code&gt; ever has an index at &lt;code&gt;n&lt;/code&gt;, a &lt;code&gt;Nat&lt;/code&gt;. (By the way, we need &lt;em&gt;MultiParamTypeClasses&lt;/em&gt; to be able to make a type class with two parameters)&lt;/p&gt;
&lt;p&gt;So, &lt;code&gt;n ~ S Z&lt;/code&gt; and &lt;code&gt;v ~ Vec (S (S Z)) a&lt;/code&gt; has an instance, because you can get the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chl=n%20%3D%201&quot; alt=&quot;n = 1&quot; title=&quot;n = 1&quot; /&gt; element (the second element) from &lt;em&gt;any&lt;/em&gt; value of type &lt;code&gt;Vec (S (S Z)) a&lt;/code&gt; (a length-two vector).&lt;/p&gt;
&lt;p&gt;But &lt;code&gt;n ~ S Z&lt;/code&gt; and &lt;code&gt;v ~ Vec (S Z) a&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt;. There are actually &lt;em&gt;no&lt;/em&gt; length-1 vectors that have a &lt;img style=&quot;vertical-align:middle&quot; src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chl=1&quot; alt=&quot;1&quot; title=&quot;1&quot; /&gt; index (second element).&lt;/p&gt;
&lt;p&gt;Note that we use the &lt;code&gt;Proxy&lt;/code&gt; trick we discussed, so that we can indicate somehow what index we really want. It is a trick that basically allows us to pass a &lt;em&gt;type&lt;/em&gt; (&lt;code&gt;S Z&lt;/code&gt;, &lt;code&gt;S (S Z)&lt;/code&gt;, etc.) as a “value”.&lt;/p&gt;
&lt;p&gt;Let’s write our instances — but only the instances that &lt;em&gt;make sense&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L80-84&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    index _ (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; _) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; forall n m&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; n (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n) (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; m)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    index _ (_ &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n) xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first case instance makes sense. We can definitely index at index &lt;code&gt;Z&lt;/code&gt; (zero) of &lt;em&gt;any&lt;/em&gt; &lt;code&gt;Vec (S n) a&lt;/code&gt; — the only thing we can’t index &lt;code&gt;Z&lt;/code&gt; into is &lt;code&gt;Vec Z a&lt;/code&gt;. So, if our vector is of length 1 or higher, we can index at position 0.&lt;/p&gt;
&lt;p&gt;The second case says that, if we can index into &lt;code&gt;n&lt;/code&gt; of a &lt;code&gt;Vec m a&lt;/code&gt;, then of course we can index into an &lt;code&gt;S n&lt;/code&gt; of a &lt;code&gt;Vec (S m) a&lt;/code&gt;. To index into &lt;code&gt;S n&lt;/code&gt; of a &lt;code&gt;Vec (S m) a&lt;/code&gt;, all we need to do is index into &lt;code&gt;n&lt;/code&gt; of the &lt;code&gt;Vec m a&lt;/code&gt; tail!&lt;/p&gt;
&lt;p&gt;We have to use the &lt;em&gt;ScopedTypeVariables&lt;/em&gt; extension to enable us to use, with the &lt;code&gt;forall&lt;/code&gt; statement, the &lt;code&gt;n&lt;/code&gt; in our instance when we are writing our type for &lt;code&gt;Proxy&lt;/code&gt;. If we didn’t, the &lt;code&gt;n&lt;/code&gt; in &lt;code&gt;Proxy n&lt;/code&gt; in our &lt;code&gt;index&lt;/code&gt; definition would be considered unrelated by GHC to the &lt;code&gt;n&lt;/code&gt; in the instance statement, &lt;code&gt;Index (S n) (Vec (S m))&lt;/code&gt;. (This is the only reason we need the &lt;code&gt;forall&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;In any case, note the similarity of this algorithm to the actual indexing function on lists:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!!&lt;/span&gt; (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_ ) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x
n &lt;span class=&quot;fu&quot;&gt;!!&lt;/span&gt; (_&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;!!&lt;/span&gt; xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;trying it out…&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Compile&lt;/span&gt; error&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It’s an error, but remember, it’s a &lt;em&gt;compiler&lt;/em&gt; error, that happens before any code is ever even run! No more indexing errors at runtime! Kiss your days of hunting segfault errors in C goodbye!&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This is something I haven’t really been able to find a good answer too. But notice that we actually could have written a “bad” instance of the second instance of &lt;code&gt;Index&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n) (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; m)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    index _ (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; _) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And this compiles fine…but gives the wrong behavior, or at least the behavior we don’t want!&lt;/p&gt;
&lt;p&gt;Does anybody know a way to state the type of &lt;code&gt;Index&lt;/code&gt; or &lt;code&gt;index&lt;/code&gt; in a way that implementations like this are impossible?&lt;/p&gt;
&lt;p&gt;There’s a “fundamental” problem here, it seems, because we can’t really demand or specify anything by the return type, like we could in the other examples. In the other examples, we sort of restricted the implementation by choosing our return type carefully…but for here, it’s just &lt;code&gt;a&lt;/code&gt;. I’d love to hear if anyone has any thoughts on this.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;You might notice that it’s a bit of a plain to write &lt;code&gt;S (S (S (S Z)))&lt;/code&gt;, etc., especially for large numbers. And I wouldn’t even think about writing it for the hundreds.&lt;/p&gt;
&lt;p&gt;We’ll “fix” this in the next section. However, even before this, you actually can generate these “automatically” with template haskell, using techniques from &lt;a href=&quot;http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf&quot;&gt;Functional Pearls: Implicit Configurations&lt;/a&gt;, and the &lt;a href=&quot;http://hackage.haskell.org/package/linear-1.18.0.1/docs/Linear-V.html&quot;&gt;linear&lt;/a&gt; package does just this. (This path slipped my mind before I posted because I didn’t really consider template Haskell, and I think I’ll edit in a section here soon). With this in mind, I still don’t really consider Template Haskell an optimal or clean approach :)&lt;/p&gt;
&lt;h2 id=&quot;using-typelits-and-type-checker-plugins&quot;&gt;Using TypeLits and Type Checker Plugins&lt;/h2&gt;
&lt;p&gt;(This next section uses code that is &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs&quot;&gt;also available online&lt;/a&gt;, as well!)&lt;/p&gt;
&lt;p&gt;Using a custom &lt;code&gt;Nat&lt;/code&gt; kind and &lt;em&gt;DataKinds&lt;/em&gt; is nice and all, but it’s a bit of a hassle to express large numbers like 100, 1000, etc. However, as of GHC 7.8, we’ve had the ability to actually &lt;em&gt;use&lt;/em&gt; numeric (integer) literals in our types. Instead of writing &lt;code&gt;S (S Z)&lt;/code&gt;, we can write &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;GHC can’t yet quite work with that well by default. It has trouble proving statements about variables, like &lt;code&gt;(n + 1) ~ (1 + n)&lt;/code&gt; (that &lt;code&gt;n + 1&lt;/code&gt; is “the same as” &lt;code&gt;1 + n&lt;/code&gt;). Fortunately for us, since GHC 7.10, we have a way to “extend” the type checker with custom plugins that &lt;em&gt;can&lt;/em&gt; prove things like this for us. (Note that this &lt;code&gt;+&lt;/code&gt; is the one from &lt;code&gt;GHC.TypeLits&lt;/code&gt;…not the one we defined earlier.)&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/ghc-typelits-natnormalise&quot;&gt;ghc-typelits-natnormalise&lt;/a&gt;&lt;/em&gt; package is a package providing such a plugin. We can have GHC use it to extend its type checking by passing in &lt;code&gt;-fplugin GHC.TypeLits.Normalise&lt;/code&gt; when we execute our code, or by adding a pragma:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L14-14&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to the top of our file, along with our &lt;code&gt;LANGUAGE&lt;/code&gt; pragmas. (Assuming, of course, a GHC 7.10+)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;set &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XDataKinds&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XTypeOperators&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XTypeFamilies&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;GHC.TypeLits&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; ((n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;~&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; n)) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Compile&lt;/span&gt; error&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cannot&lt;/span&gt; match &lt;span class=&quot;ot&quot;&gt;`1 + n`&lt;/span&gt; with &lt;span class=&quot;ot&quot;&gt;`n + 1`&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;set &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;fplugin &lt;span class=&quot;dt&quot;&gt;GHC.TypeLits.Normalise&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; ((n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;~&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; n)) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n
&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- success!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GHC now uses the plugin to prove that the two are really equivalent.&lt;/p&gt;
&lt;p&gt;If you wanted to play along or try out the code samples, I recommend you use a sandbox:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# in directory of your choice&lt;/span&gt;
$ &lt;span class=&quot;kw&quot;&gt;cabal&lt;/span&gt; sandbox init
$ &lt;span class=&quot;kw&quot;&gt;cabal&lt;/span&gt; install ghc-typelits-natnormalise
$ &lt;span class=&quot;kw&quot;&gt;cabal&lt;/span&gt; exec bash
&lt;span class=&quot;co&quot;&gt;# now the package is in scope, when you use ghci or runghc&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With that in mind, let’s start restating everything in terms of &lt;em&gt;TypeLits&lt;/em&gt; and see what it gains us.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L33-40&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; a
&lt;span class=&quot;ot&quot;&gt;    (:#) ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a

&lt;span class=&quot;kw&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)
&lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A little nicer, right? &lt;code&gt;Nil&lt;/code&gt; is a &lt;code&gt;Vec 0 a&lt;/code&gt;, and &lt;code&gt;x :# xs&lt;/code&gt; is an element with a &lt;code&gt;Vec (n - 1) a&lt;/code&gt;, which overall is a &lt;code&gt;Vec n a&lt;/code&gt;. Let’s go over everything again to see how it’d look in the new regime. (Note that the kind of the type number literals is also called &lt;code&gt;Nat&lt;/code&gt;…unrelated to our &lt;code&gt;Nat&lt;/code&gt; we used before.)&lt;/p&gt;
&lt;h2 id=&quot;a-new-look&quot;&gt;A new look&lt;/h2&gt;
&lt;p&gt;First of all, we’re going to have to define &lt;em&gt;TypeLit&lt;/em&gt; comparison operators, as they aren’t built in in a useful way.&lt;/p&gt;
&lt;p&gt;We have the type family (remember those?) &lt;code&gt;CmpNat x y&lt;/code&gt;, which returns an &lt;code&gt;Ordering&lt;/code&gt; (&lt;code&gt;LT&lt;/code&gt;, &lt;code&gt;EQ&lt;/code&gt;, or &lt;code&gt;GT&lt;/code&gt;) type (of kind &lt;code&gt;Ordering&lt;/code&gt;, using &lt;em&gt;DataKinds&lt;/em&gt;…lifting a type and its value constructors to a kind and its types), which is provided and defined for us by GHC in &lt;code&gt;GHC.TypeLits&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So defining a &lt;code&gt;x &amp;gt; y&lt;/code&gt; constraint is pretty straightforward:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L31-31&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CmpNat&lt;/span&gt; x y &lt;span class=&quot;fu&quot;&gt;~&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;GT&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we need the &lt;em&gt;ConstraintKinds&lt;/em&gt; extension for this to work, as &lt;code&gt;1 &amp;gt; 2&lt;/code&gt; is now a &lt;em&gt;constraint&lt;/em&gt;, of kind &lt;code&gt;Constraint&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Given this, let’s do our favorite list functions, &lt;code&gt;headV&lt;/code&gt; and &lt;code&gt;tailV&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L89-93&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;headV ::&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
headV (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; _)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x

&lt;span class=&quot;ot&quot;&gt;tailV ::&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) a
tailV (_ &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Magnificent!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; headV (&lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; ())
&lt;span class=&quot;co&quot;&gt;-- Error!  Cannot unite &amp;#39;EQ with &amp;#39;GT&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat! The error, remember, is at &lt;em&gt;compile time&lt;/em&gt;, and not at runtime. If we ever tried to do an unsafe head, our code wouldn’t even &lt;em&gt;compile&lt;/em&gt;! The error message comes from the fact that we need &lt;img style=&quot;vertical-align:middle&quot; src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chl=n%20%3E%200&quot; alt=&quot;n &amp;gt; 0&quot; title=&quot;n &amp;gt; 0&quot; /&gt;, but we have &lt;img style=&quot;vertical-align:middle&quot; src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chl=n%20%3D%200&quot; alt=&quot;n = 0&quot; title=&quot;n = 0&quot; /&gt; instead. We have &lt;code&gt;EQ&lt;/code&gt;, but we need &lt;code&gt;GT&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There is one problem here, though — GHC gives us a warning for not pattern matching on &lt;code&gt;Nil&lt;/code&gt;. But, if we do try to pattern match on &lt;code&gt;Nil&lt;/code&gt;, we get a type error, like the same one we got when using our custom type nats. I think this is probably something that a plugin or sufficiently smart &lt;code&gt;CmpNat&lt;/code&gt; might be able to handle…but I’m not totally sure. Right now, the best thing I can think of is just to do a wildcard match, &lt;code&gt;headV _ = error &amp;quot;What?&amp;quot;&lt;/code&gt;, knowing that that case will never be reached if your program compiles successfully.&lt;/p&gt;
&lt;p&gt;Moving on, we see that we don’t even have to do any extra work to define our own type family &lt;code&gt;x + y&lt;/code&gt;…because &lt;code&gt;GHC.TypeLits&lt;/code&gt; already defines it for us! So, we can instantly write….&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L95-97&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;appendV ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; m) a
appendV &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;       ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ys
appendV (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; appendV xs ys&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v1 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; iterateU succ &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; v1 &lt;span class=&quot;ot&quot;&gt;`appendV`&lt;/span&gt; v2
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t v1 &lt;span class=&quot;ot&quot;&gt;`appendV` v2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
v1 &lt;span class=&quot;ot&quot;&gt;`appendV` v2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And our list generating typeclasses —&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L42-47&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    unfold _ _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)), n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    unfold f x0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, x1) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x0
                  &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  y &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; unfold f x1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The translation is pretty mechanical, but I think that this new formulation looks…really nice, and really powerful. “If you can build a list from &lt;img style=&quot;vertical-align:middle&quot; src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chl=n%20-%201&quot; alt=&quot;n - 1&quot; title=&quot;n - 1&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chl=n%20%3E%200&quot; alt=&quot;n &amp;gt; 0&quot; title=&quot;n &amp;gt; 0&quot; /&gt;, then you can build a list for &lt;img style=&quot;vertical-align:middle&quot; src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chl=n&quot; alt=&quot;n&quot; title=&quot;n&quot; /&gt;!&lt;/p&gt;
&lt;p&gt;Note that because our definitions of &lt;code&gt;replicateU&lt;/code&gt;, &lt;code&gt;iterateU&lt;/code&gt;, and &lt;code&gt;fromListMaybes&lt;/code&gt; was polymorphic over all &lt;code&gt;Unfoldable&lt;/code&gt;, we can actually re-use them from before:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; iterateU succ &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; int
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; iterateU succ &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; replicateU &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The actual types are much nicer, too — we can write &lt;code&gt;Vec 10 Int&lt;/code&gt; instead of &lt;code&gt;Vec (S (S (S (S (S (S (S (S (S (S Z)))))))))) Int&lt;/code&gt; without resorting to template haskell.&lt;/p&gt;
&lt;p&gt;Going through all of our other typeclasses/functions and making the adjustments… (remembering that we can also derive &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt;, and &lt;code&gt;Foldable&lt;/code&gt; using GHC)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L49-87&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fmap _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
    fmap f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; fmap f xs

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    pure _    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)), n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    pure x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; pure x
    (f &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; fs) &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; (fs &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; xs)

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    foldMap _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mempty

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)), n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    foldMap f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; foldMap f xs

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    traverse _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; pure &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)), n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    traverse f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftA2 (&lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt;) (f x) (traverse f xs)

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;n ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;) v &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    index ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (m &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    index _ (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; _) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; forall n m&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (m &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)), n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, m &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; n (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    index _ (_ &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)) xs

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n), &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n)) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;L.IsList&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Item&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; a
    fromList xs &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; fromListU xs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; error &lt;span class=&quot;st&quot;&gt;&amp;quot;Demanded vector from a list that was too short.&amp;quot;&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; ys &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; ys
    toList      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; Data.Foldable.toList&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Remember, we use the &lt;code&gt;forall&lt;/code&gt; here with &lt;em&gt;ScopedTypeVariables&lt;/em&gt; to be able to say that the &lt;code&gt;n&lt;/code&gt; in the type signature is the same &lt;code&gt;n&lt;/code&gt; that is in the type of &lt;code&gt;Proxy&lt;/code&gt;)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListU [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListU [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Couldn&amp;#39;t&lt;/span&gt; match &lt;span class=&quot;ch&quot;&gt;&amp;#39;EQ with &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;GT&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;set &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XOverloadedLists&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demanded&lt;/span&gt; vector from a list that was too short&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I think, overall, this formulation gives a much nicer interface. Being able to just write &lt;img style=&quot;vertical-align:middle&quot; src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chl=10&quot; alt=&quot;10&quot; title=&quot;10&quot; /&gt; is pretty powerful. The usage with &lt;em&gt;OverloadedLists&lt;/em&gt; is pretty clean, too, especially when you can do things like &lt;code&gt;[1,3..] :: Vec 10 Int&lt;/code&gt; and take full advantage of list syntax and succinct vector types. (Minding your runtime errors, of course)&lt;/p&gt;
&lt;p&gt;However, you do again get the problem that GHC is not able to do real completeness checking and asks for the &lt;code&gt;Nil&lt;/code&gt; cases still of everything…but adding a &lt;code&gt;Nil&lt;/code&gt; case will cause a type error. The only solution is to add a &lt;code&gt;_&lt;/code&gt; wildcard chase, but…again, this isn’t quite satisfactory.&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; If anybody has a way to get around this, I’d love to know :)&lt;/p&gt;
&lt;h2 id=&quot;alternative-underlying-representations&quot;&gt;Alternative Underlying Representations&lt;/h2&gt;
&lt;p&gt;Recall that our &lt;code&gt;Vec&lt;/code&gt; was basically identically the normal list type, with an extra field in the type. Due to type erasure, the two are represented exactly the same in memory. So we have &lt;img style=&quot;vertical-align:middle&quot; src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chl=O%28n%29&quot; alt=&quot;O(n)&quot; title=&quot;O(n)&quot; /&gt; appends, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chl=O%28n%29&quot; alt=&quot;O(n)&quot; title=&quot;O(n)&quot; /&gt; indexing, etc. Our type is essentially equal to&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;VecList&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For this type, though, we’d need to use “smart constructors” and extractors instead of &lt;code&gt;1 :# 2 :# Nil&lt;/code&gt; etc.&lt;/p&gt;
&lt;p&gt;We could, however, chose a more efficient type, like &lt;code&gt;Vector&lt;/code&gt; from the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/vector-0.10.12.2/docs/Data-Vector.html#t:Vector&quot;&gt;vector&lt;/a&gt;&lt;/em&gt; package:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;VecVector&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And, if you made sure to wrap everything with smart constructors, you now have &lt;em&gt;type safe&lt;/em&gt; &lt;img style=&quot;vertical-align:middle&quot; src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chl=O%281%29&quot; alt=&quot;O(1)&quot; title=&quot;O(1)&quot; /&gt; random indexing!&lt;/p&gt;
&lt;p&gt;(This is representation is similar to the one used by the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/linear-1.18.0.1/docs/Linear-V.html&quot;&gt;linear&lt;/a&gt;&lt;/em&gt; package.)&lt;/p&gt;
&lt;h2 id=&quot;more-operations&quot;&gt;More Operations&lt;/h2&gt;
&lt;p&gt;One really weird quirk with this is that many functions you’d normally write using pattern matching you’d now might start writing using typeclasses. One example would be our implementation of indexing, using an &lt;code&gt;IndexV&lt;/code&gt; typeclass.&lt;/p&gt;
&lt;p&gt;A bunch of one-shot typeclasses is sort of unideal, as typeclasses are sort of ugly and non-first-class. Ideally you’d only have a few typeclasses for as generic an interface as possible, and then be able to do everything from those. Sometimes this just isn’t practical. I did mention one way around it, which was to make a typeclass to “reify” or turn your type into actual data, and then manipulate your data in an “unsafe” way knowing that the type checker checked that the data matched.&lt;/p&gt;
&lt;p&gt;We’ll demonstrate with &lt;code&gt;SomeNat&lt;/code&gt; from &lt;code&gt;GHC.TypeLits&lt;/code&gt;, but you can also make our own for our inductive &lt;code&gt;Nat&lt;/code&gt; type we used in the first half, too.&lt;/p&gt;
&lt;p&gt;If we use our “wrapped &lt;code&gt;Vector&lt;/code&gt; approach”, we can just do:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a

index&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n, m &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
index p (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; v) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; v &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt; fromInteger (natVal p)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That is, &lt;code&gt;index&lt;/code&gt; internally uses &lt;code&gt;(!)&lt;/code&gt;, an unsafe operator…but only after we assure properly that it’s safe to use by stating &lt;code&gt;m &amp;gt; n&lt;/code&gt; in the constraint. We can be sure that GHC will catch any instance where someone tries to index into a &lt;code&gt;Vec m a&lt;/code&gt; whose &lt;code&gt;m&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; greater than the index desired.&lt;/p&gt;
&lt;p&gt;The rest is up to you, though — to prove that indexing into a number smaller than &lt;code&gt;m&lt;/code&gt; will always provide an answer. We have to make sure our smart constructors are okay and that &lt;code&gt;(!)&lt;/code&gt; behaves like we think it does.&lt;/p&gt;
&lt;h2 id=&quot;singletons&quot;&gt;Singletons&lt;/h2&gt;
&lt;p&gt;Another answer to these sort of ad-hoc typeclasses is to use techniques involving singletons. Going all into how to use singletons to work with these is an article on its own…luckily, this article has already been written as &lt;a href=&quot;https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell&quot;&gt;Part 1: Dependent Types in Haskell&lt;/a&gt; by Hiromi ISHII. A major advantage is that you replace typeclasses with type families and more parameterized types. You’ll have to work with an understanding of how singletons work, and accept using some template haskell to generate singleton types for your data types (or write them yourself!). But it’s a powerful way to bring something like dependent types into Haskell, and there’s already a lot of infrastructure of support on it on hackage and in the haskell dev ecosystem in general. I recommend looking at the linked article!&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Hopefully you’ll see that we are able to apply the full type-safety of the Haskell compiler to our programs regarding lists by encoding the length of the list in its type and limiting its operations by specifically typed functions and choice of instances. I also hope that you’ve been able to become familiar with seeing a lot of GHC’s basic type extensions in real applications :)&lt;/p&gt;
&lt;p&gt;Feel free to &lt;a href=&quot;https://github.com/mstksg/inCode/blob/master/code-samples/fixvec&quot;&gt;download and run&lt;/a&gt; any of the samples&lt;/p&gt;
&lt;p&gt;Please let me know if I got anything wrong, or if there are any techniques that I should mention here that are out and in the wild today :)&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Can we get them out of Prelude? Please? :)&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;By the way, the GHC wiki seems to claim that &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists#Length-indexedobservedVectors&quot;&gt;using &lt;em&gt;OverloadedLists&lt;/em&gt; this way is impossible&lt;/a&gt;. Anyone know what’s going on here? Did we move fast and break everything?&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;Interestingly enough, I think this is something where you could have the best of both situations with the Template Haskell method. But I’d hope for something that works on the beautiful TypeLits :’(&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Tutorials</category><category>Reference</category><guid isPermaLink="true">http://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html</guid><pubDate>Tue,  5 May 2015 18:16:07 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Tutorials, Reference</dc:subject><dc:date>2015-05-05</dc:date></item><item><title>mtl is Not a Monad Transformer Library</title><link>http://blog.jle.im/entry/mtl-is-not-a-monad-transformer-library.html</link><description>&lt;p&gt;&lt;em&gt;mtl&lt;/em&gt; is not a monad transformer library — contrary to popular conception. I believe that this commonly spread myth is due in part to some rather peculiar branding choices (the name of the library) and in part to some historical accidents (&lt;em&gt;mtl&lt;/em&gt; was, in the distant and pre-historic past, indeed a monad transformer library).&lt;/p&gt;
&lt;p&gt;What is &lt;em&gt;mtl&lt;/em&gt;? It is a library of &lt;em&gt;interfaces&lt;/em&gt; you can provide to your own types, in the form of typeclasses. It abstracts over &lt;em&gt;different design patterns&lt;/em&gt; for different types, in the form of typeclasses. Just like Functor abstracts over “things that can be fmapped”. &lt;em&gt;mtl&lt;/em&gt; provides typeclasses abstracting over many useful patterns that many types satisfy — patterns involving different sorts of “effects”.&lt;/p&gt;
&lt;h2 id=&quot;the-patterns&quot;&gt;The Patterns&lt;/h2&gt;
&lt;h3 id=&quot;monaderror&quot;&gt;MonadError&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MonadError&lt;/code&gt; is a generic interface over things where you can throw “errors” of a specific type &lt;code&gt;e&lt;/code&gt;, and “catch” them. It offers two methods: &lt;code&gt;throwError :: e -&amp;gt; m a&lt;/code&gt;, and &lt;code&gt;catchError :: m a -&amp;gt; (e -&amp;gt; m a) -&amp;gt; m a&lt;/code&gt;, which does what you’d expect from an error monad.&lt;/p&gt;
&lt;p&gt;Now, we have a generic interface to work on &lt;em&gt;all specfic type error-throwing Monads&lt;/em&gt;. The &lt;code&gt;Either&lt;/code&gt; type comes to mind as an obvious candidate:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadError&lt;/span&gt; e (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; e) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    throwError &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt;
    catchError s f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; s &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                       &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; s
                       &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; e  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f e&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But there are definitely other instances possible. How about for &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;IOException&lt;/code&gt;s, in specific?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    throwError  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ioError
    catchErrror &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; catch     &lt;span class=&quot;co&quot;&gt;-- will not catch non-IOExceptions&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is great, because we can now write code &lt;em&gt;generic&lt;/em&gt; over &lt;em&gt;all&lt;/em&gt; specific-type error things!&lt;/p&gt;
&lt;h4 id=&quot;error-behaviorfor-free&quot;&gt;Error behavior…for free!&lt;/h4&gt;
&lt;p&gt;If we’re clever enough, we can actually imbue any arbitrary Monad &lt;code&gt;m&lt;/code&gt; with rudimentary, basic, “dumb” error handling by using the &lt;code&gt;ExceptT&lt;/code&gt; type. An &lt;code&gt;ExceptT e m&lt;/code&gt; behaves &lt;em&gt;just&lt;/em&gt; like our original Monad &lt;code&gt;m&lt;/code&gt; in every way…except now, we have access to rudmentary implementations of side-channels of &lt;code&gt;throwError&lt;/code&gt; and &lt;code&gt;catchError&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is pretty useful…to be able to add short-circuiting error behavior to any Monad we wanted. But remember, &lt;code&gt;ExceptT&lt;/code&gt; is not the “point” of &lt;code&gt;MonadError&lt;/code&gt;. It’s just one way to generate instances for free given a Monad. The real power of &lt;code&gt;MonadError&lt;/code&gt; is in the ability to write generically over many Monads with some sort of “error” behavior, like &lt;code&gt;Either&lt;/code&gt; or &lt;code&gt;IO&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;monadstate&quot;&gt;MonadState&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;MonadState s m&lt;/code&gt; is a Monad &lt;code&gt;m&lt;/code&gt; where, during in the context of &lt;code&gt;m&lt;/code&gt;, you have access to a global state of type &lt;code&gt;s&lt;/code&gt; that you can modify.&lt;/p&gt;
&lt;p&gt;You can “get” it with &lt;code&gt;get :: m s&lt;/code&gt;. You can modify it with &lt;code&gt;modify :: (s -&amp;gt; s) -&amp;gt; m ()&lt;/code&gt;. You can replace it with &lt;code&gt;put :: s -&amp;gt; m ()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are a lot of types that can offer this type of interface. You might have, for example, a type where “getting” the state comes from reading an &lt;code&gt;IORef&lt;/code&gt;, and “putting” it comes from writing to the &lt;code&gt;IORef&lt;/code&gt;. Or maybe the state can come from a a query to a database…where &lt;code&gt;get&lt;/code&gt; queries a database in IO, and &lt;code&gt;put&lt;/code&gt; writes to the database.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MonadState&lt;/code&gt;, as a typeclass, gives you the ability to &lt;em&gt;write generically over all Monads with state&lt;/em&gt;. You can now write generically over those database state things…or those IORef state things…or those web query things…or anything that cares to implement the interface!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MonadState&lt;/code&gt; says, “the functions and actions I write can work for &lt;em&gt;all&lt;/em&gt; Monads offering state I can modify!” An action of type &lt;code&gt;MonadState String m =&amp;gt; m Double&lt;/code&gt; can create a &lt;code&gt;Double&lt;/code&gt; from &lt;em&gt;any&lt;/em&gt; monad offering some sort of &lt;code&gt;String&lt;/code&gt; state.&lt;/p&gt;
&lt;h4 id=&quot;statefor-free&quot;&gt;State…for free!&lt;/h4&gt;
&lt;p&gt;Again, we can actually imbue any Monad &lt;code&gt;m&lt;/code&gt; with some very rudimentary, “dumb” stateful interface, using a type called &lt;code&gt;StateT&lt;/code&gt;. A &lt;code&gt;StateT s m&lt;/code&gt; behaves just like our monad &lt;code&gt;m&lt;/code&gt; (be it &lt;code&gt;IO&lt;/code&gt;, &lt;code&gt;Reader&lt;/code&gt;, &lt;code&gt;ST&lt;/code&gt;, &lt;code&gt;STM&lt;/code&gt;…), except now we have access to a rudimentary state getting-and-putting mechanism on a state of type &lt;code&gt;s&lt;/code&gt;, using a form of function composition. The implementation of the &lt;code&gt;StateT&lt;/code&gt; handles it under the hood.&lt;/p&gt;
&lt;p&gt;Obviously, being able to add a rudimentary stateful interface on top of any Monad is pretty useful. Very useful, in fact!&lt;/p&gt;
&lt;p&gt;But remember, this isn’t the &lt;em&gt;point&lt;/em&gt; of &lt;code&gt;MonadState&lt;/code&gt;. &lt;code&gt;MonadState&lt;/code&gt; doesn’t exist for &lt;code&gt;StateT&lt;/code&gt;. &lt;code&gt;StateT&lt;/code&gt; is just a way to generate a free instance of &lt;code&gt;MonadState&lt;/code&gt; if you just want to add rudimentary statefulness to an existing Monad. But there are many instances of &lt;code&gt;MonadState&lt;/code&gt;…really, &lt;code&gt;MonadState&lt;/code&gt; has nothing to do with &lt;code&gt;StateT&lt;/code&gt; fundamentally, any more than &lt;code&gt;Monad&lt;/code&gt; has to do with &lt;code&gt;Maybe&lt;/code&gt; fundamentally. And &lt;code&gt;MonadState&lt;/code&gt; and &lt;code&gt;StateT&lt;/code&gt; don’t even come from the same library!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;mtl&lt;/em&gt; offers a generic interface for working with all monads offering a statey API.&lt;/p&gt;
&lt;h3 id=&quot;monadreader&quot;&gt;MonadReader&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MonadReader&lt;/code&gt; is more or less the same thing…it offers a generic interface to work on monads that have access to some sort of global, unchanging “environment”. An example might be a Monad where you could work with command line arguments, or environment variables, assuming they are read once and fixed when things start up. You could access the command line arguments with &lt;code&gt;ask&lt;/code&gt;, and use them in your program.&lt;/p&gt;
&lt;h3 id=&quot;monadio&quot;&gt;MonadIO&lt;/h3&gt;
&lt;p&gt;This one is actaully from &lt;em&gt;transformers&lt;/em&gt;, but it gives a nice picture. Any &lt;code&gt;MonadIO m&lt;/code&gt; is a &lt;code&gt;Monad&lt;/code&gt; that allows you to embed and sequence in any arbitrary IO action. This is pretty useful! In the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/persistent&quot;&gt;persistent&lt;/a&gt;&lt;/em&gt; database library, for example — the main “database access type monad” can sequence actions that access databases &lt;em&gt;and&lt;/em&gt; arbitrary IO actions, as well. A lot of resource managers and DSL’s offer the ability to sequence IO in the middle of all the other actions.&lt;/p&gt;
&lt;p&gt;That’s what &lt;code&gt;MonadIO&lt;/code&gt; is for — it allows you to write functions and say, “hey, my function is generic over &lt;em&gt;all&lt;/em&gt; things that can embed IO…anything that can embed IO can sequence my function/type”. The generic “embedding” action is &lt;code&gt;liftIO :: MonadIO m =&amp;gt; IO a -&amp;gt; m a&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You know…ideally, all of these typeclasses would have laws, so we could make conclusions and apply equational reasoning to generically written functions.&lt;/p&gt;
&lt;p&gt;Some of the laws are simple…&lt;code&gt;liftIO&lt;/code&gt; from &lt;code&gt;MonadIO&lt;/code&gt; should be a &lt;a href=&quot;http://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html&quot;&gt;monad morphism&lt;/a&gt;. But the rest of them don’t really have any well-established laws. This is a bit of a shame, because we’d really like to be able to apply reasoning to generic functions.&lt;/p&gt;
&lt;p&gt;People have suggested &lt;code&gt;MonadState&lt;/code&gt; have laws similar to how view/set/over interact in the &lt;em&gt;lens&lt;/em&gt; laws. But as of now, most of we have in terms of our capability of analyzing generic programs is rough heuristins/feelings about what “should” be right.&lt;/p&gt;
&lt;p&gt;A bit un-ideal, but…in practice, this ends up working not-so-badly :)&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;not-a-monad-transformer-library&quot;&gt;Not a Monad Transformer Library&lt;/h2&gt;
&lt;p&gt;So, let’s work together to dispel the myth that &lt;em&gt;mtl&lt;/em&gt; is a monad transformer library. It really has nothing to do with monad transformers at all…any more than &lt;code&gt;Control.Monad&lt;/code&gt; is an “IO module”, or &lt;code&gt;Control.Monoid&lt;/code&gt; is a “list module”. Transformers don’t even come from the &lt;em&gt;mtl&lt;/em&gt; library!&lt;/p&gt;
&lt;p&gt;Together, we can overcome this myth. We can show people that we can live in a world where we can combine effects, work generically in Monads with &lt;em&gt;multiple types of effects&lt;/em&gt; by writing functions generic over many different &lt;em&gt;mtl&lt;/em&gt; typeclasses at once! (&lt;code&gt;MonadState&lt;/code&gt; + &lt;code&gt;MonadIO&lt;/code&gt;, maybe?)&lt;/p&gt;
&lt;p&gt;We don’t &lt;em&gt;have to&lt;/em&gt; reach for Monad transformers to work with combined effects. We can write our own combined effects monads and just write the instances…or we can write generically and not even care about what Monad we actually use in the end. We don’t have to teach people to be afraid of monad transformers as if they were the only way to get things done, and &lt;em&gt;mtl&lt;/em&gt; is tied to them like a ball and chain.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;mtl&lt;/em&gt; is not a Monad transformer library. How liberating!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">http://blog.jle.im/entry/mtl-is-not-a-monad-transformer-library.html</guid><pubDate>Mon, 18 May 2015 17:07:36 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings</dc:subject><dc:date>2015-05-18</dc:date></item><item><title>Auto: A Todo GUI application with Auto (on GHCJS, etc.)</title><link>http://blog.jle.im/entry/auto-a-todo-gui-application-with-auto-on.html</link><description>&lt;p&gt;Continuing along with &lt;a href=&quot;http://blog.jle.im/entries/series/+all-about-auto&quot;&gt;All About Auto&lt;/a&gt;, let’s look at another exciting and useful application of the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/auto&quot;&gt;auto&lt;/a&gt;&lt;/em&gt; library: GUI’s. We’re going to look at the canonical “hello world” of GUI apps these days — the todo app. We’re going to be using the specs of &lt;a href=&quot;http://todomvc.com/&quot;&gt;todoMVC&lt;/a&gt; to build a todoMVC “candidate” that follows the specs…and along the way see what &lt;em&gt;auto&lt;/em&gt; offers in its tools of managing isolated state components and modeling GUI logic. We’re really going to be focusing on application logic — “control” and “model” — and not looking too close on “views”, which &lt;em&gt;auto&lt;/em&gt; doesn’t quite try to offer and where you can really pick your own view rendering system, making this adaptable to really any platform — javascript/web, desktop, command line, etc.&lt;/p&gt;
&lt;p&gt;A live version of our end-product &lt;a href=&quot;https://mstksg.github.com/auto-examples/todo&quot;&gt;is hosted and online&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This post does assume &lt;em&gt;some&lt;/em&gt; concepts from the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;tutorial&lt;/a&gt;…if not all, then at least those in the &lt;a href=&quot;http://blog.jle.im/entry/introducing-the-auto-library&quot;&gt;introductory post&lt;/a&gt; or the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/README.md&quot;&gt;README&lt;/a&gt;. If you ever find yourself thinking that these concepts are completely new and crazy, you might want to try looking through the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;tutorial&lt;/a&gt; or &lt;a href=&quot;http://hackage.haskell.org/package/auto&quot;&gt;docs&lt;/a&gt; to refresh your mind. As always, comments are welcome, and I’m also usually on &lt;em&gt;#haskell-auto&lt;/em&gt; as &lt;em&gt;jle`&lt;/em&gt;, and also on &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;twitter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(Fair warning…this is not quite a “ghcjs tutorial”, if that’s what you’re looking for; it’s an auto tutorial that uses some rudimentary ghcjs. Hopefully you can learn from that too!)&lt;/p&gt;
&lt;h2 id=&quot;overall-layout&quot;&gt;Overall Layout&lt;/h2&gt;
&lt;p&gt;At the highest level, &lt;em&gt;auto&lt;/em&gt; is a library that provides us tools to build and work with stream transformers on streams of values. Transform a stream of input values to a stream of output values. So, let’s try to phrase our Todo app problem in that perspective. What are our inputs, and what are our outputs?&lt;/p&gt;
&lt;p&gt;For a Todo app, the outputs are probably going to be a &lt;em&gt;todo list&lt;/em&gt; itself. If we’re building a GUI, then having the todo list itself is going to be enough to build our front-end display. The stream of &lt;em&gt;inputs&lt;/em&gt; is a little less obvious, but, well, what does an app really take as inputs? Commands! Our stream of inputs will be commands sent by a GUI or by whatever front-end we choose. Our todo app then is a transformer of a stream of commands to a stream of todo lists…where the todo list we get changes as we process more commands.&lt;/p&gt;
&lt;p&gt;So the “overall loop” will be:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;A front-end rendered by &lt;em&gt;ghcjs-dom&lt;/em&gt; (or whatever) with event handlers that drop commands into a concurrent &lt;code&gt;Chan&lt;/code&gt; queue. This just handles rendering.&lt;/li&gt;
&lt;li&gt;Our &lt;code&gt;Auto&lt;/code&gt; launched with &lt;code&gt;runOnChan&lt;/code&gt;, which waits on the &lt;code&gt;Chan&lt;/code&gt; queue, runs the inputs through the &lt;code&gt;Auto&lt;/code&gt;, and renders the result. This handles all of the logic.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We like types in Haskell, so let’s begin by laying out our types!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs#L19-46&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto.Collection&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad.Fix&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.IntMap&lt;/span&gt;             (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Serialize&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;GHC.Generics&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Prelude&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;hiding&lt;/span&gt;          ((.), id)
&lt;span class=&quot;kw&quot;&gt;import qualified&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Data.IntMap&lt;/span&gt;   &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IM&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IAdd&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- new task with description&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ITask&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskID&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- send command to task by ID&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IAll&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- send command to all tasks&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CDelete&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;-- delete&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CPrune&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- delete if completed&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CComplete&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- set completed status&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CModify&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- modify description&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CNop&lt;/span&gt;             &lt;span class=&quot;co&quot;&gt;-- do nothing&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; taskDescr     ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
                 ,&lt;span class=&quot;ot&quot;&gt; taskCompleted ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
                 } &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Generic&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Serialize&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- from Data.Serialize, from the cereal library&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We have a type to represent our inputs, &lt;code&gt;TodoInp&lt;/code&gt;, which can be an “add” command with a &lt;code&gt;String&lt;/code&gt;, a “task” command with a &lt;code&gt;TaskId&lt;/code&gt; (&lt;code&gt;Int&lt;/code&gt;) and a &lt;code&gt;TaskCmd&lt;/code&gt;, and an “all” command with a &lt;code&gt;TaskCmd&lt;/code&gt; that is supposed to represent sending that command to all tasks.&lt;/p&gt;
&lt;p&gt;Our &lt;code&gt;TaskCmd&lt;/code&gt; represents commands we can send to individual tasks – we can delete, prune (delete if completed), set the “completed” flag, or modify the description.&lt;/p&gt;
&lt;p&gt;We’re going to represent our task list, &lt;code&gt;TaskMap&lt;/code&gt;, as not a &lt;code&gt;[]&lt;/code&gt; list, but as an &lt;code&gt;IntMap&lt;/code&gt; from &lt;em&gt;containers&lt;/em&gt;, which associates an &lt;code&gt;Int&lt;/code&gt; to a &lt;code&gt;Task&lt;/code&gt; that we can look up with the &lt;code&gt;IntMap&lt;/code&gt; API. What would a &lt;code&gt;TaskMap&lt;/code&gt; store other than a bunch of &lt;code&gt;Task&lt;/code&gt;s, which we are defining as jus a tupling of a &lt;code&gt;String&lt;/code&gt; description and a &lt;code&gt;Bool&lt;/code&gt; completed/uncompleted status.&lt;/p&gt;
&lt;h2 id=&quot;the-todo-auto&quot;&gt;The Todo Auto&lt;/h2&gt;
&lt;p&gt;Time to go over the logic portion! The part that &lt;em&gt;auto&lt;/em&gt; is meant for! We’re going to structure the logic of our app (also known as the “model”) by using principles of local statefulness to avoid ever working with a “global state”, and working in a declarative, high-level manner.&lt;/p&gt;
&lt;h3 id=&quot;tasks&quot;&gt;Tasks&lt;/h3&gt;
&lt;p&gt;It’s clear that the core of our entire thing is going to be the “task list” construct itself…something that can dynamically add or remove tasks.&lt;/p&gt;
&lt;p&gt;In &lt;em&gt;auto&lt;/em&gt;, there is a construct created just for this kind of situation: dynamic collections indexed by a key (a “task id”), where you can add or subtract &lt;code&gt;Auto&lt;/code&gt;s from dynamically — they are &lt;code&gt;dynMap&lt;/code&gt; and &lt;code&gt;dynMapF&lt;/code&gt; from &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/auto/docs/Control-Auto-Collection.html&quot;&gt;Control.Auto.Collection&lt;/a&gt;&lt;/em&gt;. We’ll be using &lt;code&gt;dynMapF&lt;/code&gt; because it’s serializable, and we don’t need the extra power that &lt;code&gt;dynMap&lt;/code&gt; offers.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;dynMapF ::&lt;/span&gt; (k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Interval&lt;/span&gt; m a b)    &lt;span class=&quot;co&quot;&gt;-- ^ function to initialize new `Auto`s&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a                        &lt;span class=&quot;co&quot;&gt;-- ^ default inputs&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m ( &lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; a        &lt;span class=&quot;co&quot;&gt;-- ^ input for each internal `Auto`, indexed by key&lt;/span&gt;
                  , &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [k]        &lt;span class=&quot;co&quot;&gt;-- ^ blip stream to initialize new `Auto`s&lt;/span&gt;
                  )
                  (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; b)        &lt;span class=&quot;co&quot;&gt;-- ^ `Auto` outputs, by key&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;dynMapF&lt;/code&gt; keeps a “dynamic collection” of &lt;code&gt;Interval m a b&lt;/code&gt;s, indexed by an &lt;code&gt;Int&lt;/code&gt; key, or an “ID”. It takes as input a stream of &lt;code&gt;IntMap a&lt;/code&gt;…basically a bunch of &lt;code&gt;(Int, a)&lt;/code&gt; pairs. &lt;code&gt;dynMapF&lt;/code&gt; routes each input to the &lt;code&gt;Interval&lt;/code&gt; at that ID/address (with a suitable “default” &lt;code&gt;a&lt;/code&gt; if none was sent in), and then outputs all of the results as an &lt;code&gt;IntMap b&lt;/code&gt; — a bunch of &lt;code&gt;(Int, b)&lt;/code&gt; pairs, each output with the address of the &lt;code&gt;Auto&lt;/code&gt; that made it.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;IM.singleton 5 True&lt;/code&gt; would send &lt;code&gt;True&lt;/code&gt; to the &lt;code&gt;Auto&lt;/code&gt; stored at &lt;code&gt;5&lt;/code&gt;. It’ll then output something that includes &lt;code&gt;(5, &amp;quot;received True!&amp;quot;)&lt;/code&gt; — the output of the &lt;code&gt;Auto&lt;/code&gt; at slot 5.&lt;/p&gt;
&lt;p&gt;Whenever an &lt;code&gt;Interval&lt;/code&gt; turns “off” (is &lt;code&gt;Nothing&lt;/code&gt;), it is removed from the collection. In this way we can have &lt;code&gt;Auto&lt;/code&gt;s “remove themselves”.&lt;/p&gt;
&lt;p&gt;It also takes as input a blip stream of &lt;code&gt;[k]&lt;/code&gt;s. We use each emitted &lt;code&gt;k&lt;/code&gt; to “initialize a new &lt;code&gt;Interval&lt;/code&gt;” and throw it into the collection, creating a new unique key for it. Every time a new &lt;code&gt;Auto&lt;/code&gt; is initialized, &lt;code&gt;dynMapF&lt;/code&gt; creates a new key for it.&lt;/p&gt;
&lt;p&gt;Read over the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md#semantic-tools&quot;&gt;tutorial section on blip streams and &lt;code&gt;Interval&lt;/code&gt;s&lt;/a&gt; if you are still unfamiliar with them.&lt;/p&gt;
&lt;p&gt;This pretty much fits exactly what we want for our task collection. If we imagined that we had our &lt;code&gt;Task&lt;/code&gt; as an &lt;code&gt;Auto&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;initTask ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Interval&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;initTask&lt;/code&gt; takes a string (a starting description) and initializes an &lt;code&gt;Interval&lt;/code&gt; that takes in a stream of task commands, and has a stream of new, updated &lt;code&gt;Task&lt;/code&gt;s as its output stream. At every step, it processes the command and outputs the new appropriate &lt;code&gt;Task&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can then use this as our “initializer” for &lt;code&gt;dynMapF&lt;/code&gt;…and now we have a dynamic collection of tasks!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs#L48-50&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;taskCollection ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m
               &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;]) (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;)
taskCollection &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dynMapF initTask &lt;span class=&quot;dt&quot;&gt;CNop&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we wanted to send in the command &lt;code&gt;CModify &amp;quot;hey!&amp;quot;&lt;/code&gt; to the task whose id/key/address is &lt;code&gt;12&lt;/code&gt;, I’d feed in &lt;code&gt;IM.singleton 12 (CModify &amp;quot;hey!&amp;quot;)&lt;/code&gt;. The output would then contain the output of feeding that &lt;code&gt;CModify&lt;/code&gt; to the &lt;code&gt;Auto&lt;/code&gt; at that slot 12, associated with slot 12 on the output &lt;code&gt;IntMap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Writing &lt;code&gt;initTask&lt;/code&gt; and the task &lt;code&gt;Auto&lt;/code&gt; is straightforward with &lt;code&gt;accum&lt;/code&gt;, which is basically like &lt;code&gt;foldl&lt;/code&gt; on the inputs and a “current state”. (The current state is of course the &lt;code&gt;Task&lt;/code&gt;).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs#L52-62&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;initTask ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Interval&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;
initTask descr &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; accum f (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; descr &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;))
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    f (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t) tc &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; tc &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                      &lt;span class=&quot;dt&quot;&gt;CDelete&lt;/span&gt;                  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
                      &lt;span class=&quot;dt&quot;&gt;CPrune&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; taskCompleted t &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
                             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t
                      &lt;span class=&quot;dt&quot;&gt;CComplete&lt;/span&gt; s              &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t { taskCompleted &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; s }
                      &lt;span class=&quot;dt&quot;&gt;CModify&lt;/span&gt; descr            &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t { taskDescr &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; descr }
                      &lt;span class=&quot;dt&quot;&gt;CNop&lt;/span&gt;                     &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t
    f &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; _   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;See that our &lt;code&gt;Auto&lt;/code&gt; “turns off” by outputting &lt;code&gt;Nothing&lt;/code&gt;. That’s interval semantics, and it’s what &lt;code&gt;dynMapF&lt;/code&gt; relies on for its internal &lt;code&gt;Auto&lt;/code&gt;s!&lt;/p&gt;
&lt;h3 id=&quot;routing-the-inputs&quot;&gt;Routing the inputs&lt;/h3&gt;
&lt;p&gt;The only thing left, then, is just to route our input stream to send everything to the correct &lt;code&gt;Auto&lt;/code&gt; in &lt;code&gt;taskCollection&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Our input stream is going to be a stream of &lt;code&gt;TodoInp&lt;/code&gt;, which can be “add”, “send command to a single task”, or “send command to all tasks”. Really, though, you can think of it three separate streams all “jammed” into one stream.&lt;/p&gt;
&lt;p&gt;This is a common pattern that we can use &lt;em&gt;blip streams&lt;/em&gt; for. Instead of working with one big fatty stream, we can work with several blip streams that only emit when the input that we care about comes in.&lt;/p&gt;
&lt;p&gt;Typically, we’d do this with &lt;code&gt;emitJusts&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;emitJusts ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can imagine &lt;code&gt;emitJusts&lt;/code&gt; is a “siphon” off of the input stream of &lt;code&gt;a&lt;/code&gt;s…and pulling out only the values that we care about, as a blip stream of &lt;code&gt;b&lt;/code&gt;’s.&lt;/p&gt;
&lt;p&gt;We can build our “siphoners”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs#L95-105&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;getAddEvts ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;]
getAddEvts (&lt;span class=&quot;dt&quot;&gt;IAdd&lt;/span&gt; descr) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; [descr]
getAddEvts _            &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;getModEvts ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;)
getModEvts (&lt;span class=&quot;dt&quot;&gt;ITask&lt;/span&gt; n te) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; IM.singleton n te
getModEvts _            &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;getMassEvts ::&lt;/span&gt; ([&lt;span class=&quot;dt&quot;&gt;TaskID&lt;/span&gt;], &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;)
getMassEvts (allIds, &lt;span class=&quot;dt&quot;&gt;IAll&lt;/span&gt; te) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; IM.fromList (map (,te) allIds)
getMassEvts _                 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;getAddEvts&lt;/code&gt;, when used with &lt;code&gt;emitJusts&lt;/code&gt;, will siphon off all &lt;code&gt;IAdd&lt;/code&gt; commands as a blip stream of &lt;code&gt;[String]&lt;/code&gt;s, emitting descriptions of new tasks to add.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getModEvts&lt;/code&gt;, when used with &lt;code&gt;emitJusts&lt;/code&gt;, will siphon off all &lt;code&gt;ITask&lt;/code&gt; commands as a blip stream of &lt;code&gt;IntMap TaskCmd&lt;/code&gt;, which will be fed into &lt;code&gt;taskCollection&lt;/code&gt; and &lt;code&gt;dynMapF&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getMassEvts&lt;/code&gt; is pretty much the same thing…siphoning off all &lt;code&gt;IAll&lt;/code&gt; commands as a blip stream of &lt;code&gt;IntMap TaskCmd&lt;/code&gt;. It needs a list of all &lt;code&gt;TaskID&lt;/code&gt;s though, to do its job…because it needs to make an &lt;code&gt;IntMap&lt;/code&gt; targeting all of the current tasks.&lt;/p&gt;
&lt;p&gt;Remember, we interace with tasks through an &lt;code&gt;IntMap TaskCmd&lt;/code&gt;…which is a map of task id-task command pairs. The &lt;code&gt;TaskCmd&lt;/code&gt; stored at key &lt;code&gt;1&lt;/code&gt; will be the command we want to send to task id 1.&lt;/p&gt;
&lt;p&gt;Let’s see it all work together!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs#L64-93&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;todoApp ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadFix&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;)
todoApp &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc inpEvt &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;

    rec &lt;span class=&quot;co&quot;&gt;-- all id&amp;#39;s currently alive&lt;/span&gt;
        allIds &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; arrD IM.keys [] &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; taskMap

        &lt;span class=&quot;co&quot;&gt;-- &amp;quot;forking&amp;quot; `inpEvt` into three blip streams:&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- newTaskB :: Blip [String]&lt;/span&gt;
        newTaskB  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; emitJusts getAddEvts  &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inpEvt
        &lt;span class=&quot;co&quot;&gt;-- modTaskB :: Blip (IntMap TaskCmd)&lt;/span&gt;
        modTaskB  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; emitJusts getModEvts  &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inpEvt
        &lt;span class=&quot;co&quot;&gt;-- massTaskB :: Blip (IntMap TaskCmd)&lt;/span&gt;
        massTaskB &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; emitJusts getMassEvts &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (allIds, inpEvt)

        &lt;span class=&quot;co&quot;&gt;-- merge the two streams together to get &amp;quot;all&amp;quot; inputs, single and&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- mass.&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; allInpB ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;)
            allInpB &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; modTaskB &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; massTaskB

        &lt;span class=&quot;co&quot;&gt;-- from a blip stream to an `IntMap` stream that is empty when the&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- stream doesn&amp;#39;t emit&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- taskCommands :: IntMap TaskCmd&lt;/span&gt;
        taskCommands &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; fromBlips IM.empty &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; allInpB

        &lt;span class=&quot;co&quot;&gt;-- feed the commands and the new tasks to `taskMap`...the result is&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- the `IntMap` of tasks.&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- taskMap :: IntMap Task&lt;/span&gt;
        taskMap &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; taskCollection &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (taskCommands, newTaskB)

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; taskMap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To read the proc block, it does help to sort of see all of the lines as english statements of what things “are”.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;allIds&lt;/code&gt; is a list of keys (id’s) currently in the task map &lt;code&gt;taskMap&lt;/code&gt;. All of the id’s of the tasks currently alive.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now, we fork into blip streams:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;newTaskB&lt;/code&gt; is a blip stream that emits with task descriptions whenever &lt;code&gt;inpEvt&lt;/code&gt; calls for one.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modTaskB&lt;/code&gt; is a blip stream that emits with a command to a specific task whenever &lt;code&gt;inpEvt&lt;/code&gt; calls for one.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;massTaskB&lt;/code&gt; is a blip stream that emits commands to every single task in &lt;code&gt;allIds&lt;/code&gt; whenever &lt;code&gt;inpEvt&lt;/code&gt; calls for it.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;allInpB&lt;/code&gt; is a blip stream with addressed commands whenever either &lt;code&gt;modTaskB&lt;/code&gt; or &lt;code&gt;massTaskB&lt;/code&gt; emits.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;taskCommands&lt;/code&gt; is a map of addressed commands for each task. It’s whatever &lt;code&gt;allInpB&lt;/code&gt; emits, when it does emit…or just &lt;code&gt;IM.empty&lt;/code&gt; (an empty map) when it doesn’t.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;taskMap&lt;/code&gt; is the map of tasks that we get from our &lt;code&gt;taskCollection&lt;/code&gt; updater, which manages a collection of tasks. &lt;code&gt;taskCollection&lt;/code&gt; needs the commands for each task and the new tasks we want to do its job.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We state things as an interplay of streams. And in the end, the result is what we want — an indexed list of tasks.&lt;/p&gt;
&lt;p&gt;Note that we needed the &lt;code&gt;rec&lt;/code&gt; block because we referred to &lt;code&gt;taskMap&lt;/code&gt; at the beginning (to get &lt;code&gt;allIds&lt;/code&gt;), but we don’t define &lt;code&gt;taskMap&lt;/code&gt; until the end.&lt;/p&gt;
&lt;p&gt;Note that we use &lt;code&gt;arrD&lt;/code&gt; for &lt;code&gt;allIds&lt;/code&gt;. What we really “meant” was something like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;allIds &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; arr IM.keys &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; taskMap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But…this doesn’t really work out, because when the whole thing “starts”, we don’t know what &lt;code&gt;taskMap&lt;/code&gt; is. We need to know &lt;code&gt;massTaskB&lt;/code&gt; to know &lt;code&gt;taskMap&lt;/code&gt;, and we need to know &lt;code&gt;allIds&lt;/code&gt; to know &lt;code&gt;massTaskB&lt;/code&gt;, and…recursive dependency!&lt;/p&gt;
&lt;p&gt;We can use &lt;code&gt;arrD&lt;/code&gt; to specify an “initial output” to “close the loop” (in technical terms). We want &lt;code&gt;allIds&lt;/code&gt; to initially be &lt;code&gt;[]&lt;/code&gt; (we can assume we start with no task id’s), so instead of&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;allIds &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; arr IM.keys &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; taskMap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we have&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;allIds &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; arrD IM.keys [] &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; taskMap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where &lt;code&gt;[]&lt;/code&gt; is the “initial output”, so when we first try to do anything, we don’t need &lt;code&gt;taskMap&lt;/code&gt; — we just pop out &lt;code&gt;[]&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;This is just a small thing to worry about whenever you have recursive bindings. There is a small cognitive price to pay, but in return, you have something that really just looks like laying out relationships between different quantities :)&lt;/p&gt;
&lt;h2 id=&quot;interfacing-with-the-world&quot;&gt;Interfacing with the world&lt;/h2&gt;
&lt;p&gt;Our application logic is done; let’s explore ways to interface with it!&lt;/p&gt;
&lt;h3 id=&quot;testingcommand-line&quot;&gt;Testing/command line&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/todo-cmd.hs#L25-62&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;parseInp ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt;
parseInp &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; p &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs)   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IAdd&lt;/span&gt; (unwords xs))
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;D&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onId n &lt;span class=&quot;dt&quot;&gt;CDelete&lt;/span&gt;
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onId n (&lt;span class=&quot;dt&quot;&gt;CComplete&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;)
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;U&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onId n (&lt;span class=&quot;dt&quot;&gt;CComplete&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;)
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;P&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onId n &lt;span class=&quot;dt&quot;&gt;CPrune&lt;/span&gt;
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;M&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onId n (&lt;span class=&quot;dt&quot;&gt;CModify&lt;/span&gt; (unwords xs))
    p _          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;    onId ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt;
    onId &lt;span class=&quot;st&quot;&gt;&amp;quot;*&amp;quot;&lt;/span&gt; te &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IAll&lt;/span&gt; te)
    onId n   te &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;`ITask`&lt;/span&gt; te) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; readMaybe n

&lt;span class=&quot;ot&quot;&gt;formatTodo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
formatTodo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; unlines &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; map format &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; IM.toList
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    format (n, &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; desc compl) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; concat [ show n
                                         , &lt;span class=&quot;st&quot;&gt;&amp;quot;. [&amp;quot;&lt;/span&gt;
                                         , &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; compl &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;X&amp;quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt;
                                         , &lt;span class=&quot;st&quot;&gt;&amp;quot;] &amp;quot;&lt;/span&gt;
                                         , desc
                                         ]

&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;Enter command! &amp;#39;A descr&amp;#39; or &amp;#39;[D/C/U/P/M] [id/*]&amp;#39;&amp;quot;&lt;/span&gt;
    void &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; interactAuto &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- interactAuto takes an Interval; `toOn` gives&lt;/span&gt;
                          &lt;span class=&quot;co&quot;&gt;--   one that runs forever&lt;/span&gt;
                          toOn
                          &lt;span class=&quot;co&quot;&gt;-- default output value on bad command&lt;/span&gt;
                        &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromBlips &lt;span class=&quot;st&quot;&gt;&amp;quot;Bad command!&amp;quot;&lt;/span&gt;
                          &lt;span class=&quot;co&quot;&gt;-- run `formatTodo &amp;lt;$&amp;gt; todoApp` on emitted commands&lt;/span&gt;
                        &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; perBlip (formatTodo &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; todoApp)
                          &lt;span class=&quot;co&quot;&gt;-- emit when input is parseable&lt;/span&gt;
                        &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts parseInp&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;interactAuto&lt;/code&gt; runs an &lt;code&gt;Interval&lt;/code&gt; by feeding it in strings from stdin printing the output to stdout, until the output is “off”/&lt;code&gt;Nothing&lt;/code&gt; — then stops. Here we use &lt;code&gt;parseInp&lt;/code&gt; to emit input events whenever there is a parse, run &lt;code&gt;todoApp&lt;/code&gt; (formatted) on the emitted events, and then condense it all with &lt;code&gt;fromBlips&lt;/code&gt; and wrap it in an “always on” &lt;code&gt;toOn&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cabal sandbox init
$ cabal install auto
$ cabal exec runghc todo-cmd.hs
Enter command! &amp;#39;A descr&amp;#39; or &amp;#39;[D/C/U/P/M] [id/*]&amp;#39;
&amp;gt; A take out the trash
0. [ ] take out the trash

&amp;gt; A do the dishes
0. [ ] take out the trash
1. [ ] do the dishes

&amp;gt; C 1
0. [ ] take out the trash
1. [X] do the dishes

&amp;gt; U 1
0. [ ] take out the trash
1. [ ] do the dishes

&amp;gt; C 0
0. [X] take out the trash
1. [ ] do the dishes

&amp;gt; P *
1. [ ] do the dishes&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/auto/todo-cmd.hs&quot;&gt;download and run this yourself&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;Looks like the logic works! Time to take it to GUI!&lt;/p&gt;
&lt;h3 id=&quot;as-a-gui&quot;&gt;As a GUI&lt;/h3&gt;
&lt;p&gt;To build a GUI, we must build an &lt;code&gt;Auto&lt;/code&gt; that takes in inputs from events and output everything the front-end renderer needs to render the interface.&lt;/p&gt;
&lt;p&gt;For a typical todomvc gui, we need to be able to filter and select things. So that means we need to be extend our input type with filtering and selecting events. And our output has to also indicate the current filter selected, and the current task selected, as well.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIOpts&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUI&lt;/span&gt; { _&lt;span class=&quot;ot&quot;&gt;currFilter   ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Filter&lt;/span&gt;        &lt;span class=&quot;co&quot;&gt;-- currently applied filter&lt;/span&gt;
                   , _&lt;span class=&quot;ot&quot;&gt;currSelected ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskID&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;-- currently selected task&lt;/span&gt;
                   }

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GIFilter&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Filter&lt;/span&gt;
            &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GISelect&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskID&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Filter&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;All&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Active&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Completed&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Generic&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Enum&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Serialize&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Filter&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Instead of defining a new input mega-type with all input events and the todo map with the options, we can use good ol’ fashioned &lt;code&gt;Either&lt;/code&gt; and &lt;code&gt;(,)&lt;/code&gt;. So now, instead of:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;todoApp ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We have:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;todoAppGUI ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;GUIOpts&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we take &lt;em&gt;either&lt;/em&gt; &lt;code&gt;TodoInp&lt;/code&gt; or &lt;code&gt;GUIInp&lt;/code&gt; and then return &lt;em&gt;both&lt;/em&gt; &lt;code&gt;IntMap Task&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;GUIOpts&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;todoAppGUI ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&amp;#39;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;GUIOpts&lt;/span&gt;)
todoAppGUI &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc inp &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    filt  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith &lt;span class=&quot;dt&quot;&gt;All&lt;/span&gt;                      &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts filtInps &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp
    selc  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;                  &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts selcInps &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp
    tasks &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith mempty &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; perBlip todoApp &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts todoInps &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (tasks, &lt;span class=&quot;dt&quot;&gt;GUI&lt;/span&gt; filt selc)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    todoInps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt;
    todoInps (&lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; ti) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; ti
    todoInps _         &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    filtInps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Filter&lt;/span&gt;
    filtInps (&lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;GIFilter&lt;/span&gt; filt)) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; filt
    filtInps _                       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    selcInps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskID&lt;/span&gt;)
    selcInps (&lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;GISelect&lt;/span&gt; sec))  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; selc
    selcInps _                       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we have the same idea as before. One input stream of &lt;code&gt;Either TodoInp GUIInp&lt;/code&gt; comes through, and we fork it into three blip streams that each do what we want. &lt;code&gt;holdWith x :: Auto m (Blip b) b&lt;/code&gt; is always the value of the last emitted item…but starts off as &lt;code&gt;x&lt;/code&gt; first.&lt;/p&gt;
&lt;p&gt;By the way, the above code is much more succinct if you are willing to use &lt;em&gt;&lt;a href=&quot;http://lens.github.com&quot;&gt;lens&lt;/a&gt;&lt;/em&gt;…&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;todoAppGUI ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&amp;#39;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;GUIOpts&lt;/span&gt;)
todoAppGUI &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc inp &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    filt  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith &lt;span class=&quot;dt&quot;&gt;All&lt;/span&gt;
           &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts (preview (_&lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; _&lt;span class=&quot;dt&quot;&gt;GIFilter&lt;/span&gt;)) &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp
    selc  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
           &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts (preview (_&lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; _&lt;span class=&quot;dt&quot;&gt;GISelect&lt;/span&gt;)) &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp
    tasks &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith mempty &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; perBlip todoApp
           &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts (preview _&lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt;)                &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (tasks, &lt;span class=&quot;dt&quot;&gt;GUI&lt;/span&gt; filt selc)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(assuming we defined the prisms for &lt;code&gt;GUIInp&lt;/code&gt; or used &lt;code&gt;&#39;&#39;mkPrisms&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;Neat, right? In a way, you can say that &lt;code&gt;emitJusts&lt;/code&gt; and &lt;code&gt;Prisms&lt;/code&gt;/lens was a match made in heaven :)&lt;/p&gt;
&lt;h3 id=&quot;giving-it-life&quot;&gt;Giving it life&lt;/h3&gt;
&lt;p&gt;The last step is to hook everything up together —&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Setting up events in our GUI to feed inputs to a queue&lt;/li&gt;
&lt;li&gt;Setting up the queue to wait on inputs, and output the task map/gui status on every one using &lt;code&gt;todoAppGUI&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Rendering the output into the GUI framework of your choice&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The second step in particular can be handled with good ol’ &lt;code&gt;[runOnChan][]&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;runOnChan ::&lt;/span&gt; (b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&amp;#39;&lt;/span&gt; a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Auto&amp;#39;&lt;/span&gt; a b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We know and love &lt;code&gt;runOnChan&lt;/code&gt; from when we used it to make our &lt;a href=&quot;http://blog.jle.im/entry/auto-building-a-declarative-chatbot-with-implicit-serialization#irc-backend-the-ugly-part&quot;&gt;chatbot&lt;/a&gt;. It runs an &lt;code&gt;Auto&#39; a b&lt;/code&gt; “on a &lt;code&gt;Chan&lt;/code&gt;” (concurrent queue). The first argument is an “output hander” — it handles the &lt;code&gt;b&lt;/code&gt;s that the &lt;code&gt;Auto&#39;&lt;/code&gt; pops out. It decides whether to stop the whole thing or keep on listening based on the &lt;code&gt;Bool&lt;/code&gt; result of the handler. The second argument is the &lt;code&gt;Chan a&lt;/code&gt; to listen for inputs on. Whenever something is dropped into that &lt;code&gt;Chan&lt;/code&gt;, it runs the &lt;code&gt;Auto&#39;&lt;/code&gt; with the &lt;code&gt;a&lt;/code&gt; and processes the output &lt;code&gt;b&lt;/code&gt; with the handler.&lt;/p&gt;
&lt;p&gt;Our final runner is then just:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;runOnChan renderGUI inputChan todoAppGUI&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;renderGUI ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;GUIOpts&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;inputChan ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The rendering is done with &lt;code&gt;renderGUI&lt;/code&gt;…and it really depends on your framework here. That’s #3 from the list above.&lt;/p&gt;
&lt;p&gt;All you need after that is just to have your GUI hook up event handlers to drop the appropriate &lt;code&gt;Either TodoInp GUIInp&lt;/code&gt; into &lt;code&gt;inputChan&lt;/code&gt;…and you’re golden!&lt;/p&gt;
&lt;h2 id=&quot;seeing-it-in-action&quot;&gt;Seeing it in action&lt;/h2&gt;
&lt;p&gt;We’ve reached the end of our tutorial — the parts about &lt;code&gt;auto&lt;/code&gt;. It is my hope that whatever GUI front-end you want to work with, it’ll be simple enough to “plug in” our &lt;code&gt;Auto&lt;/code&gt; logic.&lt;/p&gt;
&lt;p&gt;A &lt;a href=&quot;https://mstksg.github.com/auto-examples/todo&quot;&gt;live demo&lt;/a&gt; is online too; you can see &lt;a href=&quot;https://github.com/mstksg/auto-examples/blob/master/src/TodoJS.hs&quot;&gt;the source of the front-end bindings&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is a bare-bons &lt;em&gt;ghcjs&lt;/em&gt; implementation using &lt;em&gt;ghcjs-dom&lt;/em&gt;, which uses direct dom manipulation.&lt;/p&gt;
&lt;p&gt;User &lt;a href=&quot;https://github.com/eryx67&quot;&gt;eryx67&lt;/a&gt; has been kind enough to provide &lt;a href=&quot;https://github.com/eryx67/auto-examples/blob/master/src/TodoJS.hs&quot;&gt;an implementation in &lt;em&gt;ghcjs&lt;/em&gt;&lt;/a&gt; with the &lt;em&gt;&lt;a href=&quot;https://github.com/ocharles/virtual-dom&quot;&gt;virtual-dom&lt;/a&gt;&lt;/em&gt; library (&lt;a href=&quot;https://github.com/mstksg/auto-examples/commit/246133a89fbca6a2ec7ea276d8536701f6ab8d2c?diff=split&quot;&gt;side-by-side comparison&lt;/a&gt;), so there is a slightly less uglier implementation with abstraction :)&lt;/p&gt;
&lt;p&gt;As always, feel free to ask questions in the comments, hop over to &lt;em&gt;#haskell-game&lt;/em&gt; or &lt;em&gt;#haskell-auto&lt;/em&gt; on freenode, or send me a &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;tweet&lt;/a&gt;! And look forward to more tutorials as the &lt;a href=&quot;http://blog.jle.im/entries/series/+all-about-auto&quot;&gt;All About Auto&lt;/a&gt; series progresses!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Auto</category><category>Tutorials</category><guid isPermaLink="true">http://blog.jle.im/entry/auto-a-todo-gui-application-with-auto-on.html</guid><pubDate>Thu, 23 Apr 2015 17:04:10 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Auto, Tutorials</dc:subject><dc:date>2015-04-23</dc:date></item><item><title>Unique sample drawing &amp; searches with List and StateT — “Send more
money”</title><link>http://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.html</link><description>&lt;p&gt;Nothing too crazy today, just a cute (basic/intermediate) haskell trick as a response to Mark Dominus’s excellent &lt;a href=&quot;http://blog.plover.com&quot;&gt;Universe of Discourse&lt;/a&gt; post on &lt;a href=&quot;http://blog.plover.com/prog/haskell/monad-search.html&quot;&gt;Easy exhaustive search with the list monad&lt;/a&gt; intended for people new or unfamiliar with haskell demonstrating the common “list monad as a constraint solver” approach that is standard fare for learning Haskell. I myself have literally done &lt;a href=&quot;http://blog.jle.im/entries/series/+monadplus-success-failure-monads&quot;&gt;an entire series of blog posts&lt;/a&gt; on this usage.&lt;/p&gt;
&lt;p&gt;Mark’s use case however incorporates a bit of an extra pattern not typically discussed. The list monad is good for taking “independent samples” of things (looking at different samples from a list):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         z &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         return [x,y,z]
[&lt;span class=&quot;st&quot;&gt;&amp;quot;aaa&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;aab&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;aac&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;aba&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;abb&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt; ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, what if you wanted to instead “draw” from a pool, and represent different drawings? Traditionally, the answer was something like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; filter (&lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; x) &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         z &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; filter (&lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; y) &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; filter (&lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; x) &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         return [x,y,z]
&lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;acb&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;bac&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;bca&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;cab&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;cba&amp;quot;&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a little bit awkward…and it definitely gets a lot worse (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chl=O%28n%5E2%29&quot; alt=&quot;O(n^2)&quot; title=&quot;O(n^2)&quot; /&gt;) when you have more items. Also, it relies on an &lt;code&gt;Eq&lt;/code&gt; constraint — what if our thing doesn’t have an &lt;code&gt;Eq&lt;/code&gt; instance? And this also falls apart when our list contains duplicate items. If we had used &lt;code&gt;&amp;quot;aabc&amp;quot;&lt;/code&gt; instead of &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;, the result would be the same — despite having more &lt;code&gt;&#39;a&#39;&lt;/code&gt;s to pick from!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important note:&lt;/strong&gt; After writing this article, I found out that Douglas Auclair in &lt;a href=&quot;https://wiki.haskell.org/wikiupload/6/6a/TMR-Issue11.pdf&quot;&gt;11th issue of the Monad Reader&lt;/a&gt; solved this exact same problem with pretty much the exact same approach. (Oops!) If you want to do further reading, check it out! :D&lt;/p&gt;
&lt;h2 id=&quot;statet&quot;&gt;StateT&lt;/h2&gt;
&lt;p&gt;There’s a type in the &lt;em&gt;transformers&lt;/em&gt; library that provides a very useful monad instance:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; s m a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; (s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (a, s))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;StateT s m a&lt;/code&gt; is a function that takes an initial state &lt;code&gt;s&lt;/code&gt; and returns a result &lt;code&gt;a&lt;/code&gt; with a modified state…in the context of &lt;code&gt;m&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Specialize for &lt;code&gt;m ~ []&lt;/code&gt; and we get&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; s [] a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; (s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [(a, s)])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is basically describing a function from a initial state to a list of &lt;em&gt;ways you can modify the state&lt;/em&gt;, and different results from each one. It returns a list of “all ways you can mutate this state”.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;foo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; [] &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
foo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [(even x, x&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), (odd x, x&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), (x &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, negate x)]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;foo&lt;/code&gt; takes a number, &lt;code&gt;x&lt;/code&gt;, and says, “here are three ways we might proceed from having this number. We can return whether or not it’s even, in which case the new state is &lt;code&gt;x+1&lt;/code&gt;…we can return whether or not it’s odd, in which case the new state is &lt;code&gt;x-1&lt;/code&gt;….or we can return whether or not it’s positive, in which case the new state is &lt;code&gt;negate x&lt;/code&gt;”&lt;/p&gt;
&lt;p&gt;What the monad instance does is that it allows you to “chain” forks, and go along different forks, and gather together “all possible forks” you could have taken. At the end, it outputs all possible forks. So if you did &lt;code&gt;foo &amp;gt;&amp;gt; foo&lt;/code&gt;, there’d be nine results — one result for when you took the first route (the &lt;code&gt;x+1&lt;/code&gt;) twice, one for when you took the first and then the second (&lt;code&gt;x-1&lt;/code&gt;), one for when you took the first and the third….and the second and the first…etc., etc.&lt;/p&gt;
&lt;h3 id=&quot;monadplus&quot;&gt;MonadPlus&lt;/h3&gt;
&lt;p&gt;One other tool we have at our disposal is &lt;code&gt;guard&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;guard ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; [] ()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is a &lt;code&gt;StateT&lt;/code&gt; action that says “kill this current branch if given &lt;code&gt;False&lt;/code&gt;, or go on if given &lt;code&gt;True&lt;/code&gt;”&lt;/p&gt;
&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;
&lt;p&gt;The problem, as stated, was to find distinct digits for each letter to solve:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    S E N D
+   M O R E
-----------
  M O N E Y&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So &lt;code&gt;SEND&lt;/code&gt; is a four-digit number, &lt;code&gt;MORE&lt;/code&gt; is a four-digit number, and &lt;code&gt;MONEY&lt;/code&gt; is a five-digit number that is the sum of the two. The first digit of &lt;code&gt;MONEY&lt;/code&gt; has to be the first digit of &lt;code&gt;MORE&lt;/code&gt;, the last digit of &lt;code&gt;MORE&lt;/code&gt; has to be the second digit of &lt;code&gt;SEND&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;The previous approach was done using the entire “pick from all possibilities…except for the ones already chosen”, using &lt;code&gt;(/=)&lt;/code&gt; and filtering over all of the things seen vs all of the things to pick from.&lt;/p&gt;
&lt;p&gt;However, we can abstract over “picking dependently from a sample” by defining a function called &lt;code&gt;select&lt;/code&gt;, which really should be in the base libraries but isn’t for some reason:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/send-more-money.hs#L7-9&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;select ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [(a, [a])]
select []     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; []
select (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (x,xs) &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; [(y,x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ys) &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; (y,ys) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; select xs]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Implementation thanks to Cale, who has fought valiantly yet fruitlessly to get this into base for many years.)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;select&lt;/code&gt; will take a list &lt;code&gt;[a]&lt;/code&gt; and return a list of different “selected” &lt;code&gt;a&lt;/code&gt;s, with the rest of the list, too:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; select &lt;span class=&quot;st&quot;&gt;&amp;quot;abcd&amp;quot;&lt;/span&gt;
[(&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;bcd&amp;quot;&lt;/span&gt;),(&lt;span class=&quot;ch&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;acd&amp;quot;&lt;/span&gt;),(&lt;span class=&quot;ch&quot;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;abd&amp;quot;&lt;/span&gt;),(&lt;span class=&quot;ch&quot;&gt;&amp;#39;d&amp;#39;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;)]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But, hey…does the type signature of &lt;code&gt;select&lt;/code&gt; look like anything familiar?&lt;/p&gt;
&lt;p&gt;It looks &lt;em&gt;exactly&lt;/em&gt; like something that &lt;code&gt;StateT&lt;/code&gt; is supposed to describe! Give an initial state (&lt;code&gt;[a]&lt;/code&gt;), and returns a list of all possible ways to “mutate” that state (by removing one element from the state), and a result from each mutation (the removed element).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; select ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; [a] [] a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And armed with this…we have all we need&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/send-more-money.hs#L3-35&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad&lt;/span&gt;             (guard, mfilter)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad.Trans.State&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.List&lt;/span&gt;                 (foldl&amp;#39;)

&lt;span class=&quot;ot&quot;&gt;asNumber ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
asNumber &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; foldl&amp;#39; (\t o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; t&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; o) &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; print &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; flip evalStateT [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    s &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    e &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    n &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    d &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    m &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    o &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    r &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; s &lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; m &lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; send  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [s,e,n,d]
        more  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [m,o,r,e]
        money &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [m,o,n,e,y]
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; send &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; more &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; money
    return (send, more, money)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember, &lt;code&gt;StateT&lt;/code&gt; here operates with an underlying state of &lt;code&gt;[Int]&lt;/code&gt;, a list of numbers not yet picked. &lt;code&gt;StateT select&lt;/code&gt; picks one of these numbers, and modifies the state to now only include the items that were not picked. So every time you sequence &lt;code&gt;StateT select&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt; draws from a smaller and smaller pool of numbers, and makes the state list smaller and smaller. What sequencing &lt;code&gt;StateT&lt;/code&gt; does is allow us to explore &lt;em&gt;all&lt;/em&gt; of the possible ways we could pick and modify state, all at once. Using &lt;code&gt;guard&lt;/code&gt;, we then “close off” and kill off the paths that don’t end up how we’d like.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;asNumber&lt;/code&gt; takes a list like &lt;code&gt;[1,2,3]&lt;/code&gt; and turns it into the number &lt;code&gt;123&lt;/code&gt;; credit to the source blog.&lt;/p&gt;
&lt;p&gt;And, to test it out…&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;ghc&lt;/span&gt; -O2 send-more-money.hs
$ &lt;span class=&quot;kw&quot;&gt;./send-more-money&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# [(9567,1085,10652)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It returns the one and only solution, &lt;code&gt;SEND = 9567&lt;/code&gt;, &lt;code&gt;MORE = 1085&lt;/code&gt;, and &lt;code&gt;MONEY = 10652&lt;/code&gt;.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We can make things a little bit more efficient with minimal cost in expressiveness. But not that it matters…the original version runs fast already.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/send-more-money.hs#L38-59&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;select&amp;#39; ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [(a,[a])]
select&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go []
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
   go xs [] &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; []
   go xs (y&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ys) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (y,xs&lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt;ys) &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; go (y&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) ys

&lt;span class=&quot;ot&quot;&gt;main&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; print &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; flip evalStateT [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    s &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; mfilter (&lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    m &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; mfilter (&lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    e &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    n &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    d &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    o &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    r &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; send  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [s,e,n,d]
        more  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [m,o,r,e]
        money &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [m,o,n,e,y]
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; send &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; more &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; money
    return (send, more, money)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a more performant version of &lt;code&gt;select&lt;/code&gt; &lt;a href=&quot;http://chimera.labs.oreilly.com/books/1230000000929/pr01.html&quot;&gt;courtesy of Simon Marlow&lt;/a&gt; that doesn’t preserve the order of the “rest of the elements”.&lt;/p&gt;
&lt;p&gt;Also, we use &lt;code&gt;mfilter&lt;/code&gt; to “eliminate bad &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt;s” right off the bat, before having to pick any more things. &lt;code&gt;mfilter&lt;/code&gt; can be thought of as “killing the fork immediately” if the action doesn’t satisfy the predicate. If the &lt;code&gt;s&lt;/code&gt; picked doesn’t match &lt;code&gt;(/= 0)&lt;/code&gt;, then the entire branch/fork is immediately ruled invalid.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;By the way, isn’t it neat that it does all of this in “constant space”? It just keeps track of the output list, but the actual search processes is in constant space. You don’t need to keep track of all &lt;code&gt;10!&lt;/code&gt; combinations in memory at once. Hooray laziness!&lt;/p&gt;
&lt;h2 id=&quot;other-applications&quot;&gt;Other Applications&lt;/h2&gt;
&lt;p&gt;Using &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;StateT&lt;/code&gt;, we can do a lot of things involving picking from a sample, or permutations. Anything that you used to awkwardly do by using filter not-equal-to’s can work now. You can do things like drawing from a deck:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;pokerGame ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Ordering&lt;/span&gt;]
pokerGame &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; flip evalStateT [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;51&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    p2Hand &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; replicateM &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select)
    p1Hand &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; replicateM &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select)
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; pokerCompare p1Hand p2Hand&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which would draw five distinct cards from a deck of &lt;code&gt;[0..51]&lt;/code&gt;, and return who won for each draw (assuming you had a suitable &lt;code&gt;pokerCompare :: [Card] -&amp;gt; [Card] -&amp;gt; Ordering&lt;/code&gt;). Note that if you use &lt;code&gt;runStateT&lt;/code&gt;, you’d get the results (the winner), &lt;em&gt;as well as&lt;/em&gt; the leftover cards in the deck for each path!&lt;/p&gt;
&lt;!-- I used to have an example here about simulating russian roulette --&gt;
&lt;!-- But this doesn&#39;t really work in a useful way...because the paths all &quot;stop&quot; --&gt;
&lt;!-- after the first shot.  In reality, you are just as likely to be shot on the --&gt;
&lt;!-- first pull as you are on the second.  But as this simulation runs, it &quot;stops&quot; --&gt;
&lt;!-- after the first shot...so `1` will only show up once. --&gt;
&lt;p&gt;You can even combine the two sorts of drawings — sampling independently (like rolling dice) using &lt;code&gt;lift&lt;/code&gt;, and drawing from an underlying deck. For example, you might encode some game logic from a board game like monopoly:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;combo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; flip evalStateT initialDeck &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    roll &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; lift [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;]
    draw &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Whenever you want a dice roll, use &lt;code&gt;lift [1..6]&lt;/code&gt;…and whenever you want to draw from the deck, use &lt;code&gt;StateT select&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What you get in the end, remember, is a list of “all possible paths”. You’ll get a list of every possible result from all of your different rolling and drawing choices.&lt;/p&gt;
&lt;p&gt;Happy Haskelling!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;For some reason this runs pretty slowly if you use &lt;code&gt;runghc&lt;/code&gt;/&lt;code&gt;runHaskell&lt;/code&gt;, but it runs in the blink of an eye when you actually compile it (and especially with optimizations on). The difference is pretty striking…and I don’t really know what’s going on here, to be honest. If anyone does know a good explanation, I’d love to hear it :)&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Tutorials</category><guid isPermaLink="true">http://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.html</guid><pubDate>Fri, 24 Apr 2015 18:05:56 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Tutorials</dc:subject><dc:date>2015-04-24</dc:date></item><item><title>Auto: Building a Declarative Chatbot with Implicit Serialization</title><link>http://blog.jle.im/entry/auto-building-a-declarative-chatbot-with-implicit-serialization.html</link><description>&lt;p&gt;Today we’re going to continue along with the &lt;a href=&quot;http://blog.jle.im/entries/series/+all-about-auto&quot;&gt;All About Auto&lt;/a&gt; introduction series and look at building a declarative chatbot using the denotational components from the &lt;a href=&quot;http://hackage.haskell.org/package/auto&quot;&gt;auto&lt;/a&gt; library that is modular and has implicit serialization. Most importantly, we’ll look at the “design process”, and principles of architecture that you can apply to your own projects.&lt;/p&gt;
&lt;p&gt;This post assumes &lt;em&gt;some&lt;/em&gt; concepts from the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;tutorial&lt;/a&gt;, or at least my &lt;a href=&quot;http://blog.jle.im/entry/introducing-the-auto-library&quot;&gt;last post&lt;/a&gt; or the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/README.md&quot;&gt;README&lt;/a&gt;. If some of these ideas seem completely new, than looking through the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;tutorial&lt;/a&gt; or the &lt;a href=&quot;http://hackage.haskell.org/package/auto&quot;&gt;docs&lt;/a&gt; might refresh your mind…feel free to also leave a comment, stop by &lt;em&gt;#haskell-auto&lt;/em&gt; on freenode where I go by &lt;em&gt;jle`&lt;/em&gt;, or &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;tweet me&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;All of the code in this tutorial can be &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs&quot;&gt;downloaded and run&lt;/a&gt; using &lt;code&gt;runghc&lt;/code&gt; (with the appropriate dependencies installed). Feel free to play along!&lt;/p&gt;
&lt;h2 id=&quot;overall-layout&quot;&gt;Overall Layout&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;auto&lt;/em&gt; is a library that at the highest level gives you a stream transformer on streams of values. Transform a stream of input values to a stream of output values. So when we approach a chat bot, we have to think — what are the inputs, and what are the outputs?&lt;/p&gt;
&lt;p&gt;The choice should be pretty straightforward – our input stream is a stream of input messages from the irc server, and our output stream is a stream of messages to send to the server. In haskell we like types, so let’s make some types.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- first, our imports&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L25-43&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto.Blip&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto.Collection&lt;/span&gt;  (mux)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto.Run&lt;/span&gt;         (runOnChanM)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto.Serialize&lt;/span&gt;   (serializing&amp;#39;)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto.Switch&lt;/span&gt;      (resetOn)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Concurrent&lt;/span&gt;       (&lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt;, newChan, writeChan, forkIO, threadDelay)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad&lt;/span&gt;            (void, forever)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad.IO.Class&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Foldable&lt;/span&gt;            (forM_)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Map&lt;/span&gt;                 (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Serialize&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Text&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;hiding&lt;/span&gt;         (words, unwords, map)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Text.Encoding&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Text.Encoding.Error&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Time&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Network.SimpleIRC&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Prelude&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;hiding&lt;/span&gt;           ((.), id)   &lt;span class=&quot;co&quot;&gt;-- we use (.) and id from `Control.Category`&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import qualified&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Data.Map&lt;/span&gt;       &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;M&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L51-66&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; { _&lt;span class=&quot;ot&quot;&gt;inMessageNick   ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;
                           , _&lt;span class=&quot;ot&quot;&gt;inMessageBody   ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;
                           , _&lt;span class=&quot;ot&quot;&gt;inMessageSource ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt;
                           , _&lt;span class=&quot;ot&quot;&gt;inMessageTime   ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;
                           } &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;]) &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monoid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    mempty  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; M.empty
    mappend (&lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; m1) (&lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; m2)
            &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; (M.unionWith (&lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt;) m1 m2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We make some type aliases to make things a bit clearer. Our inputs are going to be a data type/“struct” with a nick, a body, a source, and a time. Our outputs are going to be a &lt;code&gt;Data.Map.Map&lt;/code&gt; from &lt;em&gt;containers&lt;/em&gt; associating channels with messages to send. I’m just adding here a &lt;code&gt;Monoid&lt;/code&gt; instance in case we want to combine &lt;code&gt;OutMessages&lt;/code&gt; maps.&lt;/p&gt;
&lt;p&gt;The type for a chat bot over a monad &lt;code&gt;m&lt;/code&gt; would then be:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L68-68&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;ChatBot&lt;/code&gt; takes a stream of &lt;code&gt;InMessage&lt;/code&gt;s and returns a stream of &lt;code&gt;OutMessages&lt;/code&gt;s…and might have effects in &lt;code&gt;m&lt;/code&gt; as it does so.&lt;/p&gt;
&lt;p&gt;Note that we get a free instance of &lt;code&gt;Monoid&lt;/code&gt; on &lt;code&gt;ChatBot m&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;mappend ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That takes two &lt;code&gt;ChatBot&lt;/code&gt;s and creates a new &lt;code&gt;ChatBot&lt;/code&gt; that forks the input stream (sends all &lt;code&gt;InMessage&lt;/code&gt;s) to both of the original ones, and &lt;code&gt;mappend&lt;/code&gt;s the results. So the new &lt;code&gt;ChatBot&lt;/code&gt; will send message to both original ones and return a “combined” &lt;code&gt;OutMessages&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, not all modules really have to “care” about the room of the outputs…they might just always reply directly to the room they received the message on. So it’ll help us to also make another sort of &lt;code&gt;Auto&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L69-69&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;RoomBot&lt;/code&gt; doesn’t care where its messages go…it just replies to the same room it got its input from. It outputs a blip stream of message lists; when it doesn’t want to send messages out, it doesn’t emit. When it does, it &lt;em&gt;does&lt;/em&gt; emit, with the list of messages.&lt;/p&gt;
&lt;p&gt;(Remember, a &lt;em&gt;blip stream&lt;/em&gt; is just like a normal stream of values, except it only actually &lt;em&gt;has&lt;/em&gt; a value every once in a while, when it “emits”. A &lt;code&gt;Blip Bool&lt;/code&gt; is a stream that sometimes, occasionally emits with a &lt;code&gt;Bool&lt;/code&gt;. We work with them using combinators and &lt;code&gt;Auto&lt;/code&gt;s from &lt;a href=&quot;http://hackage.haskell.org/package/auto/docs/Control-Auto-Blip.html&quot;&gt;&lt;code&gt;Control.Auto.Blip&lt;/code&gt;&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id=&quot;converting&quot;&gt;Converting&lt;/h3&gt;
&lt;p&gt;We can write a quick helper function to convert a &lt;code&gt;RoomBot&lt;/code&gt; into a full-on &lt;code&gt;ChatBot&lt;/code&gt;, so we can merge them together with &lt;code&gt;mappend&lt;/code&gt;/&lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L72-75&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;perRoom ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
perRoom rb &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc inp&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; _ _ src _) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    messages &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; fromBlips [] &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; rb &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp
    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; M.singleton src messages&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(This example uses proc notation; see this &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md#brief-primer-on-proc-notation&quot;&gt;proc notation primer&lt;/a&gt; for a quick run-down of the relevant aspects)&lt;/p&gt;
&lt;p&gt;We say that &lt;code&gt;messages&lt;/code&gt; is just the output of &lt;code&gt;rb&lt;/code&gt; fed with the input, except it “collapses” the blip stream into a normal stream by substituting in &lt;code&gt;[]&lt;/code&gt; whenever the stream doesn’t emit. So &lt;code&gt;messages&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt; when &lt;code&gt;rb&lt;/code&gt; doesn’t emit (it doesn’t want to send anything), and &lt;code&gt;messages&lt;/code&gt; is &lt;code&gt;[message1, message2 ...]&lt;/code&gt;, with the emitted contents, when it &lt;em&gt;does&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The “output” will be a singleton map with the source of the input and the messages to send to that source.&lt;/p&gt;
&lt;p&gt;So now if we have a &lt;code&gt;RoomBot m&lt;/code&gt;, we can convert it up into a &lt;code&gt;ChatBot m&lt;/code&gt;, and combine it/merge it with other &lt;code&gt;ChatBot m&lt;/code&gt;s.&lt;/p&gt;
&lt;h3 id=&quot;the-whole-deal&quot;&gt;The whole deal&lt;/h3&gt;
&lt;p&gt;We have enough now then to imagine our entire program architecture:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Write a bunch of separate modules, as &lt;code&gt;ChatBot m&lt;/code&gt;s or &lt;code&gt;RoomBot m&lt;/code&gt;s, which ever one is more convenient. The beauty is that we can merge them all together in the end with our promoter.&lt;/li&gt;
&lt;li&gt;Combine all of our modules with &lt;code&gt;mconcat&lt;/code&gt; — that is, something like &lt;code&gt;chatBot = mconcat [module1, module2, module3, module 4]&lt;/code&gt;. And that’s it, that’s our entire chat bot!&lt;/li&gt;
&lt;li&gt;Having an overall &lt;code&gt;chatBot :: ChatBot m&lt;/code&gt;, we can use something like &lt;code&gt;runOnChan&lt;/code&gt; from &lt;code&gt;Control.Auto.Run&lt;/code&gt; to have it exist on a concurrent thread and watch a channel for input, and perform an action on output.&lt;/li&gt;
&lt;li&gt;Find an out-of-the-box irc library that can trigger adding something to a concurrent queue when it receives a message, and where you can send messages to rooms.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And…that’s it. Program logic in our &lt;code&gt;ChatBot m&lt;/code&gt;s, and handling the “view”/input with our backend.&lt;/p&gt;
&lt;h4 id=&quot;free-serialization&quot;&gt;Free Serialization&lt;/h4&gt;
&lt;p&gt;Remember that &lt;em&gt;auto&lt;/em&gt; gives us the ability to serialize and resume our &lt;code&gt;Auto&lt;/code&gt;s for free…so we can at any time save the state of our chat bot to disk, and resume it when we re-load. We don’t have to worry about manually gathering our state between each &lt;code&gt;Auto&lt;/code&gt; and writing serialization code.&lt;/p&gt;
&lt;p&gt;There’s a “convenience combinator” called &lt;code&gt;serializing&#39;&lt;/code&gt; in &lt;code&gt;Control.Auto.Serialize&lt;/code&gt; (it’s one of many different ones that can do something like this; &lt;a href=&quot;http://hackage.haskell.org/package/auto/docs/Control-Auto-Serialize.html&quot;&gt;check out the module&lt;/a&gt; to see other ways of varying disciplined-ness!). It’ll take any &lt;code&gt;Auto&lt;/code&gt; and turn it into an &lt;code&gt;Auto&lt;/code&gt; that “self-serializes” — when you begin running it, it automatically loads its previous state if it exists, and as you run it, it automatically maintains an updated “resume state” on disk.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;serializing&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; FilePath &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;serializing&#39; fp :: MonadIO m =&amp;gt; ChatBot m -&amp;gt; ChatBot m&lt;/code&gt;. It looks a lot like an “identity-ish” sort of function, right? That’s because it is meant to behave &lt;em&gt;like&lt;/em&gt; &lt;code&gt;id&lt;/code&gt;…the returned &lt;code&gt;ChatBot&lt;/code&gt; behaves identical to the previous one…except it splices in the serializing action in-between. (We are in &lt;code&gt;MonadIO&lt;/code&gt; now, because the &lt;code&gt;Auto&lt;/code&gt; has to access &lt;code&gt;IO&lt;/code&gt; in order to serialize itself between steps).&lt;/p&gt;
&lt;p&gt;So, instead of&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;chatBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
chatBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mconcat [module1, module2, module3]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can do:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;chatBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
chatBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;state.dat&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; mconcat [module1, module2, module3]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now our &lt;code&gt;chatBot&lt;/code&gt; will automatically resume itself on program startup, and keep its state backed up on disk at &lt;code&gt;state.dat&lt;/code&gt;. We get this for free, without doing anything extra in the composition of our modules.&lt;/p&gt;
&lt;p&gt;Note that in practice, with a bot you are actively developing, this might not be the best idea. &lt;code&gt;serializing&#39;&lt;/code&gt; &lt;em&gt;analyzes&lt;/em&gt; your &lt;code&gt;Auto&lt;/code&gt;s to determine a serialization and reloading strategy, and applies that to do its job. However, if you, for example, add a new module to your chat bot…the serialization strategy will change, and your new bot won’t be able to resume old save files.&lt;/p&gt;
&lt;p&gt;One solution at this point is just to serialize individual modules that you do not see yourself changing…or even just serializing parts of the modules you don’t see yourself changing. Then you can change each portion separately and not worry about migration issues.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;chatBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
chatBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mconcat [ serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;m1.dat&amp;quot;&lt;/span&gt; module1
                  , module2
                  , serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;m3.dat&amp;quot;&lt;/span&gt; module3
                  ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We’re not all-or-nothing now here, either! So, &lt;code&gt;module1&lt;/code&gt; gets serialized and auto-resumed from &lt;code&gt;m1.dat&lt;/code&gt;, &lt;code&gt;module2&lt;/code&gt; is not serialized at all, and &lt;code&gt;module3&lt;/code&gt; now gets serialized and auto-resumed from &lt;code&gt;m3.dat&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;irc-backend-the-ugly-part&quot;&gt;IRC Backend (the ugly part)&lt;/h2&gt;
&lt;p&gt;Before we get started on our actual modules, let’s just write out the backend/interface between our &lt;code&gt;ChatBot&lt;/code&gt; and irc to get it out of the way. This will vary based on what library you use; I’m going to use the &lt;a href=&quot;http://hackage.haskell.org/package/simpleirc-0.3.0&quot;&gt;simpleirc-0.3.0&lt;/a&gt;, but feel free to use any interface/library you want.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L45-228&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;withIrcConf ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IrcConfig&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
withIrcConf ircconf chatbot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;-- chan to receive `InMessage`s&lt;/span&gt;
    inputChan &lt;span class=&quot;ot&quot;&gt;&amp;lt;- newChan ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt;)

    &lt;span class=&quot;co&quot;&gt;-- configuring IRC&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; events   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; cEvents ircconf &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; [ &lt;span class=&quot;dt&quot;&gt;Privmsg&lt;/span&gt; (onMessage inputChan) ]
        ircconf&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ircconf { cEvents &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; events }

    &lt;span class=&quot;co&quot;&gt;-- connect; simplified for demonstration purposes&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; server &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; connect ircconf&amp;#39; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;-- run `chatbot` on `inputChan`&lt;/span&gt;
    void &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; forkIO &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; void &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;
        runOnChanM id (processOutput server) inputChan chatbot

  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- what to do when `chatBot` outputs&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    processOutput ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MIrc&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
    processOutput server (&lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; outs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
      print outs
      _ &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; flip M.traverseWithKey outs &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \channel messages &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; channel&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; encodeUtf8 &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; pack &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; channel
        forM_ messages &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \message &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; message&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; encodeUtf8 &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; pack &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; message
          sendMsg server channel&amp;#39; message&amp;#39;
      return &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- &amp;quot;yes, continue on&amp;quot;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;-- what to do when you get a new message&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    onMessage ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;EventFunc&lt;/span&gt;
    onMessage inputChan &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \_ message &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; (mNick message, mOrigin message) &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; src) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
          time &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getCurrentTime
          writeChan inputChan &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; (unpack (decodeUtf8 nick))
                                          (unpack (decodeUtf8 (mMsg message)))
                                          (unpack (decodeUtf8 src))
                                          time

&lt;span class=&quot;ot&quot;&gt;channels ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt;]
channels &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&amp;quot;#testchan1&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;#testchan2&amp;quot;&lt;/span&gt;]

&lt;span class=&quot;ot&quot;&gt;conf ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IrcConfig&lt;/span&gt;
conf &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (mkDefaultConfig &lt;span class=&quot;st&quot;&gt;&amp;quot;myserver&amp;quot;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;mynick&amp;quot;&lt;/span&gt;) { cChannels &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; channels }

&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    withIrcConf conf chatBot
    forever (threadDelay &lt;span class=&quot;dv&quot;&gt;1000000000&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That should be it…don’t worry if you don’t understand all of it, most of it is just implementation details from &lt;code&gt;simpleirc&lt;/code&gt;. The overall loop is &lt;code&gt;runOnChanM&lt;/code&gt; waits on a separate thread for &lt;code&gt;inputChan&lt;/code&gt;…when it gets input, it runs it through &lt;code&gt;ChatBot&lt;/code&gt; and sends the outputs through &lt;em&gt;simpleirc&lt;/em&gt;’s interface. Meanwhile, &lt;code&gt;onMessage&lt;/code&gt; is triggered whenever &lt;em&gt;simpleirc&lt;/em&gt; receives a message, where it prepares an &lt;code&gt;InMessage&lt;/code&gt; and drops it off at &lt;code&gt;inputChan&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;runOnChanM ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m
           &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (forall c&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; m c &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; c)   &lt;span class=&quot;co&quot;&gt;-- convert `m` to `IO`&lt;/span&gt;
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;)            &lt;span class=&quot;co&quot;&gt;-- handle output&lt;/span&gt;
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt; a                    &lt;span class=&quot;co&quot;&gt;-- chan to await input on&lt;/span&gt;
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a b                &lt;span class=&quot;co&quot;&gt;-- `Auto` to run&lt;/span&gt;
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;runOnChanM&lt;/code&gt; runs any &lt;code&gt;Auto m a b&lt;/code&gt;, as long as there’s a way to convert it to &lt;code&gt;Auto IO a b&lt;/code&gt; (we can use a &lt;code&gt;ChatBot IO&lt;/code&gt;, so we just put &lt;code&gt;id&lt;/code&gt; there). You give it a “handler” &lt;code&gt;b -&amp;gt; IO Bool&lt;/code&gt; that it run whenever it outputs; if the handler returns &lt;code&gt;False&lt;/code&gt;, then the whole thing stops. You give it the &lt;code&gt;Chan a&lt;/code&gt; to await for input &lt;code&gt;a&lt;/code&gt;s on, and it takes care of the rest. It blocks until the handler returns &lt;code&gt;False&lt;/code&gt;, where it’ll return the “updated” &lt;code&gt;Auto m a b&lt;/code&gt; with updated state after running through all of those inputs.&lt;/p&gt;
&lt;p&gt;Phew. With that out of the way, let’s get right on to the fun part — building our chat bot modules.&lt;/p&gt;
&lt;h2 id=&quot;the-modules&quot;&gt;The Modules&lt;/h2&gt;
&lt;h3 id=&quot;seenbot&quot;&gt;seenBot&lt;/h3&gt;
&lt;p&gt;What’s a common module? Well, we can write a module that keeps track of the last time any user was “seen” (sent a message), and then respond when there is a query.&lt;/p&gt;
&lt;p&gt;There are two components here…the part that keeps track of the last seen time, and the part that responds to queries.&lt;/p&gt;
&lt;p&gt;Keeping track of our last seen time sounds like a job that takes in a stream of &lt;code&gt;(Nick, UTCTime)&lt;/code&gt; pairs and outputs a stream of &lt;code&gt;Map Nick UTCTime&lt;/code&gt;, where we could look up the last seen time for a nick by looking up the nick in the map.&lt;/p&gt;
&lt;p&gt;Logically, this is pretty straightforward, and anything other than &lt;code&gt;accum&lt;/code&gt; (which is like &lt;code&gt;foldl&#39;&lt;/code&gt;) would really be a bit overkill; every input would just update the output map.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;trackSeens ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;)
trackSeens &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; accum (\mp (nick, time) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insert nick time mp) M.empty&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;accum&lt;/code&gt; takes the same thing that &lt;code&gt;foldl&lt;/code&gt; takes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;foldl&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt;            (b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b
&lt;span class=&quot;ot&quot;&gt;accum ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So it basically “folds up” the entire history of inputs, with a starting value. Every time an input comes, the output is the new folded history of inputs. You can sort of think of it as it applying the function to any incoming values to an internal accumulator and updating it at every step.&lt;/p&gt;
&lt;p&gt;By the way, because &lt;code&gt;trackSeens&lt;/code&gt; is self-serializing, we need a &lt;code&gt;Serialize&lt;/code&gt; instance for &lt;code&gt;UTCTime&lt;/code&gt;…just for the sake of demonstration, let’s make one now. Let’s also write a &lt;code&gt;Serialize&lt;/code&gt; instance for &lt;code&gt;Day&lt;/code&gt; (which represents a date) too, while we’re at it.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L230-236&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Serialize&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    get &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; read &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; get      &lt;span class=&quot;co&quot;&gt;-- haha don&amp;#39;t do this in real life.&lt;/span&gt;
    put &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; put &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; show

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Serialize&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    get &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ModifiedJulianDay&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; get
    put &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; put &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; toModifiedJulianDay&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The next component is just to respond to requests. We want to do something on some “triggering” input. Every once in a while, some input will come that will “trigger” some special response. This is a sign that we can use &lt;em&gt;blip streams&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@seen&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
    getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;queryBlips&lt;/code&gt; takes an input stream of strings and turns it into an output &lt;em&gt;blip stream&lt;/em&gt; that emits with a &lt;code&gt;Nick&lt;/code&gt; whenever the input stream contains a request in the form of &lt;code&gt;&amp;quot;@seen [nick]&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With these simple blocks, we can build our &lt;code&gt;seenBot&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- seenBot :: Monad m =&amp;gt; Auto m InMessage (Blip [Message])&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L96-115&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;seenBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m
seenBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc (&lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; nick msg _ time) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    seens  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; trackSeens &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (nick, time)

    queryB &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; queryBlips &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; msg

    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; respond ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;]
        respond qry &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; M.lookup qry seens &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                        &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [qry &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; last seen at &amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; show t &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;]
                        &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&amp;quot;No record of &amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; qry &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;]

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; respond &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; queryB
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    trackSeens ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;)
    trackSeens &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; accum (\mp (nick, time) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insert nick time mp) M.empty
&lt;span class=&quot;ot&quot;&gt;    queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
    queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@seen&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
        getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we define &lt;code&gt;respond&lt;/code&gt; as a function that takes a &lt;code&gt;Nick&lt;/code&gt; and returns the output &lt;code&gt;[Message]&lt;/code&gt;. We could have also defined it outside as a helper function &lt;code&gt;respond :: Map Nick UTCTime -&amp;gt; Nick -&amp;gt; [Message]&lt;/code&gt;…but &lt;code&gt;seens&lt;/code&gt; is already in scope, so we might as well just do it there.&lt;/p&gt;
&lt;p&gt;For our output, we use the &lt;code&gt;Functor&lt;/code&gt; instance of blip streams. &lt;code&gt;respond &amp;lt;$&amp;gt; queryB&lt;/code&gt; is a blip stream that emits whenever &lt;code&gt;queryB&lt;/code&gt; emits (so, whenever there is a query input), but replaces the emitted value with the result of the function on the value. So whenever &lt;code&gt;queryB&lt;/code&gt; emits, this whole thing emits with &lt;code&gt;respond&lt;/code&gt; applied to whatever &lt;code&gt;Nick&lt;/code&gt; was emitted — in this case, our &lt;code&gt;[Message]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Short, sweet, simple. In fact, &lt;code&gt;trackSeens&lt;/code&gt; and &lt;code&gt;queryBlips&lt;/code&gt; are small enough that their definition could really have been inlined. Breaking them down just allowed us to look at them individually for this tutorial.&lt;/p&gt;
&lt;p&gt;So that’s it for that; also, if we wanted &lt;code&gt;seenBot&lt;/code&gt; to serialize and persist across sessions, all we have to do is use:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;seenbot.dat&amp;quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; seenBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat, right?&lt;/p&gt;
&lt;p&gt;If we forsee ourselves adding more features to &lt;code&gt;seenBot&lt;/code&gt;, we can future-proof our &lt;code&gt;seenBot&lt;/code&gt; for now by only serializing &lt;code&gt;trackSeens&lt;/code&gt;, meaning replacing that line with:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;    seens &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;seen.dat&amp;quot;&lt;/span&gt; trackSeens &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (nick, time)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember, &lt;code&gt;serializing&#39; fp&lt;/code&gt; acts as a sort of “identity”, so you can drop it in anywhere and you’d expect it to behave the same.&lt;/p&gt;
&lt;h3 id=&quot;repbot&quot;&gt;repBot&lt;/h3&gt;
&lt;p&gt;Another common bot is a “reputation bot”, which allows users to increment or decrement another user’s reputation scores, and look up a user’s total score.&lt;/p&gt;
&lt;p&gt;Again there are two components — keeping track of the scores of all of the users, and responding to requests.&lt;/p&gt;
&lt;p&gt;This time though, our “score updates” only happen every once in a while, triggered by certain words in the message. Again, this pattern calls for a blip stream:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;updateBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;))
updateBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts getUpdateCommand
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- updater is the person triggering the update blip&lt;/span&gt;
    getUpdateCommand (updater, msg) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; words msg &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&amp;quot;@addRep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_ &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; nick &lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; updater &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (nick, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
        &lt;span class=&quot;st&quot;&gt;&amp;quot;@subRep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_                   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (nick, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
        _                                  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;updateBlips&lt;/code&gt; takes in a stream of &lt;code&gt;(Nick, Message)&lt;/code&gt;, with the person who is sending the message and their message, and outputs a blip stream that and emits with a &lt;code&gt;(Nick, Int)&lt;/code&gt; whenever the message is a command. The emitted &lt;code&gt;(Nick, Int)&lt;/code&gt; has the person to adjust, and the amount to adjust by. Note that we ignore commands where the person is trying to increase their own reputation because that’s just lame.&lt;/p&gt;
&lt;p&gt;We probably want to keep track of the scores as a &lt;code&gt;Map Nick Int&lt;/code&gt;, so we can do that with something like &lt;code&gt;accum&lt;/code&gt; again. However, &lt;code&gt;accum&lt;/code&gt; takes a stream of normal values, but we have a &lt;em&gt;blip stream&lt;/em&gt;, so we can use &lt;code&gt;scanB&lt;/code&gt; instead. &lt;code&gt;scanB&lt;/code&gt; is pretty much the same thing, but it collapses a blip stream into a value stream by holding the “current result” of the fold.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;trackReps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
trackReps &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp (nick, change) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick change mp) M.empty&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And finally, the “response” portion — we want to be able to respond to commands and look up the result. We basically had this identical pattern for &lt;code&gt;seenBot&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@rep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
    getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…now we can wrap it all together with a nice proc block:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- repBot :: Monad m =&amp;gt; Auto m InMessage (Blip [Message])&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L117-147&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;repBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m
repBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc (&lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; nick msg _ _) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    updateB &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; updateBlips &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (nick, msg)

    reps    &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; trackReps   &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; updateB

    queryB  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; queryBlips  &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; msg

    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lookupRep ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;]
        lookupRep nick &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [nick &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; has a reputation of &amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; show rep &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;]
          &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
            rep &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; M.findWithDefault &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; nick reps

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; lookupRep &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; queryB
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    updateBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;))
    updateBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts getUpdateCommand
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- updater is the person triggering the update blip&lt;/span&gt;
        getUpdateCommand (updater, msg) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; words msg &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&amp;quot;@addRep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_ &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; nick &lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; updater &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (nick, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
            &lt;span class=&quot;st&quot;&gt;&amp;quot;@subRep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_                   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (nick, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
            _                                  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    trackReps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
    trackReps &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp (nick, change) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick change mp) M.empty
&lt;span class=&quot;ot&quot;&gt;    queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
    queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@rep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
        getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Again note that we take advantage of the &lt;code&gt;Functor&lt;/code&gt; instance of blip streams to create a new blip stream (&lt;code&gt;lookupRep &amp;lt;$&amp;gt; queryB&lt;/code&gt;) that emits whenever &lt;code&gt;queryB&lt;/code&gt; emits, but replaces the value with &lt;code&gt;lookupRep&lt;/code&gt; applied to whatever &lt;code&gt;Nick&lt;/code&gt; was in the query blip. We also take advantage that &lt;code&gt;reps&lt;/code&gt; is in scope and define &lt;code&gt;lookupRep&lt;/code&gt; right there in the block.&lt;/p&gt;
&lt;h3 id=&quot;announcebot&quot;&gt;announceBot&lt;/h3&gt;
&lt;p&gt;Let’s just go over one more module…and I think you’ll be able to use your imagination to think of and implement your own from here.&lt;/p&gt;
&lt;p&gt;Let’s make an “announceBot”, that listens for “announcement” messages from anyone (even in private messages) and broadcasts them to all of the channels in the provided list. It rate-limits the announcements, though, so that a user is only limited to three announcements per day.&lt;/p&gt;
&lt;p&gt;We can start with our typical “blip stream that emits on a certain command” to start off everything:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;announceBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;])
announceBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts getAnnounces
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    getAnnounces (nick, msg) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; words msg &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&amp;quot;@ann&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ann &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; [nick &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; says \&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; unwords ann &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;\&amp;quot;.&amp;quot;&lt;/span&gt;]
        _          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;announceBlips&lt;/code&gt; takes in a nick-message pair and emits an announcement &lt;code&gt;[Message]&lt;/code&gt; whenever the incoming message is an announcement command.&lt;/p&gt;
&lt;p&gt;Next, we’d like to keep track of how many times a user has made an announcement today. This is pretty much just &lt;code&gt;scanB&lt;/code&gt; again like with &lt;code&gt;repBot&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;trackAnns ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
trackAnns &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp nick &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; mp) M.empty&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, we’d like to be able to “reset” this map whenever a new day arrives. For that, we can use &lt;code&gt;resetOn&lt;/code&gt; from &lt;a href=&quot;http://hackage.haskell.org/package/auto/docs/Control-Auto-Switch.html&quot;&gt;&lt;code&gt;Control.Auto.Switch&lt;/code&gt;&lt;/a&gt;, which takes an &lt;code&gt;Auto&lt;/code&gt; and gives it a “reset channel” input blip stream, that resets the whole thing whenever the blip stream emits:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;resetOn ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (a        , &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; c) b
resetOn&lt;span class=&quot;ot&quot;&gt; trackAnns ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt;     &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; c) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(It doesn’t care about the actual value emitted, so we can leave it as a type variable &lt;code&gt;c&lt;/code&gt; conceptually.)&lt;/p&gt;
&lt;p&gt;Now the only thing we need is a blip stream that emits whenever there is a new day. For that, we can use &lt;code&gt;onChange&lt;/code&gt; from &lt;a href=&quot;http://hackage.haskell.org/package/auto/docs/Control-Auto-Blip.html&quot;&gt;&lt;code&gt;Control.Auto.Blip&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;newDayBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt;)
newDayBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onChange&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;newDayBlips&lt;/code&gt; takes in a stream of &lt;code&gt;Day&lt;/code&gt;s (from &lt;code&gt;Data.Time&lt;/code&gt;) that we get from the &lt;code&gt;InMessage&lt;/code&gt; and outputs a blip stream that emits whenever the day changes. It emits with the new &lt;code&gt;Day&lt;/code&gt;…but we don’t really care about the emitted value, we’re just using it to trigger &lt;code&gt;resetOn trackAnns&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Finally, let’s wrap it all together!&lt;/p&gt;
&lt;p&gt;Remember, &lt;code&gt;announceBot&lt;/code&gt; is a full on &lt;code&gt;ChatBot m&lt;/code&gt;, and not a &lt;code&gt;RoomBot m&lt;/code&gt; anymore, so it has to say where it wants to send its messages.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- announceBot :: Monad m =&amp;gt; [Channel] -&amp;gt; Auto m InMessage OutMessages&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L149-183&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;announceBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
announceBot chans &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc (&lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; nick msg src time) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    announceB &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; announceBlips     &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (nick, msg)

    newDayB   &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; newDayBlips       &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; utctDay time

    annCounts &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; resetOn trackAnns &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (nick &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&lt;/span&gt; announceB, newDayB)

    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; hasFlooded  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; M.findWithDefault &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; nick annCounts &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;        targetChans ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt;]
        targetChans &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; hasFlooded &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [src]
                    &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; chans

&lt;span class=&quot;ot&quot;&gt;        outB        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;]
        outB        &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; hasFlooded &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [nick &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;: No flooding!&amp;quot;&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&lt;/span&gt; announceB
                    &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; announceB

&lt;span class=&quot;ot&quot;&gt;        outMsgsB    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt;
        outMsgsB    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (\out &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; (M.fromList (map (,out) targetChans)))
                  &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; outB

    fromBlips mempty &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; outMsgsB
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    announceBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;])
    announceBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts getAnnounces
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getAnnounces (nick, msg) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; words msg &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&amp;quot;@ann&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ann &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; [nick &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; says \&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; unwords ann &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;\&amp;quot;.&amp;quot;&lt;/span&gt;]
            _          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    newDayBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt;)
    newDayBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onChange
&lt;span class=&quot;ot&quot;&gt;    trackAnns ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
    trackAnns &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp nick &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; mp) M.empty&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Only slightly more involved, but still pretty readable, right? We find out if things have flooded, and our target channels will be just the original source if true (a message as a reprimand); otherwise, all the channels in &lt;code&gt;chans&lt;/code&gt;. If they have flooded, then our &lt;code&gt;outB&lt;/code&gt; (blip stream of &lt;code&gt;[Message]&lt;/code&gt; to send to each room) will just be &lt;code&gt;[&amp;quot;No flooding!&amp;quot;]&lt;/code&gt; if yes, or the actual announcement otherwise.&lt;/p&gt;
&lt;p&gt;Finally, our &lt;code&gt;Blip OutMessages&lt;/code&gt; will be the &lt;code&gt;OutMessage&lt;/code&gt; formed by associating all of the channels in &lt;code&gt;targetChans&lt;/code&gt; with the message in &lt;code&gt;outB&lt;/code&gt;…emitting whenever &lt;code&gt;outB&lt;/code&gt; emits.&lt;/p&gt;
&lt;p&gt;Note here that we use &lt;code&gt;(&amp;lt;$)&lt;/code&gt; from the &lt;code&gt;Functor&lt;/code&gt; instance of blip streams. &lt;code&gt;x &amp;lt;$ fooB&lt;/code&gt; is a new blip stream that emits whenever &lt;code&gt;fooB&lt;/code&gt; emits…but instead &lt;em&gt;replaces the emitted value&lt;/em&gt;. So for &lt;code&gt;4 &amp;lt;$ fooB&lt;/code&gt;, if &lt;code&gt;fooB&lt;/code&gt; emits with &lt;code&gt;&amp;quot;hello&amp;quot;&lt;/code&gt;, &lt;code&gt;4 &amp;lt;$ fooB&lt;/code&gt; emits with &lt;code&gt;4&lt;/code&gt;. “Emit at the same time, but pry out the value and put in your own.”&lt;/p&gt;
&lt;p&gt;Finally we use &lt;code&gt;fromBlips&lt;/code&gt;, which we met before in the definition of &lt;code&gt;perRoom&lt;/code&gt;: the output is the &lt;code&gt;OutMessage&lt;/code&gt; in &lt;code&gt;outMsgsB&lt;/code&gt; whenever &lt;code&gt;outMsgsB&lt;/code&gt; &lt;em&gt;does&lt;/em&gt; emit…or it’s &lt;code&gt;mempty&lt;/code&gt; (the empty map) when it doesn’t.&lt;/p&gt;
&lt;h2 id=&quot;wrapping-it-all-up&quot;&gt;Wrapping it all up&lt;/h2&gt;
&lt;p&gt;We have three nice modules now. Now let’s wrap it all together.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L83-88&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;chatBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
chatBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;chatbot.dat&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; mconcat &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; [ perRoom seenBot
                    , perRoom repBot
                    , announceBot channels
                    ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or, to future-proof, in case we foresee adding new modules:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L90-94&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;chatBot&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
chatBot&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mconcat [ perRoom &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;seens.dat&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; seenBot
                   , perRoom &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;reps.dat&amp;quot;&lt;/span&gt;  &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; repBot
                   ,           serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;anns.dat&amp;quot;&lt;/span&gt;  &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; announceBot channels
                   ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…that’s it!&lt;/p&gt;
&lt;p&gt;Feel free to &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs&quot;&gt;download and run this all yourself&lt;/a&gt; using &lt;code&gt;runghc&lt;/code&gt;! (provided you have the appropriate libraries installed)&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This is a quick diversion! It’s slightly more advanced, so don’t worry if you don’t understand it immediately.&lt;/p&gt;
&lt;p&gt;Note that the &lt;code&gt;perRoom&lt;/code&gt; upgrade has the same &lt;code&gt;RoomBot m&lt;/code&gt; watch &lt;em&gt;all&lt;/em&gt; of the channels and send any replies back to the channel that it just received from. Every channel is really interacting with the &lt;em&gt;same&lt;/em&gt; &lt;code&gt;RoomBot&lt;/code&gt; instance, with one shared state. So &lt;code&gt;perRoom repBot&lt;/code&gt; keeps track of reputations between rooms — asking for someone’s reputation in one room will be the same as asking for it in another room.&lt;/p&gt;
&lt;p&gt;Another way we could “upgrade” a &lt;code&gt;RoomBot&lt;/code&gt; is to give each channel its own little copy, with separate state. We can do this using &lt;code&gt;mux&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L78-81&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;isolatedRooms ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
isolatedRooms rb &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc inp&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; _ _ src _) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    messages &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; fromBlips [] &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; mux (const rb) &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (src, inp)
    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; M.singleton src messages&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;mux&lt;/code&gt; is an “&lt;code&gt;Auto&lt;/code&gt; multiplexer”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;mux ::&lt;/span&gt; (k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (k, a) b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;mux f&lt;/code&gt; associates a separate/different &lt;code&gt;Auto&lt;/code&gt;, with its own isolated state, with every key &lt;code&gt;k&lt;/code&gt;. It takes in a stream of key-input pairs &lt;code&gt;(k, a)&lt;/code&gt; and feeds the &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;Auto&lt;/code&gt; it has associated with that key &lt;code&gt;k&lt;/code&gt;. The function &lt;code&gt;f&lt;/code&gt; is what &lt;code&gt;Auto&lt;/code&gt; initialize if the &lt;code&gt;k&lt;/code&gt; has not yet been seen before.&lt;/p&gt;
&lt;p&gt;So we feed it a &lt;code&gt;(Channel, InMessage)&lt;/code&gt;, and it feeds in that &lt;code&gt;InMessage&lt;/code&gt; to the &lt;code&gt;RoomBot m&lt;/code&gt; associated with that &lt;code&gt;Channel&lt;/code&gt;…and the output is the &lt;code&gt;Blip [Message]&lt;/code&gt; blip stream that the &lt;code&gt;RoomBot&lt;/code&gt; at that &lt;code&gt;Channel&lt;/code&gt; popped out.&lt;/p&gt;
&lt;p&gt;Our “auto initialization function” is &lt;code&gt;const rb&lt;/code&gt;, because no matter what channel we’re in, we always want to initialize with the same &lt;code&gt;rb&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So, for example, if we had &lt;code&gt;isolatedRooms repBot&lt;/code&gt;, if a message came from channel &lt;em&gt;#foo&lt;/em&gt; saying &lt;code&gt;&amp;quot;@rep john&amp;quot;&lt;/code&gt;, &lt;em&gt;only the &lt;code&gt;repBot&lt;/code&gt; associated with #foo&lt;/em&gt; would get the message, and only that &lt;code&gt;repBot&lt;/code&gt;’s output will be displayed. If here is not yet a &lt;code&gt;repBot&lt;/code&gt; instance associated with &lt;em&gt;#foo&lt;/em&gt;, then a new one will be created by calling &lt;code&gt;const repBot&lt;/code&gt; on &lt;code&gt;&amp;quot;#foo&amp;quot;&lt;/code&gt;…initializing a new &lt;code&gt;repBot&lt;/code&gt; that only knows about &lt;em&gt;#foo&lt;/em&gt; messages.&lt;/p&gt;
&lt;p&gt;So now every channel has its own &lt;code&gt;repBot&lt;/code&gt;, and maintains its own independent reputation database.&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;fin&quot;&gt;Fin&lt;/h2&gt;
&lt;p&gt;Hopefully, going over this project, you’re starting to see some common and powerful idioms and tools. I hope that a clear picture of how to approach and finish a program with the &lt;em&gt;auto&lt;/em&gt; library looks…and how beneficial the platform and what it offers is to streamlining the development process.&lt;/p&gt;
&lt;p&gt;Also, hopefully the “declarative” nature of everything is apparent. Especially for &lt;em&gt;proc&lt;/em&gt; blocks…everything just “looks like” a graph of relationships. This quantity is related to this quantity in this way, this quantity is related to that in that way, etc. It looks like you’re just specifying a graph of relationships, which is really what the core of &lt;em&gt;auto&lt;/em&gt; is all about. We assemble complex relationships by putting together small, simple relationships.&lt;/p&gt;
&lt;p&gt;Another interesting thing is that we never really explicitly managed any sort of state or state type. All of our &lt;code&gt;Auto&lt;/code&gt;s handled their state on their own. We didn’t need to make a giant massive aggregate bulky “global state” type…and we can add new “aspects” of state (new modules) without ever having to change any data type. The state all manages itself!&lt;/p&gt;
&lt;p&gt;And yeah, we didn’t just implement “easy” modules/components…these are actual working components that you might see in real bots, and not just toy ones.&lt;/p&gt;
&lt;p&gt;Where can we go from here? Well, you might actually want to maybe write “subscription” &lt;code&gt;Auto&lt;/code&gt;s that are updated every minute or so:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChronBot&lt;/span&gt; m &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You feed them inputs every minute with the time, and it’s allowed to react with the time and output an &lt;code&gt;OutMessages&lt;/code&gt;. You can use this bot to implement things like rss feed watchers/subscribers, for instance.&lt;/p&gt;
&lt;p&gt;So, instead of using an input channel waiting for &lt;code&gt;InMessage&lt;/code&gt;, you might wait for &lt;code&gt;Either InMessage UTCTime&lt;/code&gt;…and drop in &lt;code&gt;Left im&lt;/code&gt; whenever you get a message, and &lt;code&gt;Right time&lt;/code&gt; from a thread that just waits a minute and repeatedly throws in times.&lt;/p&gt;
&lt;p&gt;We can do this with minimal extra work by using the &lt;code&gt;(|||)&lt;/code&gt; combinator from &lt;code&gt;Control.Arrow&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;(|||) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a c &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m b c &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; a         b      ) c
&lt;span class=&quot;ot&quot;&gt;(|||) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChronBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…you get it all for free! No extra work. Now both the &lt;code&gt;ChatBot&lt;/code&gt; and the &lt;code&gt;ChronBot&lt;/code&gt; will wait on the input stream, and the &lt;code&gt;Left&lt;/code&gt;s will be fed to the &lt;code&gt;ChatBot&lt;/code&gt; and the &lt;code&gt;Right&lt;/code&gt;s will be fed to the &lt;code&gt;ChronBot&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Anyway, this post is long enough. Have fun exploring &lt;em&gt;auto&lt;/em&gt; on your own; expect more tutorials soon as I continue the &lt;a href=&quot;http://blog.jle.im/entries/series/+all-about-auto&quot;&gt;All About Auto&lt;/a&gt; series, too. I’m always happy to hear about any project you might be working on! You can find me on twitter as &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;mstk&lt;/a&gt;. If you have any questions or comments/suggestions, feel free to leave a comment down below or drop by freenode’s &lt;em&gt;#haskell-auto&lt;/em&gt; or &lt;em&gt;#haskell-game&lt;/em&gt;, where I go by &lt;em&gt;jle`&lt;/em&gt;! And, as always, happy Haskelling!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;&lt;code&gt;scanB f x0 :: Auto m (Blip a) b&lt;/code&gt;, but there’s also &lt;code&gt;accumB f x0 :: Auto m a (Blip a) (Blip b)&lt;/code&gt;, which emits whenever the input emits only.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Auto</category><category>Tutorials</category><guid isPermaLink="true">http://blog.jle.im/entry/auto-building-a-declarative-chatbot-with-implicit-serialization.html</guid><pubDate>Wed, 25 Mar 2015 17:20:17 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Auto, Tutorials</dc:subject><dc:date>2015-03-25</dc:date></item><item><title>Introducing: the Auto library!</title><link>http://blog.jle.im/entry/introducing-the-auto-library.html</link><description>&lt;p&gt;&lt;strong&gt;Auto&lt;/strong&gt;: &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/README.md&quot;&gt;README&lt;/a&gt; (with examples) / &lt;a href=&quot;http://hackage.haskell.org/package/auto&quot;&gt;hackage&lt;/a&gt; / &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;tutorial&lt;/a&gt; / &lt;a href=&quot;https://github.com/mstksg/auto-examples&quot;&gt;examples&lt;/a&gt; / &lt;a href=&quot;https://github.com/mstksg/auto&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(Before anything, maybe take a quick look at the detailed description in the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/README.md&quot;&gt;README&lt;/a&gt; for a quick motivating example and explanation of the library)&lt;/p&gt;
&lt;p&gt;Today I’m announcing and beginning promotion of my &lt;em&gt;auto&lt;/em&gt; library, a denotative and locally stateful programming DSL and platform, now &lt;a href=&quot;http://hackage.haskell.org/package/auto&quot;&gt;on hackage&lt;/a&gt;. &lt;em&gt;auto&lt;/em&gt; is suitable when your program involves an input or output that is a discrete stream of things — events, views, etc., like turn based games, GUI’s, numerical computations…; it allows you to state (possibly cyclic) complex relationships between streams of values by composing simple, primitive ones. You can read the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/README.md&quot;&gt;README&lt;/a&gt; too for a detailed buzz-word laden exposition with nice well-commented short demos and examples, get started with &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;the tutorial&lt;/a&gt;, check out the directory of &lt;a href=&quot;https://github.com/mstksg/auto-examples&quot;&gt;sample projects&lt;/a&gt;, and even see a live running &lt;a href=&quot;http://mstksg.github.io/auto-examples/todo/&quot;&gt;todoMVC&lt;/a&gt; (&lt;a href=&quot;https://github.com/mstksg/auto-examples/blob/master/src/Todo.hs&quot;&gt;source&lt;/a&gt;) example!&lt;/p&gt;
&lt;p&gt;Over the next week or two I’m going to be breaking down real-world projects written on &lt;em&gt;auto&lt;/em&gt;, and even be talking about the design processes of programs written using &lt;em&gt;auto&lt;/em&gt;. You can follow along on &lt;a href=&quot;http://blog.jle.im/entries/series/+all-about-auto&quot;&gt;the series page&lt;/a&gt;, follow me on &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;twitter&lt;/a&gt;, or just subscribe to the &lt;a href=&quot;http://blog.jle.im/rss&quot;&gt;rss feed&lt;/a&gt; feed; expect a post on designing, from start to finish,&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;A fully running chat bot&lt;/li&gt;
&lt;li&gt;A GUI-based todo app on ghcjs&lt;/li&gt;
&lt;li&gt;A text-based adventure game a la the classic &lt;a href=&quot;http://en.wikipedia.org/wiki/Rogue_%28video_game%29&quot;&gt;rogue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A numerical computation DSL&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But enough of that…what is &lt;em&gt;auto&lt;/em&gt;, why does it exist, and what are its design principles?&lt;/p&gt;
&lt;h2 id=&quot;auto&quot;&gt;Auto&lt;/h2&gt;
&lt;h3 id=&quot;on-state&quot;&gt;on State&lt;/h3&gt;
&lt;p&gt;I designed &lt;em&gt;auto&lt;/em&gt; because there really aren’t any good solutions in Haskell for declaratively describing locally stateful programs in a compositional way. And a lack of denotational semantics to reason with them.&lt;/p&gt;
&lt;p&gt;The go-to implementation for a turn-based game is to have a “giant state monad”. It is a clever “hack”, but really, all we’ve done is began programming a game with &lt;em&gt;global mutable state&lt;/em&gt;. People have tried getting over this by using lenses and zoomers, but this processes doesn’t quite scale.&lt;/p&gt;
&lt;p&gt;Even now many games, GUI’s, numerical computations, etc. are written as folds or state compositions over a giant state. Surely there is a better way?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;auto&lt;/em&gt; provides denotational semantics for the composition and transformation of &lt;em&gt;stream transformers&lt;/em&gt;. At a high level, it is an example of “locally stateful programming”. Each component and stream transformer really operates as its own entity, separate from the world, in a composable way. Typical programs involve building a (possibly cyclic) graph of &lt;em&gt;relationships&lt;/em&gt; between quantities over a stream.&lt;/p&gt;
&lt;p&gt;Composing two transformers side-by-side or end-to-end creates a new transformer…and the state of each trasnformer is “closed off” from the other and the rest of the world.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;sumAndProduct &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    sums  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; sumFrom &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x
    prods &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; productFrom &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x
    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; sums &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; prods&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;sumFrom 0&lt;/code&gt; denotes a relationship between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;sums&lt;/code&gt; such that &lt;code&gt;sums&lt;/code&gt; is the cumulative sum of all &lt;code&gt;x&lt;/code&gt;’s seen. &lt;code&gt;productFrom 1&lt;/code&gt; denotes a relationship between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;prods&lt;/code&gt; that &lt;code&gt;prods&lt;/code&gt; is the cumulative product of all &lt;code&gt;x&lt;/code&gt;s seen. With &lt;code&gt;sumAndProduct&lt;/code&gt;, we &lt;em&gt;built&lt;/em&gt; a new relationship — the output is the sum of the cumulative sum and the cumulative product of the inputs — by composing two primitives.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- running our Autos over the stream [1..10] to get a new stream&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; streamAuto&amp;#39; (sumFrom &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;]
[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;21&lt;/span&gt;,  &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;36&lt;/span&gt;,    &lt;span class=&quot;dv&quot;&gt;45&lt;/span&gt;,     &lt;span class=&quot;dv&quot;&gt;55&lt;/span&gt;]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; streamAuto&amp;#39; (productFrom &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;]
[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;120&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;720&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5040&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;40320&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;362880&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3628800&lt;/span&gt;]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; streamAuto&amp;#39; sumAndProduct [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;]
[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;34&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;135&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;741&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5068&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;40356&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;362925&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3628855&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each of them maintain their own “state”…and even &lt;code&gt;sumAndProduct&lt;/code&gt; will maintain its own internal state as you compose it with other things.&lt;/p&gt;
&lt;p&gt;You build complex programs. For games, you might have an enemy monster, or a player character…why should a player character’s update be able to access the state of the enemy monster? Why should the enemy monster be able to access the state of the player? Now, the enemy monster’s state is only accessible to the enemy monster itself…nobody else can touch it.&lt;/p&gt;
&lt;p&gt;In my opinion, this really is the only sane way to have stateful loops. Separate out your update into the composition of primitives, and describe it using denotative, pure &lt;em&gt;relationships&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&quot;on-architecture&quot;&gt;on Architecture&lt;/h2&gt;
&lt;p&gt;Using &lt;em&gt;auto&lt;/em&gt;, your entire program is structured as a stream transformer, built from the composition of smaller primitives, and using the various combinators and semantic streams of the library.&lt;/p&gt;
&lt;p&gt;In the end, “running” it is simply gathering the input one at a time, pushing it through, and acting on the result.&lt;/p&gt;
&lt;p&gt;For example, in the &lt;a href=&quot;http://mstksg.github.io/auto-examples/todo/&quot;&gt;todo example&lt;/a&gt;, the entire application is just one &lt;code&gt;Auto&lt;/code&gt; that takes a stream of input commands and outputs a stream of output GUI views. It’s launch so that the &lt;code&gt;Auto&lt;/code&gt; waits on a &lt;code&gt;Chan&lt;/code&gt; queue to consume inputs as they come in. All the javascript front-end has to do is render the output gui view, and hook up the DOM elements to trigger events that add new inputs to the queue. That’s it!&lt;/p&gt;
&lt;p&gt;How do we build that &lt;code&gt;Auto&lt;/code&gt;? By composing smaller, simpler ones. Each denoting their own relationship, each keeping track of their state locally. The “full GUI state” never &lt;em&gt;exists&lt;/em&gt; anywhere…it is aggregated during composition.&lt;/p&gt;
&lt;p&gt;By the way, &lt;em&gt;auto&lt;/em&gt; does allow you to take “snap shots” of the actual states of &lt;code&gt;Auto&lt;/code&gt;s as they are run, as a binary…so you can serialize, freeze, and resume &lt;code&gt;Auto&lt;/code&gt;s from any previous state at-will. Free undos, &lt;em&gt;free save states&lt;/em&gt;. And this serialization &lt;strong&gt;composes&lt;/strong&gt;, so the combination of two serialized &lt;code&gt;Auto&lt;/code&gt;s with internal state will also be serialized appropriately.&lt;/p&gt;
&lt;h3 id=&quot;on-comparisons&quot;&gt;on Comparisons&lt;/h3&gt;
&lt;p&gt;Throughout its development &lt;em&gt;auto&lt;/em&gt; has been compared to FRP libraries like netwire. A full address of this comparison is offered on &lt;a href=&quot;https://github.com/mstksg/auto#relation-to-frp&quot;&gt;the readme&lt;/a&gt;. The main difference is that FRP offers an expressive language for working with, manipulating, and transforming continuous-time behaviors. &lt;em&gt;auto&lt;/em&gt; borrows some aspects of FRP as well as some practical API aspects in order to build something separate, manipulating and transforming causal (discrete) streams. There are many situations where FRP is not quite suited — it’d be like using a vector art program to describe a bitmap. There are domains where &lt;em&gt;auto&lt;/em&gt; is not suited — that is, the semantic model doesn’t allow you to say anything meaningful about continuous time behaviors.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;auto&lt;/em&gt; has also been compared to pipes and conduit, but there are some major differences in design and philosophy. pipes is a more general-purpose co-routine library with an emphasis on being able to apply equational reasoning to many different domains. conduit focuses around the problem of effective streaming with resource management. Both work “sources” that come from underlying monads like IO; &lt;em&gt;auto&lt;/em&gt; discourages this except for disciplined exceptions, and it’s definitely not the norm. &lt;em&gt;auto&lt;/em&gt; works as &lt;em&gt;value stream transformers&lt;/em&gt;, working with “pure” one-by-one transformations on streams of &lt;em&gt;values&lt;/em&gt;; pipes and conduit provide &lt;em&gt;effect stream manipulators&lt;/em&gt;, managing streams of &lt;em&gt;effects&lt;/em&gt; in constant space, with resource management, etc…and often involving output effects as a result (“consumers”).&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;on-the-future&quot;&gt;on the Future&lt;/h2&gt;
&lt;p&gt;So, I’ll be using this blog to post complete walk-throughs on designing specific apps like the ones in the &lt;a href=&quot;https://github.com/mstksg/auto-examples&quot;&gt;examples&lt;/a&gt; repo. Along the way hopefully some general design principles will become apparent, too. I’ve been working on this library and have been writing “real world” code for it for almost a year now, so I have some experience with design practices and patterns that work and don’t work.&lt;/p&gt;
&lt;p&gt;For now, you can try reading over the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;tutorial&lt;/a&gt; if you want, or peruse the &lt;a href=&quot;https://github.com/mstksg/auto-examples&quot;&gt;examples&lt;/a&gt; repo!&lt;/p&gt;
&lt;p&gt;Also, I definitely welcome any criticism on the design of the library or the semantic model, or of its use cases. I’ve been more or less working on this alone for almost a year, so now is the time for any delusions of mine to be vetted out in public!&lt;/p&gt;
&lt;h3 id=&quot;on-support&quot;&gt;on Support&lt;/h3&gt;
&lt;p&gt;For now, the official support channel is &lt;em&gt;#haskell-auto&lt;/em&gt; on freenode (I’m &lt;em&gt;jle`&lt;/em&gt;), but you can always use the &lt;a href=&quot;https://github.com/mstksg/issues&quot;&gt;issue tracker&lt;/a&gt; too, &lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
h=&#39;&amp;#106;&amp;#108;&amp;#x65;&amp;#46;&amp;#x69;&amp;#x6d;&#39;;a=&#39;&amp;#64;&#39;;n=&#39;&amp;#106;&amp;#x75;&amp;#x73;&amp;#116;&amp;#x69;&amp;#110;&#39;;e=n+a+h;
document.write(&#39;&lt;a h&#39;+&#39;ref&#39;+&#39;=&quot;ma&#39;+&#39;ilto&#39;+&#39;:&#39;+e+&#39;&quot; clas&#39;+&#39;s=&quot;em&#39; + &#39;ail&quot;&gt;&#39;+&#39;&amp;#x65;&amp;#x6d;&amp;#x61;&amp;#x69;&amp;#108;&amp;#32;&amp;#x6d;&amp;#x65;&#39;+&#39;&lt;\/&#39;+&#39;a&#39;+&#39;&gt;&#39;);
// --&gt;
&lt;/script&gt;&lt;noscript&gt;&amp;#x65;&amp;#x6d;&amp;#x61;&amp;#x69;&amp;#108;&amp;#32;&amp;#x6d;&amp;#x65;&amp;#32;&amp;#40;&amp;#106;&amp;#x75;&amp;#x73;&amp;#116;&amp;#x69;&amp;#110;&amp;#32;&amp;#x61;&amp;#116;&amp;#32;&amp;#106;&amp;#108;&amp;#x65;&amp;#32;&amp;#100;&amp;#x6f;&amp;#116;&amp;#32;&amp;#x69;&amp;#x6d;&amp;#x29;&lt;/noscript&gt;, or find me on twitter as &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;mstk&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All this being said, &lt;em&gt;auto&lt;/em&gt; is still kind of technically in a sorta pre-release state, because not all of the tests are written yet. But the API should be stable and updates before &lt;code&gt;0.3.x&lt;/code&gt; are going to all be backwards compatible (API-wise) bug fixes or filling in holes.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;One could still use a subset of pipes that does not stream effects, but merely values, and &lt;em&gt;that&lt;/em&gt; does somewhat fill a similar role; this is used in the &lt;a href=&quot;https://hackage.haskell.org/package/mvc&quot;&gt;mvc&lt;/a&gt; library to build similar applications that &lt;em&gt;auto&lt;/em&gt; tries to build. However, due to mvc’s “global state” nature, you lose many of the local statefulness idioms in &lt;em&gt;auto&lt;/em&gt;, and a lot of &lt;em&gt;auto&lt;/em&gt;’s benefits and design philosophies go away, for other reasons as well.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><category>Projects</category><category>Auto</category><guid isPermaLink="true">http://blog.jle.im/entry/introducing-the-auto-library.html</guid><pubDate>Tue, 24 Mar 2015 17:30:57 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings, Projects, Auto</dc:subject><dc:date>2015-03-24</dc:date></item><item><title>Effectful, Recursive, Real-World Autos: Intro to Machine/Auto Part 3</title><link>http://blog.jle.im/entry/effectful-recursive-real-world-autos-intro-to-machine.html</link><description>&lt;p&gt;Hi! I have to apologize a bit for the long delay; starting grad school and things like that have made me have to scramble to adjust to the new life. But a couple of people have asked me to finish up and wrap up this series, and I think I owe it to them then :) Welcome to the final chapter.&lt;/p&gt;
&lt;p&gt;In the &lt;a href=&quot;http://blog.jle.im/entry/auto-as-category-applicative-arrow-intro-to-machines&quot;&gt;last post&lt;/a&gt;, we looked deeper into the Auto type, played around with instancing it as familiar typeclasses, saw it as a member of the powerful &lt;em&gt;Category&lt;/em&gt; and &lt;em&gt;Arrow&lt;/em&gt; typeclasses, and took advantage of this by composing Autos both manually and using proc/do notation, and were freed from the murk and mire of explicit recursion. We observed the special nature of this composition, and saw some neat properties, like local statefulness.&lt;/p&gt;
&lt;p&gt;At this point I consider most of the important concepts about working with &lt;code&gt;Auto&lt;/code&gt; covered, but now, we are going to push this abstraction further, to the limits of real-world industrial usage. We’re going to be exploring mechanisms for adding effects and, making the plain ol’ &lt;code&gt;Auto&lt;/code&gt; into something more rich and featureful. We’ll see how to express denotative and declarative compositions using recursively binded &lt;code&gt;Auto&lt;/code&gt;s, and what that even means. It’ll be a trip down several avenues to motivate and see practical Auto usage.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; Basically, it’ll be a “final hurrah”.&lt;/p&gt;
&lt;p&gt;A fair bit of warning — if the last post is not fresh in your mind, or you still have some holes, I recommend going back and reading through them again. This one is going to hit hard and fast :) (Also, it’s admittedly kind of long for a single post, but I didn’t want to break things up into two really short parts.)&lt;/p&gt;
&lt;p&gt;As always, feel free to leave a comment if you have any questions, drop by freenode’s &lt;em&gt;#haskell&lt;/em&gt;, or find me on &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;twitter&lt;/a&gt; :)&lt;/p&gt;
&lt;p&gt;All of the code in this post is &lt;a href=&quot;http://blog.jle.im/source/code-samples/machines&quot;&gt;available for download&lt;/a&gt; and to load up into ghci for playing along!&lt;/p&gt;
&lt;h2 id=&quot;effectful-stepping&quot;&gt;Effectful Stepping&lt;/h2&gt;
&lt;p&gt;Recall our original definition of &lt;code&gt;Auto a b&lt;/code&gt; as a newtype wrapper over a function:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (b, &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This can be read as saying, “feed the &lt;code&gt;Auto&lt;/code&gt; an &lt;code&gt;a&lt;/code&gt;, and (purely) get a resulting &lt;code&gt;b&lt;/code&gt;, and a ‘next stepper’” — the &lt;code&gt;b&lt;/code&gt; is the result, and the &lt;code&gt;Auto a b&lt;/code&gt; contains the information on how to proceed from then on.&lt;/p&gt;
&lt;p&gt;If you’ve been doing Haskell for any decent amount of time, you can probably guess what’s going to happen next!&lt;/p&gt;
&lt;p&gt;Instead of “purely” creating a naked result and a “next step”…we’re going to return it in a context.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f (b, &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What, you say? What good does that do?&lt;/p&gt;
&lt;p&gt;Well, what does returning things in a context &lt;em&gt;ever&lt;/em&gt; let you do?&lt;/p&gt;
&lt;p&gt;In Haskell, contexts like these are usually meant to be able to defer the process of “getting the value” until the end, after you’ve built up your contextual computation. This process can be complicated, or simple, or trivial.&lt;/p&gt;
&lt;p&gt;For example, a function like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;means that it simply creates a &lt;code&gt;b&lt;/code&gt; from an &lt;code&gt;a&lt;/code&gt;. But a function like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;State&lt;/span&gt; s b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Means that, given an &lt;code&gt;a&lt;/code&gt;, you get a state machine that can &lt;em&gt;create a &lt;code&gt;b&lt;/code&gt;&lt;/em&gt; using a stateful process, once given an initial state. The &lt;code&gt;b&lt;/code&gt; doesn’t “exist” yet; all you’ve given is instructions for creating that &lt;code&gt;b&lt;/code&gt;…and the &lt;code&gt;b&lt;/code&gt; that is eventually created will in general depend on whatever initial &lt;code&gt;s&lt;/code&gt; you give the state machine.&lt;/p&gt;
&lt;p&gt;A function like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Means that, given an &lt;code&gt;a&lt;/code&gt;, you’re given &lt;em&gt;a computer program&lt;/em&gt; that, when executed by a computer, will generate a &lt;code&gt;b&lt;/code&gt;. The &lt;code&gt;b&lt;/code&gt; doesn’t “exist” yet; depending on how the world is and how IO processes interact, how you are feeling that day…the &lt;code&gt;b&lt;/code&gt; generated will be different. The process of IO execution has the ability to &lt;em&gt;choose&lt;/em&gt; the &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So how about something like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;State&lt;/span&gt; s (b, &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that, given &lt;code&gt;a&lt;/code&gt;, “running” the &lt;code&gt;Auto&lt;/code&gt; with an &lt;code&gt;a&lt;/code&gt; will give you &lt;em&gt;a state machine&lt;/em&gt; that gives you, using a stateful process, both the &lt;em&gt;result&lt;/em&gt; and the &lt;em&gt;next step&lt;/em&gt;. The crazy thing is that now you are given the state machine &lt;em&gt;the ability to decide the next &lt;code&gt;Auto&lt;/code&gt;&lt;/em&gt;, the next “step”.&lt;/p&gt;
&lt;p&gt;Something like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (b, &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;means that your new &lt;code&gt;Auto&lt;/code&gt;-running function will give you a result and a “next step” that is going to be dependent on IO actions.&lt;/p&gt;
&lt;p&gt;Let’s jump straight to abstracting over this and explore a new type, shall we?&lt;/p&gt;
&lt;h3 id=&quot;monadic-auto&quot;&gt;Monadic Auto&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L27-27&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m a b &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; runAutoM ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (b, &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m a b) }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We already explained earlier the new power of this type. Let’s see if we can write our favorite instances with it. First of all, what would a &lt;code&gt;Category&lt;/code&gt; instance even do?&lt;/p&gt;
&lt;p&gt;Recall that the previous &lt;code&gt;Category&lt;/code&gt; instance “ticked” each &lt;code&gt;Auto&lt;/code&gt; one after the other and gave the final results, and then the “next Auto” was the compositions of the ticked autos.&lt;/p&gt;
&lt;p&gt;In our new type, the “ticking” happens &lt;em&gt;in a context&lt;/em&gt;. And we need to tick twice; and the second one is dependent on the result of the first. This means that your context has to be &lt;em&gt;monadic&lt;/em&gt; in order to allow you to do this.&lt;/p&gt;
&lt;p&gt;So we sequence two “ticks” inside the monadic context, and then return the result afterwards, with the new composed autos.&lt;/p&gt;
&lt;p&gt;The neat thing is that Haskell’s built-in syntax for handling monadic sequencing is nice, so you might be surprised when you write the &lt;code&gt;Category&lt;/code&gt; instance:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L43-48&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Category&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    id    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; return (x, id)
    g &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
              (y, f&amp;#39;) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; runAutoM f x
              (z, g&amp;#39;) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; runAutoM g y
              return (z, g&amp;#39; &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; f&amp;#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Does it look familiar?&lt;/p&gt;
&lt;p&gt;It should! Remember the logic from the &lt;code&gt;Auto&lt;/code&gt; Category instance?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L13-18&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Category&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    id    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (x, id)
    g &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
              &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, f&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAuto f x
                  (z, g&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAuto g y
              &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (z, g&amp;#39; &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; f&amp;#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It’s basically &lt;em&gt;identical&lt;/em&gt; and exactly the same :O The only difference is that instead of &lt;code&gt;let&lt;/code&gt;, we have &lt;code&gt;do&lt;/code&gt;…instead of &lt;code&gt;=&lt;/code&gt; we have &lt;code&gt;&amp;lt;-&lt;/code&gt;, and instead of &lt;code&gt;in&lt;/code&gt; we have &lt;code&gt;return&lt;/code&gt;. :O&lt;/p&gt;
&lt;p&gt;The takeaway here is that when you have monadic functions, their sequencing and application and composition can really be abstracted away to look pretty much like application and composition of normal values. And Haskell is one of the few languages that gives you language features and a culture to be able to fully realize the symmetry and similarities.&lt;/p&gt;
&lt;p&gt;Check out the &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Arrow&lt;/code&gt; instances, too — they’re exactly the same!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L20-47&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; r) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fmap f a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                 &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, a&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAuto a x
                 &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (f y, fmap f a&amp;#39;)

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Arrow&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    arr f     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (f x, arr f)
    first a   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \(x, z) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, a&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAuto a x
                  &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  ((y, z), first a&amp;#39;)
    second a  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \(z, x) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, a&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAuto a x
                  &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  ((z, y), second a&amp;#39;)
    a1 &lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; a2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \(x1, x2) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y1, a1&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAuto a1 x1
                      (y2, a2&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAuto a2 x2
                  &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  ((y1, y2), a1&amp;#39; &lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; a2&amp;#39;)
    a1 &lt;span class=&quot;fu&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/span&gt; a2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y1, a1&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAuto a1 x
                      (y2, a2&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAuto a2 x
                  &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  ((y1, y2), a1&amp;#39; &lt;span class=&quot;fu&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/span&gt; a2&amp;#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L50-77&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m r) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fmap f a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
                 (y, a&amp;#39;) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; runAutoM a x
                 return (f y, fmap f a&amp;#39;)

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Arrow&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    arr f     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; return (f x, arr f)
    first a   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \(x, z) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
                  (y, a&amp;#39;) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; runAutoM a x
                  return ((y, z), first a&amp;#39;)
    second a  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \(z, x) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
                  (y, a&amp;#39;) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; runAutoM a x
                  return ((z, y), second a&amp;#39;)
    a1 &lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; a2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \(x1, x2) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
                  (y1, a1&amp;#39;) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; runAutoM a1 x1
                  (y2, a2&amp;#39;) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; runAutoM a2 x2
                  return ((y1, y2), a1&amp;#39; &lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; a2&amp;#39;)
    a1 &lt;span class=&quot;fu&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/span&gt; a2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
                  (y1, a1&amp;#39;) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; runAutoM a1 x
                  (y2, a2&amp;#39;) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; runAutoM a2 x
                  return ((y1, y2), a1&amp;#39; &lt;span class=&quot;fu&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/span&gt; a2&amp;#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(I’ve left the rest of the instances from the previous part as an exercise; the solutions are available in the downloadable.)&lt;/p&gt;
&lt;p&gt;Neat, huh? Instead of having to learn over again the logic of &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Applicative&lt;/code&gt;, &lt;code&gt;Arrow&lt;/code&gt;, &lt;code&gt;ArrowPlus&lt;/code&gt;, etc., you can directly use the intuition that you gained from the past part and apply it to here, if you abstract away function application and composition to application and composition in a context.&lt;/p&gt;
&lt;p&gt;Our previous instances were then just a “specialized” version of &lt;code&gt;AutoM&lt;/code&gt;, one where we used naked application and composition,&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you look at the instances we wrote out, you might see that for some of them, &lt;code&gt;Monad&lt;/code&gt; is a bit overkill. For example, for the &lt;code&gt;Functor&lt;/code&gt; instance,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m r) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fmap f a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; (f &lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; fmap f) &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; runAutoM a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is just fine. We only need &lt;code&gt;Functor&lt;/code&gt; to make &lt;code&gt;AutoM m r&lt;/code&gt; a &lt;code&gt;Functor&lt;/code&gt;. Cool, right?&lt;/p&gt;
&lt;p&gt;If you try, how much can we “generalize” our other instances to? Which ones can be generalized to &lt;code&gt;Functor&lt;/code&gt;, which ones &lt;code&gt;Applicative&lt;/code&gt;…and which ones can’t?&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;By the way, it might be worth noting that our original &lt;code&gt;Auto&lt;/code&gt; type is identical to &lt;code&gt;AutoM Identity&lt;/code&gt; — all of the instances do the exact same thing.&lt;/p&gt;
&lt;h3 id=&quot;putting-it-to-use&quot;&gt;Putting it to use&lt;/h3&gt;
&lt;p&gt;Now let’s try using these!&lt;/p&gt;
&lt;p&gt;First some utility functions just for playing around: &lt;code&gt;autoM&lt;/code&gt;, which upgrades an &lt;code&gt;Auto a b&lt;/code&gt; to an &lt;code&gt;AutoM m a b&lt;/code&gt; for any &lt;code&gt;Monad&lt;/code&gt; &lt;code&gt;m&lt;/code&gt;&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;, and &lt;code&gt;arrM&lt;/code&gt;, which is like &lt;code&gt;arr&lt;/code&gt;, but instead of turning an &lt;code&gt;a -&amp;gt; b&lt;/code&gt; into an &lt;code&gt;Auto a b&lt;/code&gt;, it turns an &lt;code&gt;a -&amp;gt; m b&lt;/code&gt; into an &lt;code&gt;AutoM m a b&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L97-107&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;autoM ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m a b
autoM a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, a&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAuto a x
                         &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  return (y, autoM a&amp;#39;)

&lt;span class=&quot;ot&quot;&gt;arrM ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m a b
arrM f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
                    y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; f x
                    return (y, arrM f)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We will need to of course re-write our trusty &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L17-25&quot;&gt;&lt;code&gt;testAuto&lt;/code&gt;&lt;/a&gt; functions from the first entry, which is again a direct translation of the original ones:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L31-39&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;testAutoM ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m ([b], &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m a b)
testAutoM a []      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; return ([], a)
testAutoM a (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    (y , a&amp;#39; ) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; runAutoM a x
    (ys, a&amp;#39;&amp;#39;) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; testAutoM a&amp;#39; xs
    return (y&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ys, a&amp;#39;&amp;#39;)

&lt;span class=&quot;ot&quot;&gt;testAutoM_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m [b]
testAutoM_ a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftM fst &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; testAutoM a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;First, let’s test &lt;code&gt;arrM&lt;/code&gt; —&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t arrM putStrLn
arrM&lt;span class=&quot;ot&quot;&gt; putStrLn ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; ()
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; res &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; testAutoM_ (arrM putStrLn) [&lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt;]
&lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; res
[(), ()]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;arrM putStrLn&lt;/code&gt; is, like &lt;code&gt;arr show&lt;/code&gt;, just an &lt;code&gt;Auto&lt;/code&gt; with no internal state. It outputs &lt;code&gt;()&lt;/code&gt; for every single input string, except, in the process of getting the “next Auto” (and producing the &lt;code&gt;()&lt;/code&gt;), it emits a side-effect — in our case, printing the string.&lt;/p&gt;
&lt;h4 id=&quot;in-io&quot;&gt;in IO&lt;/h4&gt;
&lt;p&gt;We can sort of abuse this to get an &lt;code&gt;Auto&lt;/code&gt; with “two input streams”: one from the normal input, and the other from &lt;code&gt;IO&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L119-123&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;replicateGets ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
replicateGets &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    ioString &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; arrM (\_ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; getLine) &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; ()
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; inpStr &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; concat (replicate n ioString)
    autoM monoidAccum &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inpStr&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, &lt;code&gt;replicateGets&lt;/code&gt; uses &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L106-107&quot;&gt;&lt;code&gt;monoidAccum&lt;/code&gt;&lt;/a&gt; (or, an &lt;code&gt;AutoM&lt;/code&gt; version) to accumulate a string. At every step, it adds &lt;code&gt;inpStr&lt;/code&gt; to the running accumulated string. &lt;code&gt;inpStr&lt;/code&gt; is the result of repeating the the string that &lt;code&gt;getLine&lt;/code&gt; returns replicated &lt;code&gt;n&lt;/code&gt; times — &lt;code&gt;n&lt;/code&gt; being the official “input” to the &lt;code&gt;AutoM&lt;/code&gt; when we eventually run it.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; testAutoM_ replicateGets [&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;]
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; world
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; bye
[ &lt;span class=&quot;st&quot;&gt;&amp;quot;hellohellohello&amp;quot;&lt;/span&gt;         &lt;span class=&quot;co&quot;&gt;-- added &amp;quot;hello&amp;quot; three times&lt;/span&gt;
, &lt;span class=&quot;st&quot;&gt;&amp;quot;hellohellohelloworld&amp;quot;&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;-- added &amp;quot;world&amp;quot; once&lt;/span&gt;
, &lt;span class=&quot;st&quot;&gt;&amp;quot;hellohellohelloworldbyebyebyebyebye&amp;quot;&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;-- added &amp;quot;bye&amp;quot; five times&lt;/span&gt;
]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, we used &lt;code&gt;IO&lt;/code&gt; to get a “side channel input”. The main input is the number of times we repeat the string, and the side input is what we get from sequencing the &lt;code&gt;getLine&lt;/code&gt; effect.&lt;/p&gt;
&lt;p&gt;You can also use this to “tack on” effects into your pipeline.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L127-131&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;logging ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt; b &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; a b
logging a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; autoM a &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x
    arrM (appendFile &lt;span class=&quot;st&quot;&gt;&amp;quot;log.txt&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; show y &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;
    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; y&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, &lt;code&gt;logging a&lt;/code&gt; will “run” &lt;code&gt;a&lt;/code&gt; with the input like normal (no side-channel inputs), but then also log the results line-by-line to &lt;em&gt;log.txt&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; testAutoM_ (logging summer) [&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]
[&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; putStrLn &lt;span class=&quot;fu&quot;&gt;=&amp;lt;&amp;lt;&lt;/span&gt; readFile &lt;span class=&quot;st&quot;&gt;&amp;quot;log.txt&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(By the way, as a side note, &lt;code&gt;logging :: Auto a b -&amp;gt; AutoM IO a b&lt;/code&gt; here can be looked at as an “&lt;code&gt;Auto&lt;/code&gt; transformer”. It takes a normal &lt;code&gt;Auto&lt;/code&gt; and transforms it into an otherwise identical &lt;code&gt;Auto&lt;/code&gt;, yet which logs its results as it ticks on.)&lt;/p&gt;
&lt;h4 id=&quot;motivations&quot;&gt;Motivations&lt;/h4&gt;
&lt;p&gt;At this point, hopefully you are either excited about the possibilities that monadic &lt;code&gt;Auto&lt;/code&gt; composition/ticking offers, or are horribly revolted at how we mixed IO and unconstrained effects and “implicit side channel” inputs. Or both!&lt;/p&gt;
&lt;p&gt;After all, if all we were doing in &lt;code&gt;replicateGets&lt;/code&gt; was having two inputs, we could have just used:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;replicateGets&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And have the user “get” the string before they run the &lt;code&gt;Auto&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And hey, if all we were doing in &lt;code&gt;logging&lt;/code&gt; was having an extra logging channel, we could have just manually logged all of the outputs as they popped out.&lt;/p&gt;
&lt;p&gt;All valid suggestions. Separate the pure from the impure. We went out of our way to avoid &lt;em&gt;global&lt;/em&gt; states and side-effects, so why bother to bring it all back?&lt;/p&gt;
&lt;p&gt;Superficially, it might seem like just moving the burden from one place to the other. Instead of having the user having to worry about getting the string, or writing the log, the &lt;code&gt;Auto&lt;/code&gt; can just handle it itself internally without the “running” code having to worry.&lt;/p&gt;
&lt;p&gt;The real, deep advantage in &lt;code&gt;AutoM&lt;/code&gt;, however, is — like in &lt;code&gt;Auto&lt;/code&gt; — its (literal) &lt;em&gt;composability&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Imagine &lt;code&gt;replicateGets&#39;&lt;/code&gt; was not our “final &lt;code&gt;Auto&lt;/code&gt;” that we run…imagine it was in fact an &lt;code&gt;Auto&lt;/code&gt; used in a composition inside the definition of an &lt;code&gt;Auto&lt;/code&gt; used several times inside a composition inside the definition of another &lt;code&gt;Auto&lt;/code&gt;. All of a sudden, having to “manually thread” the extra channel of input in is a real nightmare. In addition, you can’t even statically guarantee that the &lt;code&gt;String&lt;/code&gt; &lt;code&gt;replicateGets&lt;/code&gt; eventually was the same &lt;code&gt;String&lt;/code&gt; that the user originally passed in. When composing/calling it, who knows if the Auto that composes &lt;code&gt;replicateGets&#39;&lt;/code&gt; passes in the same initially gotten String?&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Imagine that the &lt;code&gt;Auto&lt;/code&gt; whose results we wanted to log actually was not the final output of the entire &lt;code&gt;Auto&lt;/code&gt; we run (maybe we want to log a small internal portion of a big &lt;code&gt;Auto&lt;/code&gt;). Again, now you have to manually thread the &lt;em&gt;output&lt;/em&gt;. And if you’re logging several things through several layers — it gets ugly very fast.&lt;/p&gt;
&lt;p&gt;And now, all of your other &lt;code&gt;Auto&lt;/code&gt;s in the composition get to (and &lt;em&gt;have&lt;/em&gt; to) see the values of the log! So much for “locally stateful”!&lt;/p&gt;
&lt;p&gt;As you can see, there is a trade-off in either decision we make. But these monadic compositions really just give us another tool in our toolset that we can (judiciously) use.&lt;/p&gt;
&lt;h4 id=&quot;other-contexts&quot;&gt;Other contexts&lt;/h4&gt;
&lt;p&gt;It’s fun to imagine what sort of implications the different popular monads in Haskell can provide. &lt;code&gt;Writer&lt;/code&gt; gives you a running log that all &lt;code&gt;Auto&lt;/code&gt;s can append to, for example. &lt;code&gt;Reader&lt;/code&gt; gives you every composed &lt;code&gt;Auto&lt;/code&gt; the ability to access a shared global environment…and has an advantage over manual “passing in” of parameters because every composed &lt;code&gt;Auto&lt;/code&gt; is guaranteed to “see” the same global environment per tick.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;State&lt;/code&gt; gives every composed &lt;code&gt;Auto&lt;/code&gt; the ability to access and modify a globally shared state. We talk a lot about every &lt;code&gt;Auto&lt;/code&gt; having their own local, internal state; usually, it is impossible for two composed &lt;code&gt;Auto&lt;/code&gt;s to directly access each other’s state (except by communicating through output and input). With &lt;code&gt;State&lt;/code&gt;, we now give the opportunity for every &lt;code&gt;Auto&lt;/code&gt; to share and modify a collective and global state, which they can use to determine how to proceed, etc.&lt;/p&gt;
&lt;p&gt;Good? Bad? Uncontrollable, unpredictable? Perhaps. You now bring in all of the problems of shared state and reasoning with shared mutable state…and avoiding these problems was one of the things that originally motivated the usage of &lt;code&gt;Auto&lt;/code&gt; in the first place! But, we can make sound and judicious decisions without resorting to “never do this” dogma.&lt;a href=&quot;#fn5&quot; class=&quot;footnoteRef&quot; id=&quot;fnref5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; Remember, these are just tools we can possibly explore. Whether or not they work in the real world — or whether or not they are self-defeating — is a complex story!&lt;/p&gt;
&lt;h4 id=&quot;in-state&quot;&gt;in State&lt;/h4&gt;
&lt;p&gt;Here is a toy state example to demonstrate different autos talking to each other; here, the state is a measure of “fuel”; we can take any &lt;code&gt;Auto a b&lt;/code&gt; and give it a “cost” using the &lt;code&gt;limit&lt;/code&gt; function defined here. Here, every &lt;code&gt;Auto&lt;/code&gt; consumes fuel from the same pool, given at the initial &lt;code&gt;runState&lt;/code&gt; running.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L139-175&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;limit ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;) a (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b)
limit cost a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    fuel &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; arrM (\_ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; get) &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; ()
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; fuel &lt;span class=&quot;fu&quot;&gt;&amp;gt;=&lt;/span&gt; cost
      &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
        arrM (\_ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; modify (subtract cost)) &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; ()
        y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; autoM a &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x
        id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; y
      &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
        id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;sumSqDiff ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
sumSqDiff &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
  sums   &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; fromMaybe &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; limit &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; summer &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x
  sumSqs &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; fromMaybe &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; limit &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; summer &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
  id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; sumSqs &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; sums

&lt;span class=&quot;ot&quot;&gt;stuff ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
stuff &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    doubled &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; limit &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
    tripled &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; even x
                 &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; limit &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
                 &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; id         &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)
    sumSqD  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; sumSqDiff &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x
    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (doubled, tripled, sumSqD)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- a State machine returning the result and the next Auto&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; stuffState  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAutoM stuff &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- a State machine returning the result&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; stuffState_ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fst &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; stuffState
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t stuffState_
&lt;span class=&quot;ot&quot;&gt;stuffState_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;co&quot;&gt;-- start with 10 fuel&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runState stuffState_ &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
((&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;),   &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)        &lt;span class=&quot;co&quot;&gt;-- end up with 3 fuel left&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- start with 2 fuel&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runState stuffState_ &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
((&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;),   &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)        &lt;span class=&quot;co&quot;&gt;-- poop out halfway&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can see that an initial round with an even number should cost you seven fuel…if you can get to the end. In the case where we only started with two fuel, we only were able to get to the “doubled” part before running out of fuel.&lt;/p&gt;
&lt;p&gt;Let’s see what happens if we run it several times:&lt;/p&gt;
&lt;pre class=&quot;hasell&quot;&gt;&lt;code&gt;ghci&amp;gt; let stuffStateMany = testAutoM_ stuff [3..6]
ghci&amp;gt; :t stuffStateMany
stuffStateMany :: State Int [(Maybe Int, Maybe Int, Int)]
ghci&amp;gt; runState stuffStateMany 9
( [ (Just 6 , Just 9 , 6 )
  , (Just 8 , Just 12, 25)
  , (Nothing, Just 15, 0 )
  , (Nothing, Nothing, 0 ) ]
, 0 )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So starting with nine fuel, we seem to run out halfway through the second step. The third field should be the sum of the squares so far, minus the sum so far…at &lt;code&gt;25&lt;/code&gt;, it’s probably just the sum of the squares so far. So it couldn’t even subtract out the sum so far. Note that the &lt;code&gt;Just 15&lt;/code&gt; on the third step goes through because for &lt;em&gt;odd&lt;/em&gt; inputs (5, in this case), the second field doesn’t require any fuel.&lt;/p&gt;
&lt;p&gt;Anyways, imagine having to thread this global state through by hand. Try it. It’d be a disaster! Everything would have to take an extra parameter and get and extra parameter…it really is quite a headache. Imagine the source for &lt;code&gt;stuff&lt;/code&gt; being written out in &lt;code&gt;Auto&lt;/code&gt; with manual state threading.&lt;/p&gt;
&lt;p&gt;But hey, if your program needs global state, then it’s probably a good sign that you might have had a design flaw somewhere along the way, right?&lt;/p&gt;
&lt;h4 id=&quot;in-reader&quot;&gt;in Reader&lt;/h4&gt;
&lt;p&gt;Here we use &lt;code&gt;Reader&lt;/code&gt; to basically give a “second argument” to an &lt;code&gt;Auto&lt;/code&gt; when we eventually run it, but we use the fact that every composed &lt;code&gt;Auto&lt;/code&gt; gets the &lt;em&gt;exact same&lt;/em&gt; input to great effect:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L199-234&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;integral ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Reader&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;
integral x0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \dx &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
                dt &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; ask
                &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x1 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x0 &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; dx &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; dt
                return (x1, integral x1)

&lt;span class=&quot;ot&quot;&gt;derivative ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Reader&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;)
derivative &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; return (&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, derivative&amp;#39; x)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
                 &lt;span class=&quot;co&quot;&gt;-- x0 is the &amp;quot;previous input&amp;quot;&lt;/span&gt;
    derivative&amp;#39; x0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x1 &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
                       &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; dx &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x1 &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; x0
                       dt &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; ask
                       return (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (dx&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;dt), derivative&amp;#39; x1)

&lt;span class=&quot;ot&quot;&gt;fancyCalculus ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Reader&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;)
fancyCalculus &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    deriv  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; fromMaybe &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; derivative &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x
    deriv2 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; fromMaybe &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; derivative &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; deriv
    intdev &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt;                 integral &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; deriv
    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (deriv2, intdev)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, we are treating our input stream as time-varying values, and the “Reader environment” contains the “time passed since the last tick” — The time step or sampling rate, so to speak, of the input stream. We have two stateful &lt;code&gt;Auto&lt;/code&gt;s (“locally stateful”, internal state) that compute the time integral and time derivative of the input stream of numbers…but in order to do so, it needs the time step. We get it using &lt;code&gt;ask&lt;/code&gt;. (Note that the time step doesn’t have to be the same between every different tick … &lt;code&gt;integral&lt;/code&gt; and &lt;code&gt;derivative&lt;/code&gt; should work just fine with a new timestep every tick.) (Also note that &lt;code&gt;derivative&lt;/code&gt; is &lt;code&gt;Nothing&lt;/code&gt; on its first step, because there is not yet any meaningful derivative on the first input)&lt;/p&gt;
&lt;p&gt;In &lt;code&gt;fancyCalculus&lt;/code&gt;, we calculate the integral, the derivative, the second derivative, and the integral of the derivative, and return the second derivative and the integral of the derivative.&lt;/p&gt;
&lt;p&gt;In order for us to even &lt;em&gt;meaningfully say&lt;/em&gt; “the second derivative” or “the integral of the derivative”, the double derivative has to be calculated with the same time step, and the integral and the derivative have to be calculated with the same time step. If they are fed different time steps, then we aren’t really calculating a real second derivative or a real integral of a derivative anymore. We’re just calculating arbitrary numbers.&lt;/p&gt;
&lt;p&gt;Anyways, if you have taken any introduction to calculus course, you’ll know that the integral of a derivative is the original function — so the integral of the derivative, if we pick the right &lt;code&gt;x0&lt;/code&gt;, should just be an “id” function:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;integral x0 &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; derivative &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; id      &lt;span class=&quot;co&quot;&gt;-- or off by a constant difference&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let’s try this out with some input streams where we know what the second derivative should be, too.&lt;/p&gt;
&lt;p&gt;We’ll try it first with &lt;code&gt;x^2&lt;/code&gt;, where we know the second derivative will just be 2, the entire time:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x2s &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; map (&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;0.05&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x2Reader &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; testAutoM_ fancyCalculus x2s
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t x2Reader
&lt;span class=&quot;ot&quot;&gt;x2Reader ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Reader&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; [(&lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;)]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; map fst (runReader x2Reader &lt;span class=&quot;fl&quot;&gt;0.05&lt;/span&gt;)
[ &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;2.0&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;2.0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt; ]    &lt;span class=&quot;co&quot;&gt;-- with a couple of &amp;quot;stabilizing&amp;quot; first terms&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; map snd (runReader x2Reader &lt;span class=&quot;fl&quot;&gt;0.05&lt;/span&gt;)
[ &lt;span class=&quot;fl&quot;&gt;0.0&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.0025&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.0225&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.04&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; x2s
[ &lt;span class=&quot;fl&quot;&gt;0.0&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.0025&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.0225&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.04&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Perfect! The second derivative we expected (all 2’s) showed up, and the integral of the derivative is pretty much exactly the original function.&lt;/p&gt;
&lt;p&gt;For fun, try running it with a &lt;code&gt;sin&lt;/code&gt; function. The second derivative of &lt;code&gt;sin&lt;/code&gt; is &lt;code&gt;netage . sin&lt;/code&gt;. Does it end up as expected?&lt;/p&gt;
&lt;p&gt;The alternative to using &lt;code&gt;AutoM&lt;/code&gt; and &lt;code&gt;Reader&lt;/code&gt; here would be to have each composed Auto be manually “passed” the &lt;code&gt;dt&lt;/code&gt; timestep. But then we really don’t have any “guarantees”, besides checking ourselves, that every &lt;code&gt;Auto&lt;/code&gt; down the road, down every composition, will have the same &lt;code&gt;dt&lt;/code&gt;. We can’t say that we really are calculating integrals or derivatives. And plus, it’s pretty messy when literally every one of your composed &lt;code&gt;Auto&lt;/code&gt; needs &lt;code&gt;dt&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;mixing-worlds&quot;&gt;Mixing Worlds&lt;/h4&gt;
&lt;p&gt;We talked about a huge drawback of &lt;code&gt;State s&lt;/code&gt; — global mutable state is really something that we originally looked to &lt;code&gt;Auto&lt;/code&gt; to avoid in the first place. But some portions of logic are much more convenient to write with autos that all have access to a global state.&lt;/p&gt;
&lt;p&gt;What if we wanted the best of both worlds? What would that look like?&lt;/p&gt;
&lt;p&gt;In Haskell, one common technique we like to use, eloquently stated by Gabriel Gonzalez in his post &lt;a href=&quot;http://www.haskellforall.com/2012/09/the-functor-design-pattern.html&quot;&gt;the Functor design pattern&lt;/a&gt;, is to pick a “common denominator” type, and push all of our other types into it.&lt;/p&gt;
&lt;p&gt;We have two fundamentally different options here. We can pick our “main type” to be &lt;code&gt;AutoM (State s)&lt;/code&gt; and have global state, and “push” all of our non-global-state Autos into it, or we can pick our “main type” to be &lt;code&gt;Auto&lt;/code&gt;, and “seal” our global-state-Autos into non-global-state ones.&lt;/p&gt;
&lt;p&gt;For the former, we’d use &lt;code&gt;autoM&lt;/code&gt;’s whenever we want to bring our &lt;code&gt;Auto&lt;/code&gt;s into &lt;code&gt;AutoM (State s)&lt;/code&gt;…or we can always write &lt;code&gt;AutoM&lt;/code&gt;’s parameterized over &lt;code&gt;m&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;summer ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m a a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It is statically guaranteed that &lt;code&gt;summer&lt;/code&gt; &lt;em&gt;cannot touch any global state&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For the latter option, we take &lt;code&gt;AutoM (State s)&lt;/code&gt;’s that operate on global state and then basically “seal off” their access to be just within their local worlds, as we turn them into &lt;code&gt;Auto&lt;/code&gt;’s.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L182-192&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;sealStateAuto ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;State&lt;/span&gt; s) a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a b
sealStateAuto a s0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                       &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; ((y, a&amp;#39;), s1) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runState (runAutoM a x) s0
                       &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (y, sealStateAuto a&amp;#39; s1)

&lt;span class=&quot;ot&quot;&gt;runStateAuto ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;State&lt;/span&gt; s) a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; (a, s) (b, s)
runStateAuto a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \(x, s) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                   &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; ((y, a&amp;#39;), s&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runState (runAutoM a x) s
                   &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  ((y, s&amp;#39;), runStateAuto a&amp;#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;sealStateAuto&lt;/code&gt; does exactly this. Give it an initial state, and the &lt;code&gt;Auto&lt;/code&gt; will just continuously feed in its output state at every tick back in as the input state. Every &lt;code&gt;Auto&lt;/code&gt; inside now has access to a local state, untouchable from the outside.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;runStateAuto&lt;/code&gt; is a way to do this were you can pass in a new initial state every time you “step” the &lt;code&gt;Auto&lt;/code&gt;, and observe how it changes — also another useful use case.&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We can even pull this trick to turn any &lt;code&gt;AutoM (StateT s m)&lt;/code&gt; into an &lt;code&gt;AutoM m&lt;/code&gt;. See if you can write it :)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;sealStateAutoM ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; s m) a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m a b
sealStateAutoM &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;runStateAutoM ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; s m) a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m (a, s) (b, s)
runStateAutoM &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;In both of these methods, what is the real win? The big deal is that you can now chose to “work only in the world of non-global-state”, combining non-global &lt;code&gt;Auto&lt;/code&gt;s like we did in part 1 and part 2 to create non-global algorithms. And then you can also chose to “work in the world of global state”, combining global &lt;code&gt;Auto&lt;/code&gt;s like we did in the previous section, where having &lt;code&gt;State s&lt;/code&gt; made everything more clear.&lt;/p&gt;
&lt;p&gt;We’re allowed to live and compose (using &lt;code&gt;Category&lt;/code&gt;, proc notation, etc.) in whatever world we like — create as complex compositions as we could even imagine — and at the end of it all, we take the final complex product and “glue it on” to our big overall type so everything can work together.&lt;/p&gt;
&lt;p&gt;This discussion is about &lt;code&gt;State&lt;/code&gt;, but the ramifications work with almost any &lt;code&gt;Auto&lt;/code&gt; or type of &lt;code&gt;Auto&lt;/code&gt; or underlying monad we talk about.&lt;/p&gt;
&lt;p&gt;We can simulate an “immutable local environment”, for example:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L248-251&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;runReaderAuto ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Reader&lt;/span&gt; r) a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; (a, r) b
runReaderAuto a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \(x, e) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, a&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runReader (runAutoM a x) e
                    &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (y, runReaderAuto a&amp;#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now you can use a &lt;code&gt;Reader&lt;/code&gt; — composed with “global environment” semantics — inside a normal &lt;code&gt;Auto&lt;/code&gt;! Just give it the new environment very step! (Can you write a &lt;code&gt;sealReaderAuto&lt;/code&gt; that just takes an initial &lt;code&gt;r&lt;/code&gt; and feeds it back in forever?)&lt;/p&gt;
&lt;h2 id=&quot;recursive-auto&quot;&gt;Recursive Auto&lt;/h2&gt;
&lt;p&gt;Let’s move back to our normal &lt;code&gt;Auto&lt;/code&gt; for now, and imagine a very common use case that might come up.&lt;/p&gt;
&lt;p&gt;What if you wanted two chained &lt;code&gt;Auto&lt;/code&gt;s to “talk to each other” — for their inputs to depend on the other’s outputs?&lt;/p&gt;
&lt;p&gt;Here’s a common example — in control theory, you often have to have adjust an input to a system to get it to “respond” to a certain desired output (a control).&lt;/p&gt;
&lt;p&gt;One way is to start with a test input, at every step, observe the resulting response and adjust it up or down until we get the response we want. We call the difference between the response and the control the “error”.&lt;/p&gt;
&lt;p&gt;How do you think you would calculate the adjustment? Well…if the error is big, we probably want a big adjustment. And, the longer we are away from the error, we also might want to make a bigger adjustment accordingly, too.&lt;/p&gt;
&lt;p&gt;In other words, we might want our adjustment to have a term &lt;em&gt;proportional&lt;/em&gt; to the error, and a term that is &lt;em&gt;the sum of all&lt;/em&gt; errors so far.&lt;/p&gt;
&lt;p&gt;This system is known as &lt;a href=&quot;http://en.wikipedia.org/wiki/PID_controller&quot;&gt;PI&lt;/a&gt;, and is actually used in many industrial control systems today, for controlling things like lasers and other super important stuff. Congrats, you are now a control theorist!&lt;/p&gt;
&lt;p&gt;Let’s see how we might write this using our &lt;code&gt;Auto&lt;/code&gt;s:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;piTargeter ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;
piTargeter &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc control &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; err &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; control &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; response
    errSums  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; summer         &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; err

    input    &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; summer         &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; err &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.01&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; errSums
    response &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; blackBoxSystem &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; input

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; response
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    blackBoxSystem &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; id     &lt;span class=&quot;co&quot;&gt;-- to simplify things :)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So this is an &lt;code&gt;Auto&lt;/code&gt; that takes in a &lt;code&gt;Double&lt;/code&gt; — the control — and outputs a &lt;code&gt;Double&lt;/code&gt; — the response. The goal is to get the response to “match” control, by running a value, &lt;code&gt;input&lt;/code&gt;, through a “black box system” (To simplify here, we’re only running &lt;code&gt;input&lt;/code&gt; through &lt;code&gt;id&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Here is the “logic”, or the relationships between the values:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;The error value &lt;code&gt;err&lt;/code&gt; is the difference between the control and the response.&lt;/li&gt;
&lt;li&gt;The sum of errors &lt;code&gt;errSums&lt;/code&gt; is the cumulative sum of all of the error values so far.&lt;/li&gt;
&lt;li&gt;The input &lt;code&gt;input&lt;/code&gt; is the cumulative sum of all of the correction terms: a multiple of &lt;code&gt;err&lt;/code&gt; and a multiple of &lt;code&gt;errSums&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The response &lt;code&gt;response&lt;/code&gt; is the result of running the input through the black box system (here, just &lt;code&gt;id&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;The output is the response!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Look at what we wrote. Isn’t it just…beautifully declarative? Elegant? All we stated were &lt;em&gt;relationships between terms&lt;/em&gt;…we didn’t worry about state, loops, variables, iterations…there is no concept of “how to update”, everything is just “how things are”. It basically popped up exactly as how we “said” it. I don’t know about you, but this demonstration always leaves me amazed, and was one of the things that sold me on this abstraction in the first place.&lt;/p&gt;
&lt;p&gt;But, do you see the problem? To calculate &lt;code&gt;err&lt;/code&gt;, we used &lt;code&gt;resp&lt;/code&gt;. But to get &lt;code&gt;resp&lt;/code&gt;, we need &lt;code&gt;err&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;We need to be able to define “recursive bindings”. Have Autos recursively depend on each other.&lt;/p&gt;
&lt;p&gt;In another language, this would be hopeless. We’d have to have to resort to keeping explicit state and using a loop. However, with Haskell…and the world of laziness, recursive bindings, and tying knots…I think that we’re going to have a &lt;em&gt;real win&lt;/em&gt; if we can make something like what we wrote work.&lt;/p&gt;
&lt;h3 id=&quot;arrowloop&quot;&gt;ArrowLoop&lt;/h3&gt;
&lt;p&gt;There is actually a construct in &lt;em&gt;proc&lt;/em&gt; notation that lets you do just that. I’m going to cut to the chase and show you how it looks, and how you use it. I’ll explain the drawbacks and caveats. And then I’ll explain how it works in an aside — it’s slightly heavy, but some people like to understand.&lt;/p&gt;
&lt;p&gt;Without further ado —&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L266-276&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;piTargeter ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;
piTargeter &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc control &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    rec &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; err &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; control &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; response
        errSums  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; summer         &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; err

        input    &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; laggingSummer  &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; err &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.01&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; errSums
        response &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; blackBoxSystem &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; input

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; response
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    blackBoxSystem &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; id     &lt;span class=&quot;co&quot;&gt;-- to simplify things :)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The key here is the &lt;em&gt;rec&lt;/em&gt; keyword. Basically, we require that we write an instance of &lt;code&gt;ArrowLoop&lt;/code&gt; for our &lt;code&gt;Auto&lt;/code&gt;…and now things can refer to each other, and it all works out like magic! Now our solution works…the feedback loop is closed with the usage of &lt;code&gt;rec&lt;/code&gt;. Now, our algorithm looks &lt;em&gt;exactly&lt;/em&gt; like how we would “declare” the relationship of all the variables. We “declare” that &lt;code&gt;err&lt;/code&gt; is the difference between the control and the response. We “declare” that &lt;code&gt;errSums&lt;/code&gt; is the cumulative sum of the error values. We “declare” that our &lt;code&gt;input&lt;/code&gt; is the cumulative sum of all of the adjustment terms. And we “declare” that our response is just the result of feeding our input through our black box.&lt;/p&gt;
&lt;p&gt;No loops. No iteration. No mutable variables. Just…a declaration of relationships.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; testAuto_ piTargeter [&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;5.01&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;]      &lt;span class=&quot;co&quot;&gt;-- vary our desired target slowly&lt;/span&gt;
[ &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;1.05&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;1.93&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;2.67&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;3.28&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;         &lt;span class=&quot;co&quot;&gt;-- &amp;quot;seeking&amp;quot;/tracking to 5&lt;/span&gt;
, &lt;span class=&quot;fl&quot;&gt;5.96&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;5.97&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;5.98&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;5.99&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;6.00&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;-- properly tracking&lt;/span&gt;
]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Perfect!&lt;/p&gt;
&lt;p&gt;Wait wait wait hold on…but how does this even work? Is this magic? Can we just throw &lt;em&gt;anything&lt;/em&gt; into a recursive binding, and expect it to magically figure out what we mean?&lt;/p&gt;
&lt;p&gt;Kinda, yes, no. This works based on Haskell’s laziness. It’s the reason something like &lt;code&gt;fix&lt;/code&gt; works:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;fix ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
fix f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f (fix f)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Infinite loop, right?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; head (fix (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;))
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fix (1:)&lt;/code&gt; is basically an infinite lists of ones. But remember that &lt;code&gt;head&lt;/code&gt; only requires the first element to be evaluated:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;head (fix (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;))
head (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; fix (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;))     &lt;span class=&quot;co&quot;&gt;-- head (x:_) = x&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So that’s the key. If what we &lt;em&gt;want&lt;/em&gt; doesn’t require the entire result of the infinite loop…then we can safely reason about infinite recursion in haskell.&lt;/p&gt;
&lt;p&gt;The MVP here really is this function that I sneakily introduced, &lt;code&gt;laggingSummer&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L258-262&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;laggingSummer ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a a
laggingSummer &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sumFrom &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    sumFrom ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a a
    sumFrom x0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (x0, sumFrom (x0 &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; x))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;laggingSummer&lt;/code&gt; is like &lt;code&gt;summer&lt;/code&gt;, except all of the sums are delayed. Every step, it adds the input to the accumulator…but returns the accumulator &lt;em&gt;before&lt;/em&gt; the addition. Sort of like &lt;code&gt;x++&lt;/code&gt; instead of &lt;code&gt;++x&lt;/code&gt; in C. If the accumulator is at 10, and it receives a 2, it &lt;em&gt;outputs 10&lt;/em&gt;, and &lt;em&gt;updates the accumulator to 12&lt;/em&gt;. The key is that it &lt;em&gt;doesn’t need the input&lt;/em&gt; to &lt;em&gt;immediately return that step’s output&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; testAuto_ laggingSummer [&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;]
[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;18&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;26&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;35&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The accumulator starts off at 0, and receives a 5…it then outputs 0 and updates the accumulator to 5. The accumulator then has 5 and receives a 6…it outputs 5 and then updates the accumulator to 11. Etc. The next step it would output 45 &lt;em&gt;no matter what input it gets&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Look at the definition of &lt;code&gt;piTargeter&lt;/code&gt; again. How would it get its “first value”?&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;The first output is just &lt;code&gt;response&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The first response is just the first &lt;code&gt;input&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The first &lt;code&gt;input&lt;/code&gt; is just the result of &lt;code&gt;laggingSummer&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The first result of &lt;code&gt;laggingSummer&lt;/code&gt; is 0.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And that’s it! Loop closed! The first result is zero…no infinite recursion here.&lt;/p&gt;
&lt;p&gt;Now that we know that the first result of &lt;code&gt;response&lt;/code&gt; is 0, we can also find the first values of &lt;code&gt;err&lt;/code&gt; and &lt;code&gt;errSums&lt;/code&gt;: The first &lt;code&gt;err&lt;/code&gt; is the first control (input to the &lt;code&gt;Auto&lt;/code&gt;) minus 0 (the first response), and the first &lt;code&gt;errSums&lt;/code&gt; is a cumulative sum of &lt;code&gt;errs&lt;/code&gt;, so it too starts off as the first control minus zero.&lt;/p&gt;
&lt;p&gt;So now, we have all of the first values of &lt;em&gt;all&lt;/em&gt; of our Autos. Check! Now the next step is the same thing!&lt;/p&gt;
&lt;p&gt;Recursive bindings have a lot of power in that they allow us to directly translate natural language and (cyclic) graph-like “relationships” (here, between the different values of a control system) and model them &lt;em&gt;as relationships&lt;/em&gt;. Not as loops and updates and state modifications. But &lt;em&gt;as relationships&lt;/em&gt;. Something we can &lt;em&gt;declare&lt;/em&gt;, at a high level.&lt;/p&gt;
&lt;p&gt;And that’s definitely something I would write home about.&lt;/p&gt;
&lt;p&gt;The only caveat is, of course, that we have to make sure our loop can produce a “first value” without worrying about its input. Autos like &lt;code&gt;laggingSummer&lt;/code&gt; give this to us.&lt;/p&gt;
&lt;p&gt;In the following aside, I detail the exact mechanics of how this works :)&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ah, so you’re curious? Or maybe you are just one of those people who really wants to know how things work?&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;rec&lt;/code&gt; keyword in proc/do blocks desugars to applications of a function called &lt;code&gt;loop&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Arrow&lt;/span&gt; r &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ArrowLoop&lt;/span&gt; r &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    loop ::&lt;/span&gt; r (a, c) (b, c) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r a b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type signature seems a bit funny. Loop takes a morphism from &lt;code&gt;(a, c)&lt;/code&gt; to &lt;code&gt;(b, c)&lt;/code&gt; and turns it into a morphism from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;. But…how does it do that?&lt;/p&gt;
&lt;p&gt;I’ll point you to &lt;a href=&quot;https://wiki.haskell.org/Circular_programming&quot;&gt;a whole article about the &lt;code&gt;(-&amp;gt;)&lt;/code&gt; instance of &lt;code&gt;ArrowLoop&lt;/code&gt;&lt;/a&gt; and how it is useful, if you’re interested. But we’re looking at &lt;code&gt;Auto&lt;/code&gt; for now.&lt;/p&gt;
&lt;p&gt;We can write an &lt;code&gt;ArrowLoop&lt;/code&gt; instance for &lt;code&gt;Auto&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L58-61&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ArrowLoop&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    loop a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
               &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; ((y, d), a&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAuto a (x, d)
               &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (y, loop a&amp;#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So what does this mean? When will we be able to “get a &lt;code&gt;y&lt;/code&gt;”?&lt;/p&gt;
&lt;p&gt;We will be able to get a &lt;code&gt;y&lt;/code&gt; in the case that the &lt;code&gt;Auto&lt;/code&gt; can just “pop out” your &lt;code&gt;y&lt;/code&gt; without ever evaluating its arguments…or only using &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The evaluation of &lt;code&gt;a&#39;&lt;/code&gt; is then deferred until later…and through this, everything kinda makes sense. The loop is closed. See the article linked above for more information on how &lt;code&gt;loop&lt;/code&gt; really works.&lt;/p&gt;
&lt;p&gt;The actual desugaring of a &lt;code&gt;rec&lt;/code&gt; block is a little tricky, but we can trust that if we have a properly defined &lt;code&gt;loop&lt;/code&gt; (that typechecks and has the circular dependencies that loop demands), then &lt;code&gt;ArrowLoop&lt;/code&gt; will do what it is supposed to do.&lt;/p&gt;
&lt;p&gt;In any case, we can actually understand &lt;em&gt;how to work with rec blocks&lt;/em&gt; pretty well — as long as we can have an &lt;code&gt;Auto&lt;/code&gt; in the pipeline that can pop something out immediately ignoring its input, then we can rest assured that our knot will be closed.&lt;/p&gt;
&lt;p&gt;By the way, this trick works with &lt;code&gt;ArrowM&lt;/code&gt; too — provided that the &lt;code&gt;Monad&lt;/code&gt; is an instance of &lt;code&gt;MonadFix&lt;/code&gt;, which is basically a generalization of the recursive &lt;code&gt;let&lt;/code&gt; bindings we used above:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L88-91&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadFix&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ArrowLoop&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    loop a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
               rec ((y, d), a&amp;#39;) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; runAutoM a (x, d)
               return (y, loop a&amp;#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;going-kleisli&quot;&gt;Going Kleisli&lt;/h2&gt;
&lt;p&gt;This is going to be our last “modification” to the &lt;code&gt;Auto&lt;/code&gt; type — one more common &lt;code&gt;Auto&lt;/code&gt; variation/trick that is used in real life usages of &lt;code&gt;Auto&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;inhibition&quot;&gt;Inhibition&lt;/h3&gt;
&lt;p&gt;It might some times be convenient to imagine the &lt;em&gt;results&lt;/em&gt; of the &lt;code&gt;Auto&lt;/code&gt;s coming in contexts — for example, &lt;code&gt;Maybe&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;How can we interpret/use this? In many domains, this is used to model “on/off” behavior of &lt;code&gt;Auto&lt;/code&gt;s. The &lt;code&gt;Auto&lt;/code&gt; is “on” if the output is &lt;code&gt;Just&lt;/code&gt;, and “off” if the output is &lt;code&gt;Nothing&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can imagine “baking this in” to our Auto type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L19-19&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; a b &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsOn&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; runAutoOn ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b, &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; a b) }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where the semantics of composition are: if you get a &lt;code&gt;Nothing&lt;/code&gt; as an input, just don’t tick anything and pop out a &lt;code&gt;Nothing&lt;/code&gt;; if you get a &lt;code&gt;Just x&lt;/code&gt; as an input run the auto on the &lt;code&gt;x&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L22-29&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Category&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    id    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsOn&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; x, id)
    g &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsOn&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
              &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, f&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAutoOn f x
                  (z, g&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; y &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                              &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; _y &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; runAutoOn g _y
                              &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, g)
              &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (z, g&amp;#39; &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; f&amp;#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The other instances are on the file linked above, but I won’t post them here, so you can write them as an exercise. Have fun on the &lt;code&gt;ArrowLoop&lt;/code&gt; instance!&lt;a href=&quot;#fn6&quot; class=&quot;footnoteRef&quot; id=&quot;fnref6&quot;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This aside contains category-theoretic justification for what we just did. You can feel free to skip it if you aren’t really too familiar with the bare basics of Category Theory (What an endofunctor is, for example)… but, if you are, this might be a fun perspective :)&lt;/p&gt;
&lt;p&gt;What we’ve really done here is taken a category with objects as Haskell types and morphisms are &lt;code&gt;Auto a b&lt;/code&gt;, and turned it into a category with objects as Haskell types and whose morphisms are &lt;code&gt;Auto a (m b)&lt;/code&gt;, where &lt;code&gt;m&lt;/code&gt; is a Monad.&lt;/p&gt;
&lt;p&gt;The act of forming this second category from the first is called forming the &lt;em&gt;Kleisli category&lt;/em&gt; on a category. We took &lt;code&gt;Auto&lt;/code&gt; and are now looking at the Kleisli category on &lt;code&gt;Auto&lt;/code&gt; formed by &lt;code&gt;Maybe&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;By the way, a “Monad” here is actually different from the normal &lt;code&gt;Monad&lt;/code&gt; typeclass found in standard Haskell. A Monad is an endofunctor on a category with two associated natural transformations — unit and join.&lt;/p&gt;
&lt;p&gt;Because we’re not dealing with the typical Haskell category anymore (on &lt;code&gt;(-&amp;gt;)&lt;/code&gt;), we have to rethink what we actually “have”.&lt;/p&gt;
&lt;p&gt;For any Haskell Monad, we get for free our natural transformations:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;unitA ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a (m a)
unitA &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; arr return

&lt;span class=&quot;ot&quot;&gt;joinA ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; (m (m a)) (m a)
joinA &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; arr join&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But what we &lt;em&gt;don’t get&lt;/em&gt;, necessarily, the &lt;em&gt;endofunctor&lt;/em&gt;. An endofunctor must map both objects and morphisms. A type constructor like &lt;code&gt;Maybe&lt;/code&gt; can map objects fine — we have the same objects in &lt;code&gt;Auto&lt;/code&gt; as we do in &lt;code&gt;(-&amp;gt;)&lt;/code&gt; (haskell types). But we also need the ability to map &lt;em&gt;morphisms&lt;/em&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;FunctorA&lt;/span&gt; f &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    fmapA ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; (f a) (f b)
    &lt;span class=&quot;co&quot;&gt;-- fmapA id = id&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- fmapA g . fmapA f = fmapA (g . f)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, if this function exists for a type constructor, following the usual &lt;code&gt;fmap&lt;/code&gt; laws, then that type is an endofunctor in our &lt;code&gt;Auto&lt;/code&gt; category. And if it’s also a Monad in &lt;code&gt;(-&amp;gt;)&lt;/code&gt;, then it’s also then a Monad in &lt;code&gt;Auto&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can write such an &lt;code&gt;fmapA&lt;/code&gt; for &lt;code&gt;Maybe&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;FunctorA&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fmapA a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; x &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                  &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; _x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, a&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAuto a x
                             &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; y, fmapA a&amp;#39;)
                  &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, fmapA a)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And, it is a fact that if we have a Monad, we can write the composition of its Kleisli category for free:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;(&amp;lt;~=&amp;lt;) ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;FunctorA&lt;/span&gt; f, &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; f) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a (f c) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a (f b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a (f c)
g &lt;span class=&quot;fu&quot;&gt;&amp;lt;~=&amp;lt;&lt;/span&gt; f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; joinA &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fmapA g &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; f&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In fact, for &lt;code&gt;f ~ Maybe&lt;/code&gt;, this definition is identical to the one for the &lt;code&gt;Category&lt;/code&gt; instance we wrote above for &lt;code&gt;AutoOn&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And, if the &lt;code&gt;FunctorA&lt;/code&gt; is a real functor and the &lt;code&gt;Monad&lt;/code&gt; is a real monad, then we have for free the associativity of this super-fish operator:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;(h &lt;span class=&quot;fu&quot;&gt;&amp;lt;~=&amp;lt;&lt;/span&gt; g) &lt;span class=&quot;fu&quot;&gt;&amp;lt;~=&amp;lt;&lt;/span&gt; f &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; h &lt;span class=&quot;fu&quot;&gt;&amp;lt;~=&amp;lt;&lt;/span&gt; (g &lt;span class=&quot;fu&quot;&gt;&amp;lt;~=&amp;lt;&lt;/span&gt; f)
f &lt;span class=&quot;fu&quot;&gt;&amp;lt;~=&amp;lt;&lt;/span&gt; unitA      &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; unitA &lt;span class=&quot;fu&quot;&gt;&amp;lt;~=&amp;lt;&lt;/span&gt; f      &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; f&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Category theory is neat!&lt;/p&gt;
&lt;p&gt;By the way, definitely not all endofunctors on &lt;code&gt;(-&amp;gt;)&lt;/code&gt; are endofunctors on &lt;code&gt;Auto&lt;/code&gt;. We see that &lt;code&gt;Maybe&lt;/code&gt; is one. Can you think of any others? Any others where we could write an instance of &lt;code&gt;FunctorA&lt;/code&gt; that follows the laws? Think about it, and post some in the comments!&lt;/p&gt;
&lt;p&gt;One immediate example is &lt;code&gt;Either e&lt;/code&gt;, which is used for great effect in many FRP libraries! It’s “inhibit, with a &lt;em&gt;value&lt;/em&gt;”. As an exercise, see if you can write its &lt;code&gt;FunctorA&lt;/code&gt; instance, or re-write the &lt;code&gt;AutoOn&lt;/code&gt; in this section to work with &lt;code&gt;Either e&lt;/code&gt; (you might need to impose a typeclass constraint on the &lt;code&gt;e&lt;/code&gt;) instaed of &lt;code&gt;Maybe&lt;/code&gt;!&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;I’m not going to spend too much time on this, other than saying that it is useful to imagine how it might be useful to have an “off” Auto “shut down” every next Auto in the chain.&lt;/p&gt;
&lt;p&gt;One neat thing is that &lt;code&gt;AutoOn&lt;/code&gt; admits a handy &lt;code&gt;Alternative&lt;/code&gt; instance; &lt;code&gt;a1 &amp;lt;|&amp;gt; a2&lt;/code&gt; will create a new &lt;code&gt;AutoOn&lt;/code&gt; that feeds in its input to &lt;em&gt;both&lt;/em&gt; &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt;, and the result is the first &lt;code&gt;Just&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L80-86&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Alternative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    empty     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsOn&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \_ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, empty)
    &lt;span class=&quot;co&quot;&gt;-- (&amp;lt;|&amp;gt;) :: AutoOn a b -&amp;gt; AutoOn a b -&amp;gt; AutoOn a b&lt;/span&gt;
    a1 &lt;span class=&quot;fu&quot;&gt;&amp;lt;|&amp;gt;&lt;/span&gt; a2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsOn&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y1, a1&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAutoOn a1 x
                      (y2, a2&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAutoOn a2 x
                  &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (y1 &lt;span class=&quot;fu&quot;&gt;&amp;lt;|&amp;gt;&lt;/span&gt; y2, a1&amp;#39; &lt;span class=&quot;fu&quot;&gt;&amp;lt;|&amp;gt;&lt;/span&gt; a2&amp;#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unexpectedly, we also get the handy &lt;code&gt;empty&lt;/code&gt;, which is a “always off” &lt;code&gt;AutoOn&lt;/code&gt;. Feed anything through &lt;code&gt;empty&lt;/code&gt; and it’ll produce a &lt;code&gt;Nothing&lt;/code&gt; no matter what. You can use this to provide an “always fail”, “short-circuit here” kind of composition, like &lt;code&gt;Nothing&lt;/code&gt; in the &lt;code&gt;Maybe&lt;/code&gt; monad.&lt;/p&gt;
&lt;p&gt;You also get this an interesting and useful concept called “switching” that comes from this; the ability to switch from running one Auto or the other by looking if the result is on or off — here is a common switch that behaves like the first &lt;code&gt;AutoOn&lt;/code&gt; until it is off, and then behaves like the second forever after:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L115-121&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;(--&amp;gt;) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; a b
a1 &lt;span class=&quot;fu&quot;&gt;--&amp;gt;&lt;/span&gt; a2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsOn&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
              &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y1, a1&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAutoOn a1 x
              &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;   &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; y1 &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                     &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; _  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (y1, a1&amp;#39; &lt;span class=&quot;fu&quot;&gt;--&amp;gt;&lt;/span&gt; a2)
                     &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; runAutoOn a2 x
&lt;span class=&quot;kw&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;usages&quot;&gt;Usages&lt;/h3&gt;
&lt;p&gt;Let’s test this out; first, some helper functions (the same ones we wrote for &lt;code&gt;AutoM&lt;/code&gt;)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L91-107&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;autoOn ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; a b
autoOn a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsOn&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, a&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAuto a x
             &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; y, autoOn a&amp;#39;)

&lt;span class=&quot;ot&quot;&gt;arrOn ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; a b
arrOn f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsOn&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (f x, arrOn f)

&lt;span class=&quot;ot&quot;&gt;fromAutoOn ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b)
fromAutoOn a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                 &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, a&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAutoOn a x
                 &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (y, fromAutoOn a&amp;#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;autoOn&lt;/code&gt; turns an &lt;code&gt;Auto a b&lt;/code&gt; into an &lt;code&gt;AutoOn a b&lt;/code&gt;, where the result is always &lt;code&gt;Just&lt;/code&gt;. &lt;code&gt;arrOn&lt;/code&gt; is like &lt;code&gt;arr&lt;/code&gt; and &lt;code&gt;arrM&lt;/code&gt;…it takes an &lt;code&gt;a -&amp;gt; Maybe b&lt;/code&gt; and turns it into an &lt;code&gt;AutoOn a b&lt;/code&gt;. &lt;code&gt;fromAutoOn&lt;/code&gt; turns an &lt;code&gt;AutoOn a b&lt;/code&gt; into a normal &lt;code&gt;Auto a (Maybe b)&lt;/code&gt;, just so that we can leverage our existing test functions on normal &lt;code&gt;Auto&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;Let’s play around with some test &lt;code&gt;AutoOn&lt;/code&gt;s!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L131-152&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;onFor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; a a
onFor n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    i &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; autoOn summer &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; i &lt;span class=&quot;fu&quot;&gt;&amp;lt;=&lt;/span&gt; n
      &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; id    &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x       &lt;span class=&quot;co&quot;&gt;-- succeed&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; empty &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x       &lt;span class=&quot;co&quot;&gt;-- fail&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- alternatively, using explit recursion:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- onFor 0 = empty&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- onFor n = AConsOn $ \x -&amp;gt; (Just x, onFor&amp;#39; (n-1))&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;filterA ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; a a
filterA p &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; arrOn (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&lt;/span&gt; guard (p x))

&lt;span class=&quot;ot&quot;&gt;untilA ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; a a
untilA p &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    stopped &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; autoOn (autoFold (&lt;span class=&quot;fu&quot;&gt;||&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; p x
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; stopped
      &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; empty &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x       &lt;span class=&quot;co&quot;&gt;-- fail&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; id    &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x       &lt;span class=&quot;co&quot;&gt;-- succeed&lt;/span&gt;


&lt;span class=&quot;co&quot;&gt;-- alternatively, using explicit recursion:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- untilA p = AConsOn $ \x -&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--              if p x&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--                then (Just x , untilA p)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--                else (Nothing, empty   )&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One immediate usage is that we can use these to “short circuit” our proc blocks, just like with monadic &lt;code&gt;Maybe&lt;/code&gt; and do blocks:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L163-173&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;shortCircuit1 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
shortCircuit1 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    filterA even &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x
    onFor &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;      &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; ()
    id           &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;shortCircuit2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
shortCircuit2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    onFor &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;      &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; ()
    filterA even &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x
    id           &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If either the &lt;code&gt;filterA&lt;/code&gt; or the &lt;code&gt;onFor&lt;/code&gt; are off, then the whole thing is off. How do you think the two differ?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; testAuto (fromAutoOn shortCircuit1) [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;]
[ &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;40&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;
, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; testAuto (fromAutoOn shortCircuit2) [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;]
[ &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ah. For &lt;code&gt;shortCircuit1&lt;/code&gt;, as soon as the &lt;code&gt;filterA&lt;/code&gt; fails, it jumps &lt;em&gt;straight to the end&lt;/em&gt;, short-circuiting; it doesn’t bother “ticking along” the &lt;code&gt;onFor&lt;/code&gt; and updating its state!&lt;/p&gt;
&lt;p&gt;The arguably more interesting usage, and the one that is more used in real life&lt;a href=&quot;#fn7&quot; class=&quot;footnoteRef&quot; id=&quot;fnref7&quot;&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt;, is the powerful usage of the switching combinator &lt;code&gt;(--&amp;gt;)&lt;/code&gt; in order to be able to combine multiple &lt;code&gt;Auto&lt;/code&gt;’s that simulate “stages”…an &lt;code&gt;Auto&lt;/code&gt; can “do what it wants”, and then choose to “hand it off” when it is ready.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L178-183&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;stages ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
stages &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; stage1 &lt;span class=&quot;fu&quot;&gt;--&amp;gt;&lt;/span&gt; stage2 &lt;span class=&quot;fu&quot;&gt;--&amp;gt;&lt;/span&gt; stage3 &lt;span class=&quot;fu&quot;&gt;--&amp;gt;&lt;/span&gt; stages
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    stage1 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onFor &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; arr negate
    stage2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; untilA (&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; autoOn summer
    stage3 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onFor &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (pure &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; filterA even &lt;span class=&quot;fu&quot;&gt;&amp;lt;|&amp;gt;&lt;/span&gt; pure &lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; testAuto_ (fromAutoOn stages) [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;]
[ &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)              &lt;span class=&quot;co&quot;&gt;-- stage 1&lt;/span&gt;
, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- stage 2&lt;/span&gt;
, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;-- stage 3&lt;/span&gt;
, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)             &lt;span class=&quot;co&quot;&gt;-- stage 1&lt;/span&gt;
, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;                           &lt;span class=&quot;co&quot;&gt;-- stage 2&lt;/span&gt;
, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;-- stage 3&lt;/span&gt;
, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)            &lt;span class=&quot;co&quot;&gt;-- stage 1&lt;/span&gt;
]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the stages continually “loop around”, as our recursive definition seems to imply. Neat!&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You might note that sometimes, to model on/off behavior, it might be nice to really be able to “keep on counting” even when receiving a &lt;code&gt;Nothing&lt;/code&gt; in a composition. For example, you might want both versions of &lt;code&gt;shortCircuit&lt;/code&gt; to be the same — let &lt;code&gt;onFor&lt;/code&gt; still “keep on counting” even when it has been inhibited upstream.&lt;/p&gt;
&lt;p&gt;If this is the behavior you want to model (and this is actually the behavior modeled in some FRP libraries), then the type above isn’t powerful enough; you’ll have to go deeper:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn2.hs#L10-10&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn2&lt;/span&gt; a b &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons2&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; runAutoOn2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b, &lt;span class=&quot;dt&quot;&gt;AutoOn2&lt;/span&gt; a b) }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So now, you can write something like &lt;code&gt;onFor&lt;/code&gt;, which keeps on “ticking on” even if it receives a &lt;code&gt;Nothing&lt;/code&gt; from upstream:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn2.hs#L16-18&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;onFor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn2&lt;/span&gt; a a
onFor &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \_ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, onFor &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
onFor n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (x, onFor (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can of course translate all of your &lt;code&gt;AutoOn&lt;/code&gt;s into this new type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn2.hs#L24-31&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;autoOn ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn2&lt;/span&gt; a b
autoOn a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; x &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
               &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; _x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                 &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, a&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runAutoOn a _x
                 &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (y, autoOn a&amp;#39;)
               &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                 (&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, autoOn a)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or you can use the smart constructor method detailed immediately following.&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;working-all-together&quot;&gt;Working all together&lt;/h2&gt;
&lt;p&gt;Of course, we can always literally throw everything we can add together into our &lt;code&gt;Auto&lt;/code&gt; type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoX.hs#L18-18&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoX&lt;/span&gt; m a b &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsX&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; runAutoX ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b, &lt;span class=&quot;dt&quot;&gt;AutoX&lt;/span&gt; m a b) }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Again, instances are in the source file, but not here in the post directly)&lt;/p&gt;
&lt;p&gt;Here is a same of a big conglomerate type where we throw in a bunch of things.&lt;/p&gt;
&lt;p&gt;The benefit? Well, we could work and compose “normal” &lt;code&gt;Auto&lt;/code&gt;s, selecting for features that we only need to work with. And then, when we need to, we can just “convert it up” to our “lowest common denominator” type.&lt;/p&gt;
&lt;p&gt;This is the common theme, the “functor design pattern”. Pick your common unifying type, and just pop everything into it. You can compose, etc. with the semantics of the other type when convenient, and then have all the parts work together in the end.&lt;/p&gt;
&lt;p&gt;This pattern is awesome, if only we didn’t have so many types to convert in between manually.&lt;/p&gt;
&lt;p&gt;Well, we’re in luck. There’s actually a great trick, that makes &lt;em&gt;all of this&lt;/em&gt; even more streamlined: we can replace the “normal constructors” like &lt;code&gt;ACons&lt;/code&gt;, &lt;code&gt;AConsM&lt;/code&gt;, and &lt;code&gt;AConsOn&lt;/code&gt;, with &lt;em&gt;smart constructors&lt;/em&gt; &lt;code&gt;aCons&lt;/code&gt;, &lt;code&gt;aConsM&lt;/code&gt;, &lt;code&gt;aConsOn&lt;/code&gt;, that work &lt;em&gt;exactly the same way&lt;/em&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoX.hs#L85-100&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;aCons ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (b, &lt;span class=&quot;dt&quot;&gt;AutoX&lt;/span&gt; m a b)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoX&lt;/span&gt; m a b
aCons a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsX&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, aX) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; a x
            &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  return (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; y, aX)

&lt;span class=&quot;ot&quot;&gt;aConsM ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (b, &lt;span class=&quot;dt&quot;&gt;AutoX&lt;/span&gt; m a b)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoX&lt;/span&gt; m a b
aConsM a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsX&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
             (y, aX) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; a x
             return (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; y, aX)

&lt;span class=&quot;ot&quot;&gt;aConsOn ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b, &lt;span class=&quot;dt&quot;&gt;AutoX&lt;/span&gt; m a b)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoX&lt;/span&gt; m a b
aConsOn a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsX&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
              &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, aX) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; a x
              &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  return (y, aX)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Compare these definitions of &lt;code&gt;summer&lt;/code&gt;, &lt;code&gt;arrM&lt;/code&gt;, and &lt;code&gt;untilA&lt;/code&gt; from their “specific type” “real constructor” versions to their &lt;code&gt;AutoX&lt;/code&gt;-generic “smart constructor” versions:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L67-73&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;summer ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a a
summer &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sumFrom &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    sumFrom ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a a
    sumFrom n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \input &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; s &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; input
      &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  ( s , sumFrom s )


&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L104-107&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;arrM ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m a b
arrM f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
                    y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; f x
                    return (y, arrM f)


&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L154-158&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;untilA&amp;#39; ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoOn&lt;/span&gt; a a
untilA&amp;#39; p &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsOn&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
              &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; p x
                &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; x , untilA p)
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, empty   )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoX.hs#L106-128&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;summer ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoX&lt;/span&gt; m a a
summer &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sumFrom &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    sumFrom n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; aCons &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \input &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; s &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; input
      &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  ( s , sumFrom s )

&lt;span class=&quot;ot&quot;&gt;arrM ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoX&lt;/span&gt; m a b
arrM f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; aConsM &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
                    y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; f x
                    return (y, arrM f)

&lt;span class=&quot;ot&quot;&gt;untilA ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoX&lt;/span&gt; m a a
untilA p &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; aConsOn &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; p x
               &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; x , untilA p)
               &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, empty   )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;They are literally exactly the same…we just change the constructor to the smart constructor!&lt;/p&gt;
&lt;p&gt;You might also note that we can express a “pure, non-Monadic” &lt;code&gt;Auto&lt;/code&gt; in &lt;code&gt;AutoM&lt;/code&gt; and &lt;code&gt;AutoX&lt;/code&gt; by making the type polymorphic over all monads:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoX.hs#L106-106&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;summer ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoX&lt;/span&gt; m a a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;An &lt;code&gt;Auto&lt;/code&gt; with a type like this says, “I cannot perform any effects during stepping” — and we know that &lt;code&gt;summer&lt;/code&gt; definitely does not. &lt;code&gt;summer&lt;/code&gt; is statically guaranteed not to affect any state or IO, and it’s reflected in its type.&lt;/p&gt;
&lt;p&gt;The takeaway? You don’t even have to mungle around multiple types to make this strategy work — just make all your &lt;code&gt;Auto&lt;/code&gt;s from the start using these smart constructors, and they all compose together! One type from the start — we just expose different constructors to expose the different “subtypes of power” we want to offer.&lt;/p&gt;
&lt;p&gt;Now it’s all just to chose your “greatest common denominator”. If you don’t want inhibition-based semantics, just only use &lt;code&gt;AutoM&lt;/code&gt;, for example!&lt;/p&gt;
&lt;p&gt;By the way, here’s a “smart constructor” for &lt;code&gt;AutoM&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L112-113&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;aCons ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (b, &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m a b)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AutoM&lt;/span&gt; m a b
aCons f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AConsM&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; return (f x)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;closing-remarks&quot;&gt;Closing Remarks&lt;/h2&gt;
&lt;p&gt;That was a doozy, wasn’t it? For those of you who have been waiting, thank you for being patient. I hope most if not all of you are still with me.&lt;/p&gt;
&lt;p&gt;Hopefully after going through all of these examples, you can take away some things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;From the previous parts, you’ve recognized the power of local statefulness and the declarative style offered by proc notation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;From here, you’ve seen that the Auto type can be equipped in many ways to give it many features which have practical applications in the real world.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You’ve learned how to handle those features and use and manage them together in sane ways, and their limitations.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You also know that you can really “program”, “compose”, or “think” in any sort of Auto or composition semantics that you want, for any small part of the problem. And then at the end, just push them all into your greatest common denominator type. So, you aren’t afraid to play with different effect types even in the same program!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You’ve seen the power of recursive bindings to make complete the promise of declarative programming — being able to extend the realm of what we can express “declaratively”, and what we can &lt;em&gt;denote&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You are ready to really understand anything you encounter involving &lt;code&gt;Auto&lt;/code&gt; and &lt;code&gt;Auto&lt;/code&gt;-like entities.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, what’s next?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://blog.jle.im/source/code-samples/machines&quot;&gt;Download the files of this post&lt;/a&gt;, play along with the examples in this post, CTRL+F this page for “exercise” to find exercises, and try writing your own examples!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Feel ready to be able to have a grasp of the situation you see &lt;code&gt;Auto&lt;/code&gt; in the real world, such as in the popular FRP library &lt;a href=&quot;http://hackage.haskell.org/package/netwire&quot;&gt;netwire&lt;/a&gt;!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Apply it to the real world and your real world problems!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Well, a bit of self-promotion, my upcoming library &lt;a href=&quot;https://github.com/mstksg/auto.&quot;&gt;auto&lt;/a&gt; is basically supposed to be almost all of these concepts (except for implicit on/off behavior) implemented as a finely tuned and optimized performant library, attached with semantic tools for working with real-world problems with these concepts of local statefulness, composition, and declarative style. You can really apply what you learned here to start building projects right away!&lt;/p&gt;
&lt;p&gt;Well, sorta. Unfortunately, as of Feburary 2015, it is not yet ready for real usage, and the API is still being finalized. But now that this post is finished, I will be posting more examples and hype posts in the upcoming weeks and months leading up to its official release.&lt;/p&gt;
&lt;p&gt;I am open to pull requests and help on the final stages of documentation :)&lt;/p&gt;
&lt;p&gt;If you’re interested, or are curious, stop by &lt;em&gt;#haskell-auto&lt;/em&gt; on freenode or send me a message!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Look forward to an actual series on Arrowized FRP, coming up soon! We’ll be using the concepts in this series to &lt;em&gt;implement FRP&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Happy Haskelling!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Some of you might recall an earlier plan for this post that would include FRP. Unfortunately, I’ve refactored FRP into a completely new topic, because I’ve realized that the two aren’t exactly as related as I had led you all to believe. Still, most if not all of these techniques here are used in actual arrowized FRP libraries today. So, look out for that one soon!&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;I’m going to go out on a limb here and say that, where Haskell lets you abstract over functions and function composition with &lt;code&gt;Category&lt;/code&gt;, Haskell lets you abstract over values and function application with &lt;code&gt;Monad&lt;/code&gt;, &lt;code&gt;Applicative&lt;/code&gt;, and &lt;code&gt;Functor&lt;/code&gt;.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;This function really could be avoided if we had written all of our &lt;code&gt;Auto&lt;/code&gt;s is &lt;code&gt;AutoM&lt;/code&gt;’s parameterized over all &lt;code&gt;m&lt;/code&gt; in the first place — that is, written our &lt;code&gt;Auto a b&lt;/code&gt;’s as the equally powerful &lt;code&gt;Monad m =&amp;gt; AutoM m a b&lt;/code&gt;. But we’re just going to run with &lt;code&gt;Auto&lt;/code&gt; for the rest of this series to make things a bit less confusing.&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;By the way, you might notice this pattern as something that seems more fit for &lt;code&gt;Reader&lt;/code&gt; than &lt;code&gt;IO&lt;/code&gt;. We’ll look at that later!&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn5&quot;&gt;&lt;p&gt;Which really isn’t the point of these posts, anyway!&lt;a href=&quot;#fnref5&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn6&quot;&gt;&lt;p&gt;Another exercise you can do if you wanted is to write the exact same instances, but for &lt;code&gt;newtype AutoOn a b = AutoOn (Auto a (Maybe b))&lt;/code&gt; :)&lt;a href=&quot;#fnref6&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn7&quot;&gt;&lt;p&gt;Admittedly, implicit short-circuiting with &lt;code&gt;Auto&lt;/code&gt;s is actually often times a lot more of a headache than it’s worth; note that “switching” still works if you have a normal &lt;code&gt;Auto a (Maybe b)&lt;/code&gt;; this is the approach that many libraries like &lt;a href=&quot;https://github.com/mstksg/auto.&quot;&gt;&lt;em&gt;auto&lt;/em&gt;&lt;/a&gt; take — write switching combinators on normal &lt;code&gt;Auto a (Maybe b)&lt;/code&gt;’s instead.&lt;a href=&quot;#fnref7&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">http://blog.jle.im/entry/effectful-recursive-real-world-autos-intro-to-machine.html</guid><pubDate>Mon,  9 Feb 2015 17:19:03 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings</dc:subject><dc:date>2015-02-09</dc:date></item><item><title>IO Monad Considered Harmful</title><link>http://blog.jle.im/entry/io-monad-considered-harmful.html</link><description>&lt;p&gt;In the tradition of “considered harmful” posts, this post’s title is intentionally misleading and designed to incite controversy — or at least grab your attention. Because of this, please take my exaggerations in this article for what they are :) In following tradition I will try to leave as many quotes and soundbytes as possible that can be easily taken terribly out of context and twisted.&lt;/p&gt;
&lt;p&gt;Anyways, I don’t mean that this “IO Monad” is something to be avoid. In fact, there’s a lot I rather like about it. What I mean is that the phrase “IO Monad”…it’s got to go. It has its usages, but 99.9% of times it is used, it is used improperly, with much damaging effects. So let’s go ahead with stopping this nonsense once and for all, okay?&lt;/p&gt;
&lt;p&gt;So I’ll say it here:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The phrase “IO monad” considered harmful. Please do not use it.&lt;/strong&gt;&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In most circumstances, an &lt;em&gt;IO action&lt;/em&gt; of an &lt;em&gt;IO type&lt;/em&gt;&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; is the more helpful and more correct answer.&lt;/p&gt;
&lt;p&gt;I’m going to say that this is probably &lt;strong&gt;the single most harmful and damaging thing&lt;/strong&gt; in Haskell and the community, with regards to pedagogy, practice, public perception, and kittens. Not even kidding. It’s actually literally the worst and everyone in the world is worse off every time someone says it. Not only is this a problem in and of itself, but it is at the core root of 90% (+/- 80%) of Haskell’s problems.&lt;/p&gt;
&lt;h2 id=&quot;please-not-the-io-monad&quot;&gt;Please, Not the “IO Monad”&lt;/h2&gt;
&lt;p&gt;Let’s say someone comes to you and asks you the question: “How does Haskell do things like print a string?”&lt;/p&gt;
&lt;p&gt;The answer is: &lt;strong&gt;Definitely not with the IO monad.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This is literally one of the simplest questions a new person to Haskell could possibly ask. There are many incorrect answers you could give, but “the IO Monad” is one of the most incorrect answers possible.&lt;/p&gt;
&lt;p&gt;For one, one of the most beautiful things about Haskell is that IO actions are all &lt;a href=&quot;http://blog.jle.im/entry/first-class-statements&quot;&gt;first-class normal data objects&lt;/a&gt;, like lists or integers or booleans.&lt;/p&gt;
&lt;p&gt;The answer to this is that you use something of an IO action – somethign of an &lt;code&gt;IO&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;You use an &lt;em&gt;IO action&lt;/em&gt; (of the &lt;em&gt;IO type&lt;/em&gt;)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;
putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There is nothing that has to do with monads at all in printing a string. The idea that &lt;code&gt;putStrLn &amp;quot;hello world&amp;quot;&lt;/code&gt; is monadic is as absurd as saying that &lt;code&gt;[1,2,3]&lt;/code&gt; is monadic.&lt;/p&gt;
&lt;p&gt;Saying that the answer is the “IO monad” implies that the monad part is something important. &lt;strong&gt;It’s not.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IO in Haskell has nothing to do with monads.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Okay, so the truth is a &lt;em&gt;little&lt;/em&gt; more complicated than this.&lt;/p&gt;
&lt;p&gt;IO’s monadic interface is intimately intertwined with its history. It can be said that the &lt;em&gt;reason&lt;/em&gt; why the model for IO that Haskell has was chosen is &lt;em&gt;because&lt;/em&gt; of its monadic interface. The fact that this IO model admits a monadic interface was a major factor in its adoption as &lt;em&gt;the&lt;/em&gt; IO model for Haskell.&lt;/p&gt;
&lt;p&gt;So, monads “have something to do” with the design decisions of IO in Haskell. But it is still true that IO doesn’t need to have a monadic interface in order to do IO. But that isn’t as nice of a one-liner/sound byte now, is it?&lt;/p&gt;
&lt;p&gt;Special thanks to Chris Allen and Kevin Hammond for this important clarification.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;You could take away monads and even the entire monadic interface from Haskell and Haskell could &lt;em&gt;still&lt;/em&gt; do IO &lt;em&gt;with the same IO type&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The ability for Haskell to work with IO comes from the fact that we have a regular ol’ data type that represents IO actions, in the same way that &lt;code&gt;Bool&lt;/code&gt; represents a boolean or &lt;code&gt;Integer&lt;/code&gt; represents an integer.&lt;/p&gt;
&lt;p&gt;Saying “the IO monad” is literally the most misleading thing you could possibly say. IO in Haskell has nothing to do with monads.&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;How did this idea become so prevalent and pervasive? I cannot say! But somehow, somewhere, this idea happened, and it is persistent now. Please do not add anything to this misconception and further propagate this dangerous myth.&lt;/p&gt;
&lt;p&gt;Saying “IO monad” is very misleading and awful pedagogy because when someone new to Haskell reads that you print strings or do IO actions using “the IO monad”, the natural question is: “What is a monad?”&lt;/p&gt;
&lt;p&gt;Not only is that question completely &lt;em&gt;irrelevant&lt;/em&gt; to doing IO at all, it’s also a question that has &lt;a href=&quot;https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/&quot;&gt;historically lead to much confusion&lt;/a&gt;. I consider it one of the worst “sidequests” you could embark on in learning Haskell. Seeking an intuitive grasp of what a monad is is not only worthless for learning practical Haskell (at the start), but one that can lead to many false answers, confusing and contradictory answers, and just a lot of headache in general. Before I even ever heard about Haskell, I heard about the infamous “IO monad”. I read, “monads are a crazy hard-to-understand subject, but once you understand it, Haskell becomes amazing.” Haskell is Haskell and is useful before you ever introduce Monad into the picture…and a quote like that implies that understanding monads is important to understanding Haskell or IO.&lt;/p&gt;
&lt;p&gt;It just simply &lt;em&gt;isn’t&lt;/em&gt;. If you want to “understand Monads” (whatever that means), then go ahead; try. But please don’t think that it’ll help you &lt;strong&gt;even a single bit&lt;/strong&gt; in understanding IO in Haskell.&lt;/p&gt;
&lt;p&gt;Saying “IO Monad” implies that understanding monads is some prerequisite to understanding IO, or at the very least that IO in Haskell is inherently tied to monads. &lt;strong&gt;Both are untrue&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Another commonly mis-answered question is, “How does Haskell, a pure language, handle impure side-effects?”&lt;/p&gt;
&lt;p&gt;Again, the answer is &lt;strong&gt;anything except “the IO Monad”&lt;/strong&gt;. If I were to make a list of the most misleading, incorrect, dangerous, and disgusting possible answers, this would be on the top spot. The &lt;em&gt;IO type itself&lt;/em&gt; is what enables this. Not the monadic interface.&lt;/p&gt;
&lt;p&gt;Bringing in the idea of “monads” into the idea really only leads to confusion, because they literally contribute &lt;em&gt;nothing&lt;/em&gt; to the subject. And yet, why do I see people answering, “Haskell handles IO and impurity with monads”? I’m sure you’ve heard at least one person saying this. But it’s 100% wrong. &lt;strong&gt;Monads actually have nothing to do with it&lt;/strong&gt;, and I’m not even exaggerating here.&lt;/p&gt;
&lt;p&gt;If anything it adds to the perceived learning barrier of Haskell. &lt;strong&gt;If something as simple as IO requires &lt;em&gt;category theory&lt;/em&gt; to understand, then something must be way off.&lt;/strong&gt; (Luckily, it doesn’t) This really only &lt;em&gt;adds more&lt;/em&gt; to the perception of Haskell as an academic language that people learn only to be able to feel smarter. Haskell already has a huge PR problem as it is; we don’t need people going around doing this and making it even worse. Please, do not contribute to this.&lt;/p&gt;
&lt;p&gt;Furthermore, imagine someone new to Haskell asked you, “Can I store a sequence of numbers?”&lt;/p&gt;
&lt;p&gt;One good answer would be, “Yes, with a list!”, or the list type.&lt;/p&gt;
&lt;p&gt;One bad answer would be, “Yes, with the List Monad!”&lt;/p&gt;
&lt;p&gt;Now someone who wants to be able to do something simple like &lt;code&gt;[1, 2, 3]&lt;/code&gt; will think that something like &lt;code&gt;[1, 2, 3]&lt;/code&gt; in Haskell is inherently tied to monads in some way.&lt;/p&gt;
&lt;p&gt;But having a list like &lt;code&gt;[1,2,3]&lt;/code&gt; has nothing to do with monads. Calling every list “the list monad”, or calling every situation where a list would be useful a situation where “you want the List monad” is misleading, false, and just leads to more confusion.&lt;/p&gt;
&lt;p&gt;I need to find all even numbers from one to one hundred.&lt;/p&gt;
&lt;p&gt;Right: Use a list and &lt;code&gt;filter even&lt;/code&gt; over a list from one to one hundred.&lt;/p&gt;
&lt;p&gt;Wrong: Use the list monad and &lt;code&gt;filter even&lt;/code&gt; over a list from one to one hundred.&lt;/p&gt;
&lt;p&gt;Even more wrong but you couldn’t really get more wrong in the first place: Use the list monoid and &lt;code&gt;filter even&lt;/code&gt; over a list from one to one hundred.&lt;/p&gt;
&lt;p&gt;Why would you ever do that?&lt;/p&gt;
&lt;p&gt;What good does it do?&lt;/p&gt;
&lt;p&gt;What good has it ever done anyone?&lt;/p&gt;
&lt;p&gt;Really, why?&lt;/p&gt;
&lt;p&gt;Why do people say the IO monad?&lt;/p&gt;
&lt;p&gt;Why did people start saying that in the first place?&lt;/p&gt;
&lt;p&gt;Why doesn’t this world make any sense?&lt;/p&gt;
&lt;p&gt;Please, please, stop saying “the IO monad”.&lt;/p&gt;
&lt;h2 id=&quot;some-side-notes&quot;&gt;Some side notes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;“State monad” and “Writer monad” and “Reader monad” are just as bad when abused, and you know it. Shame on you.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A good time to use the “(something) monad” is when you are referring in particular to the monad instance or its monadic interface.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I have qualms with the “monad” part of “IO monad”, but sometimes, I even wonder about the “IO” part. Yes, Haskell can do IO through the IO type, but it’s really possible to program effectful code interfacing with IO without ever directly working with the IO type; one could even just think of IO as a nice “intermediate data structure” that GHC or whatever Haskell compiler you are using can understand. Use a library or DSL or whatever to write your IO-based code, just make sure your library has a function to transform it into an IO. Already, many real-world Haskell code that “does IO” doesn’t ever directly work with the IO type itself.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For those confused at this point there are some appropriate times to use “the X monad”. It’s in the cases where you take advantage of the monadic interface. Just like you call an array an iterator when you use the Iterator interface. Here are some examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“I have to print a string”: No; use the “primitive” &lt;code&gt;putStrLn&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;“I have to turn an IO action returning an &lt;code&gt;Int&lt;/code&gt; into an IO action returning a &lt;code&gt;Bool&lt;/code&gt; (if it’s even)”: No; use &lt;a href=&quot;http://blog.jle.im/entry/inside-my-world-ode-to-functor-and-monad&quot;&gt;&lt;code&gt;fmap&lt;/code&gt;&lt;/a&gt; to “map” your &lt;code&gt;Int -&amp;gt; Bool&lt;/code&gt; onto the &lt;code&gt;IO Int&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;“I have to print a string twice, or multiple strings”: Kinda. You can use the monadic interface to do this using &lt;em&gt;do&lt;/em&gt; notation, or &lt;code&gt;mapM_&lt;/code&gt; or &lt;code&gt;(&amp;gt;&amp;gt;)&lt;/code&gt;. I say abuse because while using the monadic interface to do this is possible, it is a little overkill; &lt;code&gt;(*&amp;gt;)&lt;/code&gt; and &lt;code&gt;traverse_&lt;/code&gt; do the trick as well.&lt;/li&gt;
&lt;li&gt;“I want to combine two IO actions, two programs, into one that does both of the original ones one after the other”: See the above.&lt;/li&gt;
&lt;li&gt;“I have to do line-by-line constant-memory text processing of a large file”: No; please use a streaming combinator library like &lt;em&gt;pipes&lt;/em&gt; or &lt;em&gt;conduit&lt;/em&gt;. (Working directly with) the &lt;code&gt;IO&lt;/code&gt; type is actually notoriously bad at this. Don’t use it; and of course, don’t use its monad instance either.&lt;/li&gt;
&lt;li&gt;“I have to directly use the result of one IO action in order to decide which IO action should happen next”: Yes, this is a use case for IO’s monadic interface.&lt;/li&gt;
&lt;li&gt;“What is one type can I use with a &lt;em&gt;do&lt;/em&gt; block”: Yes, IO Monad. Because only monads can be used with &lt;em&gt;do&lt;/em&gt; blocks.&lt;/li&gt;
&lt;li&gt;“What is a Monad I can use as the underlying monad for my monad transformer?”: Yes, IO Monad. Because you need a monad in particular.&lt;/li&gt;
&lt;li&gt;“What is best way to get to the grocery store?”: No; use Google Maps or something like that.&lt;/li&gt;
&lt;li&gt;“What is a word that begins with I and rhymes with ‘Bio Monad’?”: Yes, IO Monad.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;: So a lot of people seem to be getting the impression that I advocate not using the word “monad” to describe things like “binding” expressions, do blocks, using &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; with &lt;code&gt;IO&lt;/code&gt;, etc. I am not really quite for this. I do advise that if you are talking specifically about monadic things, you should say that they are monadic things. Hiding things from people isn’t going to help anyone and only leads to more confusion, and I think it might get in the way of learning and making important connections.&lt;/p&gt;
&lt;p&gt;However, what I &lt;em&gt;am&lt;/em&gt; against is saying “monad” to describe things that are clearly not monadic. Like printing a string, or sequencing a bunch of independent actions.&lt;/p&gt;
&lt;p&gt;In short: use Monad when you are talking about IO’s monadic properties; don’t use it when you aren’t. Simple, right?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;In any case, ever, for any circumstance or reason.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;Just kidding. Only a sith deals in absolutes.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;Note here, I am referring to the &lt;em&gt;IO type&lt;/em&gt;, not the &lt;em&gt;&lt;code&gt;IO&lt;/code&gt; type constructor&lt;/em&gt;. The actual abstract data type, and not the &lt;code&gt;IO :: * -&amp;gt; *&lt;/code&gt; type constructor that you use in type signatures. When we talk about the “Map type”, we talk about the abstract data type, the underlying binary search tree, and the API that it offers…we don’t really talk about the &lt;code&gt;Map :: * -&amp;gt; * -&amp;gt; *&lt;/code&gt; &lt;em&gt;type constructor&lt;/em&gt;.&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;See the aside for a qualification.&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">http://blog.jle.im/entry/io-monad-considered-harmful.html</guid><pubDate>Thu, 22 Jan 2015 17:01:17 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell</dc:subject><dc:date>2015-01-22</dc:date></item><language>en</language><copyright>Copyright 2016 Justin Le</copyright><managingEditor>justin@jle.im (Justin Le)</managingEditor><webMaster>justin@jle.im (Justin Le)</webMaster><lastBuildDate>Fri, 25 Mar 2016 21:50:35 UTC</lastBuildDate><generator>feed-0.3.11.1 (Sigbjorn Finne)</generator><image><url>http://blog.jle.im/img/site_logo.jpg</url><title>in Code</title><link>http://blog.jle.im/</link></image><dc:creator>Justin Le</dc:creator><dc:language>en</dc:language><dc:rights>Copyright 2016 Justin Le</dc:rights><dc:date>2016-03-25</dc:date><dc:description>Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge.</dc:description></channel></rss>