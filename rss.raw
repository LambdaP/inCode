<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>in Code — Entries</title><link>https://blog.jle.im/</link><description>Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge.</description><item><title>Introducing the Hamilton library</title><link>https://blog.jle.im/entry/introducing-the-hamilton-library.html</link><description>&lt;p&gt;&lt;a href=&quot;http://i.imgur.com/Vaaa2EC.gifv&quot;&gt;&lt;img src=&quot;/img/entries/hamilton/double-pendulum.gif&quot; title=&quot;My name is William Rowan Hamilton&quot; alt=&quot;My name is William Rowan Hamilton&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hamilton&lt;/strong&gt;: &lt;a href=&quot;https://github.com/mstksg/hamilton#readme&quot;&gt;README&lt;/a&gt; / &lt;a href=&quot;http://hackage.haskell.org/package/hamilton&quot;&gt;hackage&lt;/a&gt; / &lt;a href=&quot;https://github.com/mstksg/hamilton&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/hamilton&quot;&gt;hamilton&lt;/a&gt;&lt;/em&gt; library is on hackage! It was mostly a proof-of-concept toy experiment to simulate motion on bezier curves, but it became usable enough and accurate enough (to my surprise, admittedly) that I finished up some final touches to make it complete and put it on hackage as a general-purpose physics simulator.&lt;/p&gt;
&lt;p&gt;The library is, in short, a way to simulate a physical system by stating nothing more than an arbitrary parameterization of a system (a “generalized coordinate”) and a potential energy function.&lt;/p&gt;
&lt;p&gt;I was going to write a Haskell post on the implementation, which was what interested me at first. I wanted to go over –&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Using &lt;a href=&quot;https://hackage.haskell.org/package/ad&quot;&gt;automatic differentiation&lt;/a&gt; to automatically compute momentum and the hamilton equations, which are solutions of differential equations.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Using type-indexed vectors and dependent types in a seamless way to encode the dimensionality of the generalized coordinate systems and to encode invariants the types of functions.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And fun stuff like that. But that post might be a bit of a while away, so I’m just going to write a post about the usage of the library. (Fair warning, most of this information is also found in the &lt;a href=&quot;https://github.com/mstksg/hamilton#readme&quot;&gt;readme&lt;/a&gt;.)&lt;/p&gt;
&lt;h3 id=&quot;hamiltonian-mechanics&quot;&gt;Hamiltonian Mechanics&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;(This section goes briefly over some relevant part of the physics behind Hamiltonian dynamics, but feel free to skip it if you want to go straight to the Haskell)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hamiltonian_mechanics&quot;&gt;Hamiltonian mechanics&lt;/a&gt; is a brilliant, radical, and beautiful re-imagination of the physics of mechanics and dynamics by &lt;a href=&quot;https://www.youtube.com/watch?v=SZXHoWwBcDc&quot;&gt;William Rowan Hamilton&lt;/a&gt;. It was adapted for statistical mechanics and thermodynamics, and it was through the lens of Hamiltonian mechanics that Schroedinger and Heisenberg independently found insight that unlocked the secrets of quantum mechanics. While Newton’s interpretation of mechanics (in terms of forces and accelerations) was cute, it simply didn’t generalize to quantum mechanics. Hamiltonian’s interpretation of mechanics &lt;em&gt;did&lt;/em&gt;, and we have a century of physics revolutions to thank for it. Hamiltonian mechanics also generalize without any extra work to relativity – another case where newtonian mechanics tends to fall apart.&lt;/p&gt;
&lt;p&gt;Hamiltonian mechanics, in a classical sense, imagines that the state of the system exists as a point in &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_space&quot;&gt;phase space&lt;/a&gt;&lt;/em&gt;, and that the system evolves based on geometric properties of the system’s &lt;em&gt;Hamiltonian&lt;/em&gt; over that phase space.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/entries/hamilton/phase-space.gif&quot; alt=&quot;Animation of particles traveling in phase space (top) over time, from Wikipedia&quot; /&gt;&lt;figcaption&gt;Animation of particles traveling in phase space (top) over time, from Wikipedia&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;In other words, define the Hamiltonian of the system, and you see the step-by-step evolution and dynamics of the system. You can imagine mechanics as a series of streams of flow over phase space…and the state of the system just goes along for the ride.&lt;/p&gt;
&lt;p&gt;One nice thing about phase space is that it can be stated in terms of any arbitrary parameterization/coordinate system of your system. For example, for a &lt;a href=&quot;https://en.wikipedia.org/wiki/Double_pendulum&quot;&gt;double pendulum&lt;/a&gt; system, you can imagine the system as traveling about in the phase space of the angles of the bobs (instead of their actual positions in cartesian space). If you can find &lt;em&gt;any&lt;/em&gt; way to parameterize your system, in any sort of type of coordinates, then Hamiltonian mechanics will describe how it evolves in those coordinates.&lt;/p&gt;
&lt;p&gt;State some fundamental geometric properties about your coordinate system, and the Hamiltonian figures out the rest. It’s the key to unlocking the dynamical properties of the system.&lt;/p&gt;
&lt;p&gt;I could go into more details, but this isn’t a post about Hamiltonian mechanics! Armed with this, let’s look into modeling an actual double pendulum system in terms of the angles of the bobs.&lt;/p&gt;
&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;
&lt;h4 id=&quot;the-double-pendulum&quot;&gt;The Double Pendulum&lt;/h4&gt;
&lt;p&gt;So, if we’re going to be simulating a double pendulum system using &lt;em&gt;hamilton&lt;/em&gt;, we need three things:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;A statement of our parameterized coordinates and how they relate to the underlying cartesian coordinates of our system&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The inertias (in our case, masses) of each of those underlying coordinates.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A potential energy function (in our case, just the potential energy induced by gravity)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We have two coordinates here (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Ctheta_1&quot; alt=&quot;\theta_1&quot; title=&quot;\theta_1&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Ctheta_2&quot; alt=&quot;\theta_2&quot; title=&quot;\theta_2&quot; /&gt;), which will be encoding the positions of the two pendulums:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Clangle%20x_1%2C%20y_1%20%5Crangle%20%3D%0A%20%20%5Cleft%5Clangle%20%5Csin%20%28%5Ctheta_1%29%2C%20-%20%5Ccos%20%28%5Ctheta_1%29%20%5Cright%5Crangle%0A&quot; alt=&quot;
\langle x_1, y_1 \rangle =
  \left\langle \sin (\theta_1), - \cos (\theta_1) \right\rangle
&quot; title=&quot;
\langle x_1, y_1 \rangle =
  \left\langle \sin (\theta_1), - \cos (\theta_1) \right\rangle
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Clangle%20x_2%2C%20y_2%20%5Crangle%20%3D%0A%20%20%5Cleft%5Clangle%20%5Csin%20%28%5Ctheta_1%29%20%2B%20%5Cfrac%7B1%7D%7B2%7D%20%5Csin%20%28%5Ctheta_2%29%2C%0A%20%20%20%20-%20%5Ccos%20%28%5Ctheta_1%29%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5Ccos%20%28%5Ctheta_2%29%20%5Cright%5Crangle%0A&quot; alt=&quot;
\langle x_2, y_2 \rangle =
  \left\langle \sin (\theta_1) + \frac{1}{2} \sin (\theta_2),
    - \cos (\theta_1) - \frac{1}{2} \cos (\theta_2) \right\rangle
&quot; title=&quot;
\langle x_2, y_2 \rangle =
  \left\langle \sin (\theta_1) + \frac{1}{2} \sin (\theta_2),
    - \cos (\theta_1) - \frac{1}{2} \cos (\theta_2) \right\rangle
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;(Assuming that the first pendulum has length 1 and the second pendulum has length &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B2%7D&quot; alt=&quot;\frac{1}{2}&quot; title=&quot;\frac{1}{2}&quot; /&gt;)&lt;/p&gt;
&lt;p&gt;The inertias of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?x_1&quot; alt=&quot;x_1&quot; title=&quot;x_1&quot; /&gt;, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?y_1&quot; alt=&quot;y_1&quot; title=&quot;y_1&quot; /&gt;, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?x_2&quot; alt=&quot;x_2&quot; title=&quot;x_2&quot; /&gt;, and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?y_2&quot; alt=&quot;y_2&quot; title=&quot;y_2&quot; /&gt; are the “masses” attached to them. Let’s pick that the first bob has mass &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?1&quot; alt=&quot;1&quot; title=&quot;1&quot; /&gt; and the second bob has mass &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?2&quot; alt=&quot;2&quot; title=&quot;2&quot; /&gt;, so then our masses are &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Clangle%201%2C%201%2C%202%2C%202%20%5Crangle&quot; alt=&quot;\langle 1, 1, 2, 2 \rangle&quot; title=&quot;\langle 1, 1, 2, 2 \rangle&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;Finally, the potential energy of our system is just the potential energy of gravity, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?m%20%5Ctimes%20g%20%5Ctimes%20y&quot; alt=&quot;m \times g \times y&quot; title=&quot;m \times g \times y&quot; /&gt; for each of our points:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0AU%28x_1%2C%20y_1%2C%20x_2%2C%20y_2%29%20%3D%20%28%20y_1%20%2B%202%20y_2%20%29%20g%0A&quot; alt=&quot;
U(x_1, y_1, x_2, y_2) = ( y_1 + 2 y_2 ) g
&quot; title=&quot;
U(x_1, y_1, x_2, y_2) = ( y_1 + 2 y_2 ) g
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Turns out that this is a complete enough description of our system to let &lt;em&gt;hamilton&lt;/em&gt; do the rest!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L10-25&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;doublePendulum ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
doublePendulum &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mkSystem&amp;#39; masses coordinates potential
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    masses ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
    masses &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; vec4 &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
    coordinates
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Floating&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; a
    coordinates (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; θ&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; θ&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V4&lt;/span&gt; (sin θ&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)            (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;cos θ&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
                                (sin θ&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; sin θ&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;cos θ&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; cos θ&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
    potential
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
    potential (&lt;span class=&quot;dt&quot;&gt;V4&lt;/span&gt; _ y1 _ y2) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (y1 &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y2) &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;-- assuming g = 5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(with some &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L27-35&quot;&gt;helper patterns&lt;/a&gt; defined here – &lt;code&gt;V2&lt;/code&gt; and &lt;code&gt;V4&lt;/code&gt; – that lets us pattern match on and construct sized &lt;code&gt;Vector&lt;/code&gt;s and their 2 (or 4) elements)&lt;/p&gt;
&lt;p&gt;Ta dah. That’s literally all we need.&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;System m n&lt;/code&gt; represents a description of a physical system (without its state) described with &lt;code&gt;n&lt;/code&gt; parameters/generalized coordinates. The &lt;code&gt;m&lt;/code&gt; represents the dimension of its underlying cartesian coordinate system (&lt;code&gt;4&lt;/code&gt; for us, with &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Clangle%20x_1%2C%20y_1%2C%20x_2%2C%20y_2%20%5Crangle&quot; alt=&quot;\langle x_1, y_1, x_2, y_2 \rangle&quot; title=&quot;\langle x_1, y_1, x_2, y_2 \rangle&quot; /&gt;). The &lt;code&gt;m&lt;/code&gt; should be more or less irrelevant to the actual &lt;em&gt;usage&lt;/em&gt; of &lt;code&gt;System m n&lt;/code&gt; and the &lt;em&gt;hamilton&lt;/em&gt; api…but it’s mostly useful only if we eventually want to plot the system in normal cartesian space.&lt;/p&gt;
&lt;p&gt;Now, let’s run the simulation. First we have to pick a starting configuration:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L37-39&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;config0 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
config0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cfg&lt;/span&gt; (vec2 &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  )  &lt;span class=&quot;co&quot;&gt;-- initial positions&lt;/span&gt;
              (vec2 &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;-- initial velocities&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;Config n&lt;/code&gt; represents the state of the system, represented in configuration-space. But, remember, Hamiltonian dynamics is about simulating the path of the particle through &lt;em&gt;phase space&lt;/em&gt;. So we can convert our configuration-space state into a phase-space state:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L41-42&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;phase0 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
phase0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; toPhase doublePendulum config0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now we can ask for the state of our system at any amount of points in time:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L44-45&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;evolution ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
evolution &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; evolveHam&amp;#39; doublePendulum phase0 [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The result there will be the state of the system at times 0, 0.01, 0.02, 0.03 … etc.&lt;/p&gt;
&lt;p&gt;Or, if you want to run the system step-by-step:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L47-48&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;evolution&amp;#39; ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
evolution&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; iterate (stepHam &lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt; doublePendulum) phase0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And you can get the position of the coordinates as:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L50-51&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;positions ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
positions &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; phsPositions &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; evolution&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With &lt;code&gt;phsPositions :: Phase n -&amp;gt; R n&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;And the position in the underlying cartesian space as:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L53-54&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;positions&amp;#39; ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]
positions&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; underlyingPos doublePendulum &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; positions&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where &lt;code&gt;underlyingPos :: System m n -&amp;gt; Phase n -&amp;gt; R m&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let’s ignore the underlying position for now, and print out now the full progression of the system’s positions:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L56-57&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withRows (take &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt; positions) (disp &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;withRows&lt;/code&gt; is from &lt;em&gt;hmatrix&lt;/em&gt;, which treats a list of vectors as a matrix with each vector as a row, and &lt;code&gt;disp 5&lt;/code&gt; from &lt;em&gt;hmatrix&lt;/em&gt; pretty-prints our matrix with 5 decimal places of precision)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;L 25 2
 1.0000   0.0000
 0.9727   0.0800
 0.8848   0.2345
 0.7164   0.5129
 0.4849   0.8725
 0.2878   1.0648
 0.1223   1.0801
-0.0165   0.9388
-0.1099   0.6400
-0.1161   0.1447
-0.0539  -0.4882
-0.0795  -0.9212
-0.1689  -1.1797
-0.2860  -1.2970
-0.4146  -1.2803
-0.5562  -1.1238
-0.7249  -0.8079
-0.8762  -0.4505
-0.9442  -0.2075
-0.9416  -0.0516
-0.8793   0.0312
-0.7596   0.0265
-0.5728  -0.1086
-0.3001  -0.4237
-0.0381  -0.6640&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Neat! We see that the first coordinate (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Ctheta_1&quot; alt=&quot;\theta_1&quot; title=&quot;\theta_1&quot; /&gt;) starts at 1 like we asked, and then begins decreasing and falling… And then we see the second coordinate (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Ctheta_2&quot; alt=&quot;\theta_2&quot; title=&quot;\theta_2&quot; /&gt;) starting at 0 and then “swinging” to the right. The &lt;a href=&quot;http://i.imgur.com/Vaaa2EC.gifv&quot;&gt;image the top of this post&lt;/a&gt; is an animation of such a system (albeit with &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?m_2%20%3D%201&quot; alt=&quot;m_2 = 1&quot; title=&quot;m_2 = 1&quot; /&gt;).&lt;/p&gt;
&lt;h4 id=&quot;two-body-system&quot;&gt;Two-body system&lt;/h4&gt;
&lt;p&gt;Here’s one more situation where generalized coordinates describe things in a lot nicer way than cartesian coordinates: the classic two-body problem.&lt;/p&gt;
&lt;p&gt;Really, you can describe the state of a two-body system with only two parameters: the distance between the two bodies, and their current angle of rotation.&lt;/p&gt;
&lt;p&gt;In this framework, Kepler tells us that for bodies in orbit, the distance will grow smaller and larger again over time, and that the angle of rotation will constantly increase…and increase at a faster rate when the distance is smaller (which is &lt;a href=&quot;https://en.wikipedia.org/wiki/Kepler&amp;#39;s_laws_of_planetary_motion#Second_law&quot;&gt;Kepler’s second law&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;If we assume that the center of mass of the system is at &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Clangle%200%2C%200%20%5Crangle&quot; alt=&quot;\langle 0, 0 \rangle&quot; title=&quot;\langle 0, 0 \rangle&quot; /&gt;, then we can state these coordinates as&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Clangle%20x_1%2C%20y_1%20%5Crangle%20%3D%20%5Clangle%20r_1%20%5Ccos%20%28%5Ctheta%29%2C%20r_1%20%5Csin%20%28%5Ctheta%29%20%5Crangle%0A&quot; alt=&quot;
\langle x_1, y_1 \rangle = \langle r_1 \cos (\theta), r_1 \sin (\theta) \rangle
&quot; title=&quot;
\langle x_1, y_1 \rangle = \langle r_1 \cos (\theta), r_1 \sin (\theta) \rangle
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Clangle%20x_2%2C%20y_2%20%5Crangle%20%3D%20%5Clangle%20r_2%20%5Ccos%20%28%5Ctheta%29%2C%20r_2%20%5Csin%20%28%5Ctheta%29%20%5Crangle%0A&quot; alt=&quot;
\langle x_2, y_2 \rangle = \langle r_2 \cos (\theta), r_2 \sin (\theta) \rangle
&quot; title=&quot;
\langle x_2, y_2 \rangle = \langle r_2 \cos (\theta), r_2 \sin (\theta) \rangle
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?r_1%20%3D%20%5Cfrac%7Bm_2%7D%7Bm_1%20%2B%20m_2%7D&quot; alt=&quot;r_1 = \frac{m_2}{m_1 + m_2}&quot; title=&quot;r_1 = \frac{m_2}{m_1 + m_2}&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?r_2%20%3D%20-%20%5Cfrac%7Bm_1%7D%7Bm_1%20%2B%20m_2%7D&quot; alt=&quot;r_2 = - \frac{m_1}{m_1 + m_2}&quot; title=&quot;r_2 = - \frac{m_1}{m_1 + m_2}&quot; /&gt; (solving from the center of mass).&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Our potential energy function is Newton’s famous &lt;a href=&quot;https://en.wikipedia.org/wiki/Newton&amp;#39;s_law_of_universal_gravitation&quot;&gt;law of universal gravitation&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0AU%28r%2C%20%5Ctheta%29%20%3D%20-%20%5Cfrac%7BG%20m_1%20m_2%7D%7Br%7D%0A&quot; alt=&quot;
U(r, \theta) = - \frac{G m_1 m_2}{r}
&quot; title=&quot;
U(r, \theta) = - \frac{G m_1 m_2}{r}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;And, this should be enough to go for &lt;em&gt;hamilton&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;“But wait,” I hear you say. “If we’re doing a change-of-coordinate-system into polar coordinates, don’t we have to account for artifacts like centrifugal acceleration from the fact that &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?d%20%5Ctheta&quot; alt=&quot;d \theta&quot; title=&quot;d \theta&quot; /&gt; is non-uniform and depends on &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?r&quot; alt=&quot;r&quot; title=&quot;r&quot; /&gt;?”&lt;/p&gt;
&lt;p&gt;Well, I’m glad you asked! And the answer is, nope. We don’t have to account for any weird interplay from non-uniform coordinate systems because &lt;em&gt;hamilton&lt;/em&gt; arrives at the proper solution simply from the geometry of the generalized coordinates. (And it does this using &lt;a href=&quot;https://hackage.haskell.org/package/ad&quot;&gt;ad&lt;/a&gt;, but more on that for a later post!)&lt;/p&gt;
&lt;p&gt;Anyway, here we go:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/TwoBody.hs#L10-42&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;twoBody ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
twoBody &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mkSystem masses coordinates potential
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    masses ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
    masses &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; vec4 &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    coordinates
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Floating&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; a
    coordinates (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; r θ) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V4&lt;/span&gt; (r1 &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; cos θ) (r1 &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; sin θ)
                              (r2 &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; cos θ) (r2 &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; sin θ)
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        r1 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;   r &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;
        r2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; r &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;
    potential
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
    potential (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; r _) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; r       &lt;span class=&quot;co&quot;&gt;-- G = 1&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;config0 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
config0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cfg&lt;/span&gt; (vec2 &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;-- initial positions&lt;/span&gt;
              (vec2 &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;-- initial velocities&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(we use &lt;code&gt;mkSystem&lt;/code&gt; instead of &lt;code&gt;mkSystem&#39;&lt;/code&gt; because we want to state the potential energy in terms of our generalized coordinates &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?r&quot; alt=&quot;r&quot; title=&quot;r&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Ctheta&quot; alt=&quot;\theta&quot; title=&quot;\theta&quot; /&gt;)&lt;/p&gt;
&lt;p&gt;Let’s take a peek:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/TwoBody.hs#L44-60&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;phase0 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
phase0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; toPhase twoBody config0

&lt;span class=&quot;ot&quot;&gt;evolution&amp;#39; ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
evolution&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; iterate (stepHam &lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt; twoBody) phase0

&lt;span class=&quot;ot&quot;&gt;positions ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
positions &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; phsPositions &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; evolution&amp;#39;

&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withRows (take &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt; positions) (disp &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;L 25 2
2.0000  0.0000
1.9887  0.0502
1.9547  0.1015
1.8972  0.1554
1.8149  0.2133
1.7058  0.2777
1.5669  0.3523
1.3933  0.4435
1.1774  0.5647
0.9057  0.7503
0.5516  1.1413
0.2057  3.4946
0.6092  5.2275
0.9490  5.5664
1.2115  5.7386
1.4207  5.8542
1.5889  5.9424
1.7233  6.0152
1.8283  6.0785
1.9069  6.1358
1.9610  6.1892
1.9917  6.2403
1.9998  6.2904
1.9852  6.3407
1.9479  6.3923&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Neat! We see that &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?r&quot; alt=&quot;r&quot; title=&quot;r&quot; /&gt; starts big and gets smaller, and then gets big again. And it’s clear that when &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?r&quot; alt=&quot;r&quot; title=&quot;r&quot; /&gt; is smallest, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Ctheta&quot; alt=&quot;\theta&quot; title=&quot;\theta&quot; /&gt; changes the fastest. Look at it go!&lt;/p&gt;
&lt;p&gt;Here’s an animation of the same situation with some different masses:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://i.imgur.com/TDEHTcb.gifv&quot;&gt;&lt;img src=&quot;/img/entries/hamilton/two-body.gif&quot; alt=&quot;The two-body solution&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;just-you-wait&quot;&gt;Just you wait&lt;/h3&gt;
&lt;p&gt;Now, this isn’t all just useful for physics. You can state a lot of animation/dynamics problems as motion along coordinates that aren’t always trivial. This project started, after all, as a way to simulate constant-velocity motion along a bezier curve. (In that case, the single coordinate is the non-uniform time parameter to the bezier curve.)&lt;/p&gt;
&lt;p&gt;I’ve included more examples in the &lt;a href=&quot;https://github.com/mstksg/hamilton#example-app-runner&quot;&gt;example app launcher&lt;/a&gt; included in the library (which generated those animations you see above), including:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;A spring hanging from a block sliding along a horizontal rail (a favorite of many physics students, of course)&lt;/li&gt;
&lt;li&gt;A ball bouncing around a room, showing that you can represent bouncy walls as potential energy functions&lt;/li&gt;
&lt;li&gt;The bezier curve example.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let me know in the comments if you think of any interesting systems to apply this to, or if you have any interesting applications in physical or non-physical ways! I’d love to hear :D&lt;/p&gt;
&lt;p&gt;And if you’re interested in the implementation using some of those Haskell tricks I mentioned above, stay tuned :)&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Alternatively, we could assume that the halfway point (or even the first body) is always at &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Clangle%200%2C%200%20%5Crangle&quot; alt=&quot;\langle 0, 0 \rangle&quot; title=&quot;\langle 0, 0 \rangle&quot; /&gt;, but this doesn’t give us as pretty of plots. The center of mass is a nice reference point because newton’s third law implies that it remains stationary forever.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Projects</category><guid isPermaLink="true">https://blog.jle.im/entry/introducing-the-hamilton-library.html</guid><pubDate>Mon, 28 Nov 2016 17:28:32 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Projects</dc:subject><dc:date>2016-11-28</dc:date></item><item><title>Practical Dependent Types in Haskell 2: Existential Neural Networks and Types at
Runtime</title><link>https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html</link><description>&lt;p&gt;We’re back to continue on &lt;a href=&quot;https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html&quot;&gt;our journey&lt;/a&gt; in using dependent types to write type-safe neural networks! In &lt;a href=&quot;https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html&quot;&gt;Part 1&lt;/a&gt;, we wrote things out in normal, untyped Haskell, and looked at red flags and general design principles that nudged us in the direction of adding dependent types to our program. We learned to appreciate what dependent types offered in terms of guiding us in writing our code, helping the compiler check our correctness, providing a better interface for users, and more.&lt;/p&gt;
&lt;p&gt;We also learned how to use singletons to work around some of Haskell’s fundamental limitations to let us “pattern match” on the structure of types, and how to use typeclasses to generate singletons reflecting the structure of types we are dealing with.&lt;/p&gt;
&lt;p&gt;(If you read &lt;a href=&quot;https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html&quot;&gt;Part 1&lt;/a&gt; &lt;em&gt;before&lt;/em&gt; the singletons section was re-written to use the &lt;a href=&quot;https://hackage.haskell.org/package/singletons&quot;&gt;singletons&lt;/a&gt; library, &lt;a href=&quot;https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html#singletons-and-induction&quot;&gt;here’s a link to the section&lt;/a&gt; in specific. This tutorial will assume familiarity with what is discussed there!)&lt;/p&gt;
&lt;p&gt;All of what we’ve dealt with so far has essentially been with types that are fixed at compile-time. All the networks we’ve made have had “static” types, with their sizes in their types indicated directly in the source code. In this post, we’re going to dive into the world of types that &lt;em&gt;depend&lt;/em&gt; on factors unknown until runtime, and see how dependent types in a strongly typed language like Haskell helps us write safer, more correct, and more maintainable code.&lt;/p&gt;
&lt;p&gt;This post was written for GHC 8 on stackage snapshot &lt;a href=&quot;https://www.stackage.org/nightly-2016-06-28&quot;&gt;nightly-2016-06-28&lt;/a&gt;, but should work with GHC 7.10 for the most part. All of the set-up instructions and caveats (like the &lt;em&gt;singletons-2.0.1&lt;/em&gt; bug affecting GHC 7.10 users and the unreleased &lt;em&gt;hmatrix&lt;/em&gt; version) are the same as for &lt;a href=&quot;https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html#setup&quot;&gt;part 1’s setup&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All of the code in this post is &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs&quot;&gt;downloadable as a standalone source file&lt;/a&gt; so you can follow along!&lt;/p&gt;
&lt;p&gt;A fair disclosure: a lot of this post doesn’t actually directly deal with machine learning or neural networks. Most of it will be learning general principles for working with dependent types through implementing things you’d want to do with neural networks. More stuff with ML will come in the next posts!&lt;/p&gt;
&lt;h2 id=&quot;types-at-runtime&quot;&gt;Types at Runtime&lt;/h2&gt;
&lt;p&gt;Recall the type we had for our neural networks:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;They’re of the form &lt;code&gt;Network i hs o&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the size of the input vector it expects, &lt;code&gt;hs&lt;/code&gt; is the list of hidden layer sizes, and &lt;code&gt;o&lt;/code&gt; is the size of the output vector it produces. Something of type &lt;code&gt;Network 10 &#39;[6, 4] 3&lt;/code&gt; is a network with 10 input nodes, two input layers of size 6 and 4, and 3 output nodes.&lt;/p&gt;
&lt;p&gt;This is great and all, but there’s an severe limitation to this: Haskell is a statically typed language, right? So doesn’t this mean that using a network requires that you know the entire structure of the network at compile-time?&lt;/p&gt;
&lt;p&gt;It’s conceivable that you might be able to have the input and output sizes known at compile-time, but it’s possible that you don’t care or know your hidden layer structure. You might load it from a configuration file, or have it depend on user input. You might even want to receive one over a network channel without knowing what the internal structure is. But can a type really depend on things that you can’t know until runtime?&lt;/p&gt;
&lt;p&gt;To illustrate more clearly:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;What hidden layer structure do you want?&amp;quot;&lt;/span&gt;
    hs  &lt;span class=&quot;ot&quot;&gt;&amp;lt;- readLn    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;]
    net &lt;span class=&quot;ot&quot;&gt;&amp;lt;- randomNet ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;???&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;-- what is ???&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- ...?&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We &lt;em&gt;want&lt;/em&gt; to put &lt;code&gt;hs&lt;/code&gt; there where &lt;code&gt;???&lt;/code&gt; is, but…&lt;code&gt;???&lt;/code&gt; has to be a type (of kind &lt;code&gt;[Nat]&lt;/code&gt;). &lt;code&gt;hs&lt;/code&gt; is a value (of type &lt;code&gt;[Integer]&lt;/code&gt;). It’s clear here that the &lt;em&gt;type&lt;/em&gt; of our network depends on something we can’t write down or decide until runtime.&lt;/p&gt;
&lt;h3 id=&quot;an-existential-crisis&quot;&gt;An Existential Crisis&lt;/h3&gt;
&lt;p&gt;There are two main ways to go about solving this issue in Haskell. We’ll look at both, and then see that they are really actually just two styles of doing the same thing.&lt;/p&gt;
&lt;h4 id=&quot;types-hiding-behind-constructors&quot;&gt;Types hiding behind constructors&lt;/h4&gt;
&lt;p&gt;Now, having the entire structure of your neural network in the type is nice and all for cool tricks like &lt;code&gt;randomNet&lt;/code&gt;…but do you &lt;em&gt;really&lt;/em&gt; want to work with this directly? After all, from the user’s perspective, the user really only ever needs to know &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;o&lt;/code&gt;: What vectors the network &lt;em&gt;expects&lt;/em&gt; and what vectors the network &lt;em&gt;outputs&lt;/em&gt;. In the end, a (feed-forward) Neural Network is really just a fancy &lt;code&gt;R i -&amp;gt; R o&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Remember, the main benefits of having the entire structure in the type was to help us &lt;em&gt;implement&lt;/em&gt; our functions more safely, with the compiler’s help, and also for cute return type polymorphism tricks like &lt;code&gt;randomNet&lt;/code&gt; and &lt;code&gt;getNet&lt;/code&gt; and some stronger documentation. The &lt;em&gt;user&lt;/em&gt; of the network really only benefits from the second two types of benefits.&lt;/p&gt;
&lt;p&gt;One practical downside of having the structure in the type is that you can’t store them in the same list or data structure. A &lt;code&gt;Network 10 &#39;[5,3] 1&lt;/code&gt; won’t share a list with a &lt;code&gt;Network 10 &#39;[5,2] 1&lt;/code&gt;, despite having the same inputs/outputs (and API).&lt;/p&gt;
&lt;p&gt;Imagine that we had written a &lt;code&gt;Network&lt;/code&gt; type that &lt;em&gt;didn’t&lt;/em&gt; have the internal structure in the type —&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Recall that our issue earlier was that we had to write &lt;code&gt;Network i ??? o&lt;/code&gt;, but we had no idea what to put in for &lt;code&gt;???&lt;/code&gt;. But, if we worked with an &lt;code&gt;OpaqueNet i o&lt;/code&gt;, we wouldn’t even care! We wouldn’t have to tell GHC what the internal structure is.&lt;/p&gt;
&lt;p&gt;I’d actually argue that &lt;code&gt;OpaqueNet&lt;/code&gt; might often be the more useful type to offer to your users (or to use yourself), because it only exposes the types that are &lt;em&gt;relevant&lt;/em&gt; to its usage/API. You can store them in a list or MVar — &lt;code&gt;[OpaqueNet 10 3]&lt;/code&gt; and &lt;code&gt;MVar (OpaqueNet 10 3)&lt;/code&gt;, serialize/deserialize them without knowing their internal structure in advance (&lt;code&gt;loadNet :: FilePath -&amp;gt; IO (OpaqueNet 10 3)&lt;/code&gt;), etc. (if you wanted to load a &lt;code&gt;Network&lt;/code&gt;, you would need to know exactly what internal structure was stored, in advance). Though &lt;code&gt;Network&lt;/code&gt; is a much easier type to &lt;em&gt;implement&lt;/em&gt;, &lt;code&gt;OpaqueNet&lt;/code&gt; is a often a more ideal type to &lt;em&gt;use&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We can implement our vision for &lt;code&gt;OpaqueNet&lt;/code&gt; as an “existential” wrapper over &lt;code&gt;Network&lt;/code&gt;, actually:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L110-111&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, if you have &lt;code&gt;net :: Network 6 &#39;[10,6,3] 2&lt;/code&gt;, you can create &lt;code&gt;ONet net :: OpaqueNet 6 2&lt;/code&gt;. When you use the &lt;code&gt;ONet&lt;/code&gt; constructor, the structure of the hidden layers disappears from the type!&lt;/p&gt;
&lt;p&gt;We can use the network inside by &lt;em&gt;pattern matching&lt;/em&gt; on &lt;code&gt;ONet&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L113-125&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;runOpaqueNet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
             &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o
             &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; i
             &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o
runOpaqueNet (&lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; n) x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runNet n x

&lt;span class=&quot;ot&quot;&gt;numHiddens ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
numHiddens (&lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; n) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go n
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    go ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
    go &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; _      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
        _ &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; go n&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the &lt;em&gt;ScopedTypeVariables&lt;/em&gt; extension, we can even bring &lt;code&gt;hs&lt;/code&gt; back into scope, as in:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; oN &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;n ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This pattern is sometimes called the &lt;strong&gt;dependent pair&lt;/strong&gt;, because pattern matching on &lt;code&gt;ONet&lt;/code&gt; yields the hidden &lt;strong&gt;existentially quantified&lt;/strong&gt; type (&lt;code&gt;hs&lt;/code&gt;) and also a value whose type is based on it (&lt;code&gt;Network i hs o&lt;/code&gt;). It’s like &lt;code&gt;hs&lt;/code&gt; “paired” with &lt;code&gt;Network i hs o&lt;/code&gt;. Pattern match on the results to give both the type (&lt;code&gt;hs&lt;/code&gt;) &lt;em&gt;and&lt;/em&gt; the data structure. (To make this more explicit, we could have implemented it as &lt;code&gt;ONet :: Sing hs -&amp;gt; Network i hs o -&amp;gt; OpaqueNet i o&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;And here’s the key to making this all work: once you pattern match on &lt;code&gt;ONet&lt;/code&gt;, you have to handle the &lt;code&gt;hs&lt;/code&gt; in a &lt;em&gt;completely polymorphic way&lt;/em&gt;. You’re not allowed to assume anything about &lt;code&gt;hs&lt;/code&gt;…you have to provide a completely parametrically polymorphic way of dealing with it!&lt;/p&gt;
&lt;p&gt;For example, this function is completely &lt;em&gt;not&lt;/em&gt; ok:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;bad ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o
bad (&lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; n) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; n            &lt;span class=&quot;co&quot;&gt;-- nope, not ok at all.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Why not? Well, a type signature like &lt;code&gt;OpaqueNet i o -&amp;gt; Network i hs o&lt;/code&gt; means that the &lt;em&gt;caller&lt;/em&gt; can decide what &lt;code&gt;hs&lt;/code&gt; can be — just like &lt;code&gt;read :: Read a =&amp;gt; String -&amp;gt; a&lt;/code&gt;, where the caller decides what &lt;code&gt;a&lt;/code&gt; is.&lt;/p&gt;
&lt;p&gt;Of course, this isn’t the case in the way we’ve written the function…the function can only return a &lt;em&gt;specific&lt;/em&gt; &lt;code&gt;hs&lt;/code&gt; (namely, the &lt;code&gt;hs&lt;/code&gt; of the network that &lt;code&gt;ONet&lt;/code&gt; hides). The &lt;em&gt;caller&lt;/em&gt; has to accommodate whatever is inside &lt;code&gt;ONet&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;the-universal-and-the-existential&quot;&gt;The Universal and the Existential&lt;/h4&gt;
&lt;p&gt;We just brushed here on something at the heart of using existential types in Haskell: the issue of who has the power to decide what the types will be instantiated as. Most polymorphic functions you work with in Haskell are “universally qualified”. For example, for a function like&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;map&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are universally quantified, which means that the person who &lt;em&gt;uses&lt;/em&gt; &lt;code&gt;map&lt;/code&gt; gets to decide what &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are. To be more explicit, that type signature can be written as:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;map&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; forall a b&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that &lt;code&gt;map&lt;/code&gt; is defined in a way that will work for &lt;em&gt;any&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; that the &lt;em&gt;caller&lt;/em&gt; wants. As a caller, you can request:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;map&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;)    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;]    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;]
map&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Void&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Void&lt;/span&gt;]
map&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or anything else!&lt;/p&gt;
&lt;p&gt;Consequentially, the function has to be implemented in a way that will work for &lt;em&gt;any&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. The function’s implementation has the burden of being flexible enough to handle whatever the caller asks for.&lt;/p&gt;
&lt;p&gt;But, for a function like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;foo ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the caller can choose what &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;o&lt;/code&gt; are, the &lt;em&gt;function&lt;/em&gt; gets to choose what &lt;code&gt;hs&lt;/code&gt; (in the hidden &lt;code&gt;Network i hs o&lt;/code&gt;) is. If I want to &lt;em&gt;use&lt;/em&gt; the thing that &lt;code&gt;foo&lt;/code&gt; returns…then &lt;em&gt;I&lt;/em&gt; have to be flexible. &lt;em&gt;I&lt;/em&gt; have the burden of being flexible enough to handle whatever &lt;code&gt;hs&lt;/code&gt; the &lt;em&gt;function&lt;/em&gt; returns.&lt;/p&gt;
&lt;p&gt;In summary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;For universally quantified types, the &lt;em&gt;caller&lt;/em&gt; chooses the type being instanced, and the &lt;em&gt;function’s implementation&lt;/em&gt; has to accommodate any choice.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For existentially quantified types, the &lt;em&gt;function’s implementation&lt;/em&gt; chooses the type being instanced, and the &lt;em&gt;caller&lt;/em&gt; has to accommodate any choice.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Indeed, we saw earlier that if we ever wanted to &lt;em&gt;use&lt;/em&gt; the &lt;code&gt;Network i hs o&lt;/code&gt; inside the &lt;code&gt;OpaqueNet i o&lt;/code&gt;, we were forced to deal with it in a parametrically polymorphic way. We had to be able to handle &lt;em&gt;any&lt;/em&gt; &lt;code&gt;hs&lt;/code&gt; that the &lt;code&gt;ONet&lt;/code&gt; could throw at us!&lt;/p&gt;
&lt;h4 id=&quot;a-familiar-friend&quot;&gt;A familiar friend&lt;/h4&gt;
&lt;p&gt;I called &lt;code&gt;OpaqueNet i o&lt;/code&gt; a “dependent pair” earlier, pairing &lt;code&gt;hs&lt;/code&gt; with &lt;code&gt;Network i hs o&lt;/code&gt;. But there’s another common term for it: a &lt;strong&gt;dependent sum&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;People familiar with Haskell might recognize that “sum types” are &lt;code&gt;Either&lt;/code&gt;-like types that can be one thing or another. Sum types are one of the first things you learn about in Haskell — heck, even &lt;code&gt;Maybe a&lt;/code&gt; is the sum of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;()&lt;/code&gt;. Dependent pairs/existential types actually are very similar to &lt;code&gt;Either&lt;/code&gt;/sum types, in spirit, and it might help to see the parallel so that you can see that they’re nothing scary, and that the fundamentals/intuition of working with existential types in Haskell is no different than working with &lt;code&gt;Either&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;If I had:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;foo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I have to handle the result for both the case where I get an &lt;code&gt;Int&lt;/code&gt; and the case where I get a &lt;code&gt;Bool&lt;/code&gt;. The &lt;em&gt;function&lt;/em&gt; gets to pick what type I have to handle (&lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Bool&lt;/code&gt;), and &lt;em&gt;I&lt;/em&gt; have to adapt to whatever it returns. Sound familiar? In fact, you can even imagine that &lt;code&gt;OpaqueNet i o&lt;/code&gt; as being just a infinite &lt;em&gt;Either&lt;/em&gt; over &lt;code&gt;&#39;[]&lt;/code&gt;, &lt;code&gt;&#39;[1]&lt;/code&gt;, &lt;code&gt;&#39;[1,2]&lt;/code&gt;, etc.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Remember that the basic way of handling an &lt;code&gt;Either&lt;/code&gt; and figuring out what the type of the value is inside is through &lt;em&gt;pattern matching&lt;/em&gt; on it. You can’t know if an &lt;code&gt;Either Int Bool&lt;/code&gt; contains an &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Bool&lt;/code&gt; until you pattern match. But, once you do, all is revealed, and GHC lets you take advantage of knowing the type.&lt;/p&gt;
&lt;p&gt;For &lt;code&gt;OpaqueNet i o&lt;/code&gt;, it’s the same! You don’t know the actual type of the &lt;code&gt;Network i hs o&lt;/code&gt; it contains until you &lt;em&gt;pattern match&lt;/em&gt; on the network (This time, it’s a “dependent pattern match”). Once you pattern match on it, all is revealed…and GHC lets you take advantage of knowing the type!&lt;/p&gt;
&lt;h3 id=&quot;reification&quot;&gt;Reification&lt;/h3&gt;
&lt;p&gt;For simplicity, let’s re-write &lt;code&gt;randomNet&lt;/code&gt; the more sensible way — with the explicit singleton input style:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L79-87&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomNet&amp;#39; ::&lt;/span&gt; forall m i hs o&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
           &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; hs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o)
randomNet&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;            &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;     &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights
    &lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; ss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; randomNet&amp;#39; ss

&lt;span class=&quot;ot&quot;&gt;randomNet ::&lt;/span&gt; forall m i hs o&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; hs, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
          &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o)
randomNet &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; randomNet&amp;#39; sing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We use &lt;code&gt;sing :: SingI hs =&amp;gt; Sing hs&lt;/code&gt; to go call the &lt;code&gt;Sing hs -&amp;gt;&lt;/code&gt;-style function from the &lt;code&gt;SingI hs =&amp;gt;&lt;/code&gt; one.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now, we still need to somehow get our list of integers to the type level so that we can create a &lt;code&gt;Network i hs o&lt;/code&gt; to stuff into our &lt;code&gt;ONet&lt;/code&gt;. For that, the &lt;em&gt;singletons&lt;/em&gt; library offers the necessary tooling. It gives us &lt;code&gt;SomeSing&lt;/code&gt;, which is a lot like our &lt;code&gt;OpaqueNet&lt;/code&gt; above, wrapping the &lt;code&gt;Sing a&lt;/code&gt; inside an existential data constructor. &lt;code&gt;toSing&lt;/code&gt; takes the term-level value (for us, an &lt;code&gt;[Integer]&lt;/code&gt;) and returns a &lt;code&gt;SomeSing&lt;/code&gt; wrapping the type-level value (for us, a &lt;code&gt;[Nat]&lt;/code&gt;). When we pattern match on the &lt;code&gt;SomeSing&lt;/code&gt; constructor, we get &lt;code&gt;a&lt;/code&gt; in scope!&lt;/p&gt;
&lt;p&gt;As of &lt;em&gt;singletons-2.2&lt;/em&gt; and GHC 8&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;, &lt;code&gt;SomeSing&lt;/code&gt; is implemented as:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;a ::&lt;/span&gt; k) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; k&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And you have:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;foo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
foo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;bar ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
bar &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pattern matching looks like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;How many cats do you own?&amp;quot;&lt;/span&gt;
    c &lt;span class=&quot;ot&quot;&gt;&amp;lt;- readLn ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; toSing c &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, inside the case statement branch (the &lt;code&gt;...&lt;/code&gt;), we have &lt;em&gt;type&lt;/em&gt; &lt;code&gt;n :: Nat&lt;/code&gt; in scope! And by pattern matching on the &lt;code&gt;SNat&lt;/code&gt; constructor, we also have a &lt;code&gt;KnownNat n&lt;/code&gt; instance (As discussed in &lt;a href=&quot;https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html#on-typeclasses-and-dictionaries&quot;&gt;previous part&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;toSing&lt;/code&gt; works using a simple typeclass mechanism with an associated type whose job is to connect the types of values with the kinds of their singletons. It associates &lt;code&gt;Bool&lt;/code&gt; (the type) with &lt;code&gt;Bool&lt;/code&gt; (the kind), &lt;code&gt;Integer&lt;/code&gt; (the type) with &lt;code&gt;Nat&lt;/code&gt; (the kind), &lt;code&gt;[Integer]&lt;/code&gt; (the type) with &lt;code&gt;[Nat]&lt;/code&gt; (the kind), etc., and it does it with simple applications of type families (here’s a &lt;a href=&quot;https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html&quot;&gt;nice tutorial on type families&lt;/a&gt; courtesy of Oliver Charles, as a refresher). With it, we can convert any normal value &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;a&lt;/code&gt; to a singleton representing type &lt;code&gt;x&lt;/code&gt; with kind &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We now have enough to write our &lt;code&gt;randomONet&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L127-131&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomONet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
           &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;]
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o)
randomONet hs &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; toSing hs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                  &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; ss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomNet&amp;#39; ss&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This process of bringing a term-level value into the type level is known in Haskell as &lt;strong&gt;reification&lt;/strong&gt;. With this, our original goal is (finally) within reach:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L205-213&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;What hidden layer structure do you want?&amp;quot;&lt;/span&gt;
    hs &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; readLn
    n  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; randomONet hs
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; n &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;net ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; hs &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
        print net
        &lt;span class=&quot;co&quot;&gt;-- blah blah stuff with our dynamically generated net&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;the-boundary&quot;&gt;The Boundary&lt;/h4&gt;
&lt;p&gt;With the power of existentially quantified types (like in &lt;code&gt;SomeSing&lt;/code&gt;), we essentially gained the ability to work with types that depend on runtime results.&lt;/p&gt;
&lt;p&gt;In a way, you can consider the &lt;code&gt;toSing&lt;/code&gt; and the &lt;code&gt;SomeSing&lt;/code&gt; as our “boundary” between the “untyped world” and the “typed world”. This layer (and the process of reification) cleanly separates the two.&lt;/p&gt;
&lt;p&gt;This boundary can be thought of as a lot like the boundary we talk about between “pure” functions and values and “impure” (IO, etc.) ones. People say to always write as much of your program as possible in the “pure” world — to separate and pull out as much logic as you can to be pure logic. That’s one of the first things you learn about as a Haskell programmer: how to separate logic that &lt;em&gt;can&lt;/em&gt; be pure from logic that is “impure” (IO, etc.), and then finally combine them at the very end, as late as possible.&lt;/p&gt;
&lt;p&gt;It’s easy to think that just because the final program is going to “be in IO in the end anyway”, there isn’t any point in separating out pure and impure parts of your program logic. But we know that we gain separation of concerns, the increased ability to reason with your code and analyze what it does, the compiler’s ability to check what you write, the limitation of implementations, etc.&lt;/p&gt;
&lt;p&gt;You can think of the general philosophy of working with typed/untyped worlds as being the same thing. You try to write as much of your program as possible in the “typed” world, like we did in Part 1. Take advantage of the increased ability to reason with your code, parametric polymorphism helping you &lt;em&gt;write&lt;/em&gt; your code, limit your implementations, nab you compiler help, etc. All of those are benefits of working in the typed world.&lt;/p&gt;
&lt;p&gt;Then, write what you absolutely must in your “untyped” world, such as dealing with values that pop up at runtime like the &lt;code&gt;[Integer]&lt;/code&gt; above.&lt;/p&gt;
&lt;p&gt;Finally, at the very end, &lt;em&gt;unite&lt;/em&gt; them at the boundary. Pass the control football from the untyped world to the typed world!&lt;/p&gt;
&lt;p&gt;The great part about this all is that GHC and the type system is there at every step holding your hand, guiding you as you implement your programs and making sure everything is type-safe and fits together! (This, after all, is why dependently typed programming with dynamically generated types is &lt;em&gt;not&lt;/em&gt; the same thing as “&lt;em&gt;dynamically&lt;/em&gt; typed programming”!)&lt;/p&gt;
&lt;h3 id=&quot;continuation-based-existentials&quot;&gt;Continuation-Based Existentials&lt;/h3&gt;
&lt;p&gt;There’s another way in Haskell that we work with existential types that can be more natural to use in a lot of cases. Remember that when we pattern match on an existential data type, we have to work with the values in the constructor in a parametrically polymorphic way. For example, if we had:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;oNetToFoo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
oNetToFoo (&lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; n) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;f&lt;/code&gt; has to take a &lt;code&gt;Network i hs o&lt;/code&gt; but deal with it in a way that works &lt;em&gt;for all&lt;/em&gt; &lt;code&gt;hs&lt;/code&gt;. It can’t be written for &lt;em&gt;only&lt;/em&gt; &lt;code&gt;&#39;[5]&lt;/code&gt; or &lt;em&gt;only&lt;/em&gt; &lt;code&gt;&#39;[6,3]&lt;/code&gt;…it has to work for &lt;em&gt;any&lt;/em&gt; &lt;code&gt;hs&lt;/code&gt;. That’s the whole “existential vs. universal quantification” thing we just talked about.&lt;/p&gt;
&lt;p&gt;Well, we could really also just skip the constructor altogether and represent an existential type as something &lt;em&gt;taking&lt;/em&gt; the continuation &lt;code&gt;f&lt;/code&gt; and giving it what it needs.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L154-154&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&amp;#39;&lt;/span&gt; i o r &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (forall hs&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“Tell me how you would make an &lt;code&gt;r&lt;/code&gt; if you had a &lt;code&gt;Network i hs o&lt;/code&gt; (that works for any &lt;code&gt;hs&lt;/code&gt;) and I’ll make it for you!”&lt;/p&gt;
&lt;p&gt;(This takes advantage of Rank-N types. If you’re unfamiliar with them, Gregor Riegler has a &lt;a href=&quot;http://sleepomeno.github.io/blog/2014/02/12/Explaining-Haskell-RankNTypes-for-all/&quot;&gt;nice tutorial&lt;/a&gt; on the subject.)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Using&lt;/em&gt; these types is very similar to using the constructor-style ones:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L159-176&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;runOpaqueNet&amp;#39; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
              &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&amp;#39;&lt;/span&gt; i o (&lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o)
              &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; i
              &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o
runOpaqueNet&amp;#39; oN x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; oN (\n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; runNet n x)
&lt;span class=&quot;co&quot;&gt;--            :: ((forall hs. Network i hs o -&amp;gt; R o) -&amp;gt; R o)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--            -&amp;gt; R i&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--            -&amp;gt; R o&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;numHiddens&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&amp;#39;&lt;/span&gt; i o &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
numHiddens&amp;#39; oN &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; oN go
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    go ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
    go &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; _      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
        _ &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; go n&amp;#39;
&lt;span class=&quot;co&quot;&gt;--          :: ((forall hs. Network i hs o -&amp;gt; Int) -&amp;gt; Int)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--          -&amp;gt; Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This “continuation transformation” is formally known as &lt;strong&gt;skolemization&lt;/strong&gt;.&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We can “wrap” a &lt;code&gt;Network i hs o&lt;/code&gt; into an &lt;code&gt;OpaqueNet&#39; i o r&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L156-157&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;oNet&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&amp;#39;&lt;/span&gt; i o r
oNet&amp;#39; n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \f &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let’s write a version of &lt;code&gt;randomONet&lt;/code&gt; that returns a continuation-style existential:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;withRandomONet&amp;#39; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
                &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;]
                &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall hs&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m r)
                &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m r
&lt;span class=&quot;co&quot;&gt;--         aka, =&amp;gt; [Integer]&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--              -&amp;gt; OpaqueNet&amp;#39; i o (m r)&lt;/span&gt;
withRandomONet&amp;#39; hs f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; toSing hs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                         &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; ss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
                           net &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; randomNet&amp;#39; ss
                           f net&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But, hey, because we’re skolemizing everything, let’s do it with the skolemized version of &lt;code&gt;toSing&lt;/code&gt;/&lt;code&gt;SomeSing&lt;/code&gt;, &lt;code&gt;withSomeSing&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- a version of `toSing` that returns a skolemized `SomeSing`&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;withSomeSing ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;]
             &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall (&lt;span class=&quot;ot&quot;&gt;hs ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;])&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; hs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r)
             &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because why not? Skolemize all the things!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L178-186&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;withRandomONet&amp;#39; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
                &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;]
                &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall hs&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m r)
                &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m r
&lt;span class=&quot;co&quot;&gt;--         aka, =&amp;gt; [Integer]&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--              -&amp;gt; OpaqueNet&amp;#39; i o (m r)&lt;/span&gt;
withRandomONet&amp;#39; hs f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withSomeSing hs &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \ss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
                         net &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; randomNet&amp;#39; ss
                         f net&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can use it to do the same things we used the constructor-based existential for, as well…and, in a way, it actually seems (oddly) more natural.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L215-221&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;main&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;What hidden layer structure do you want?&amp;quot;&lt;/span&gt;
    hs &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; readLn
    withRandomONet&amp;#39; hs &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \(&lt;span class=&quot;ot&quot;&gt;net ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; hs &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
      print net
      &lt;span class=&quot;co&quot;&gt;-- blah blah stuff with our dynamically generated net&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Like the case statement pattern match represented the lexical “wall”/“boundary” between the untyped and typed world when using constructor-style existentials, the &lt;code&gt;... $ \net -&amp;gt; ...&lt;/code&gt; can be thought of the “wall” for the continuation-style existentials.&lt;/p&gt;
&lt;h2 id=&quot;a-tale-of-two-styles&quot;&gt;A Tale of Two Styles&lt;/h2&gt;
&lt;p&gt;We’ve just discussed two ways of doing the same thing. Two styles of representing/working with existential types. The two are equivalent, in that you can always “convert” between one or the other, but the choice of which one you use/reach for/offer can make a difference in code clarity. After working with both styles a lot (sometimes, libraries only offer one style), you start to get a feel for which one you like more in which situations. In the end, I don’t think there are any hard or fast rules. Just use whichever one you feel is more readable!&lt;/p&gt;
&lt;p&gt;That being said, here are some general Pros and Cons that I’ve noticed over the years:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Most obviously, continuation-style doesn’t require you to define a throwaway data type/constructor. While new types are cheap in Haskell, they force your users to learn a new set of types and constructors for every single existential type you return. If you or the library you’re writing uses/returns a &lt;em&gt;lot&lt;/em&gt; of different existentially qualified types, all those extra dumb wrappers are a huge hassle.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Continuation-style existentials are in general smoother to use than constructor-style ones when functions &lt;em&gt;return&lt;/em&gt; existentials. Especially if you intend to immediately use them, continuation-style basically saves you an extraneous pattern match.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When you have to use several existentials at once, continuation-style is much better because each nested existential doesn’t force another level of indentation:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;foo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withSomeSing x &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \sx &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
      withSomeSing y &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \sy &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
      withSomeSing z &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \sz &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;vs.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;foo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; toSing x &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; sx &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; toSing y &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; sy &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
              &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; toSing z &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; sz &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                  &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Every time you nest a case statement, you actually waste &lt;em&gt;two&lt;/em&gt; levels of indentation, which can be annoying even at 2-space indentation. But you don’t need &lt;em&gt;any&lt;/em&gt; to nest in the continuation style!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you’re working monadically, though, you can take advantage of do notation and &lt;em&gt;ScopedTypeVariables&lt;/em&gt; for a nicer style that doesn’t require any nesting at all:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; n1 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; randomONet [&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
    &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; n2 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; randomONet [&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
    &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; n3 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; randomONet [&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
    hs &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; readLn
    &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;n4 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; hs &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; randomONet hs
    &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is arguably nicer than&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withRandomONet&amp;#39; [&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \n1 &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
       withRandomONet&amp;#39; [&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \n2 &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
       withRandomONet&amp;#39; [&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \n3 &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
         hs &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; readLn
         withRandomONet&amp;#39; hs &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \(&lt;span class=&quot;ot&quot;&gt;n4 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; hs &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
           &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A lot of libraries return existentials in &lt;code&gt;Maybe&lt;/code&gt;’s (&lt;a href=&quot;http://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-TypeLits.html#v:someNatVal&quot;&gt;base is guilty&lt;/a&gt;), so this trick can be useful for those, too!&lt;/p&gt;
&lt;p&gt;This trick is less useful for functions like &lt;code&gt;toSing&lt;/code&gt; where things are &lt;em&gt;not&lt;/em&gt; returned in a monad. You could wrap it in Identity, but that’s kind of silly:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;foo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runIdentity &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; sx &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Identity&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; toSing x
        &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; sy &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Identity&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; toSing y
        &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; sz &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Identity&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; toSing z
        return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Constructor-style is necessary for writing typeclass instances. You can’t write a &lt;code&gt;Show&lt;/code&gt; instance for &lt;code&gt;(forall hs. Network i hs o -&amp;gt; r) -&amp;gt; r&lt;/code&gt;, but you can write one for &lt;code&gt;OpaqueNet i o&lt;/code&gt;. We’ll also be writing &lt;code&gt;Binary&lt;/code&gt; instances later for serialization/deserialization, and it all only works in constructor-style.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Haskell doesn’t allow you to use Rank-N types as arguments to type constructors, so you can have &lt;code&gt;[OpaqueNet i o]&lt;/code&gt;, but &lt;em&gt;not&lt;/em&gt; &lt;code&gt;[OpaqueNet&#39; i o r]&lt;/code&gt; or &lt;code&gt;[(forall hs. Network i hs o -&amp;gt; r) -&amp;gt; r]&lt;/code&gt;. You can have &lt;code&gt;MVar (OpaqueNet i o)&lt;/code&gt;, but not &lt;code&gt;MVar ((forall hs. Network i hs o -&amp;gt; r) -&amp;gt; r)&lt;/code&gt;. The latter are known as &lt;em&gt;impredicative&lt;/em&gt; types, which are a big no-no in GHC Haskell. Don’t even go there! The constructor style is necessary in these situations.&lt;/p&gt;
&lt;p&gt;If the type constructor is a Monad, you can get away with a ContT-style skolemization, like &lt;code&gt;(forall hs. Network i hs o -&amp;gt; [r]) -&amp;gt; [r]&lt;/code&gt; and &lt;code&gt;(forall hs. Network i hs o -&amp;gt; IO r) -&amp;gt; IO r&lt;/code&gt;. But this doesn’t work for &lt;code&gt;MVar&lt;/code&gt; and other useful type constructors you might want to put &lt;code&gt;OpaqueNet&lt;/code&gt; in.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When writing functions that &lt;em&gt;take&lt;/em&gt; existentials as inputs, the constructor-style is arguably more natural. But barely.&lt;/p&gt;
&lt;p&gt;For example, we wrote a function to find the number of hidden layers in a network earlier:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;numHiddens ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But the continuation-style version has a slightly messier type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;numHiddens&amp;#39; ::&lt;/span&gt; ((forall hs&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
            &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Even with with the type synonym, it’s still a little awkward:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;numHiddens&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&amp;#39;&lt;/span&gt; i o &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is why you’ll encounter many more functions &lt;em&gt;returning&lt;/em&gt; continuation-style existentials in libraries than &lt;em&gt;taking&lt;/em&gt; them, for the most part.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These are just general principles, not hard fast rules. This list is nowhere near exhaustive and reflects my current progress in my journey towards a dependently typed lifestyle. If you come back in a month, you might see more things listed here!&lt;/p&gt;
&lt;p&gt;All said, I do find myself very happy when I see that a library I’m using offers &lt;em&gt;both&lt;/em&gt; styles for me to use. And I’ve been known to submit PR’s to a library to have it offer one style or another, if it’s lacking.&lt;/p&gt;
&lt;p&gt;Be judicious. If you’re writing a library, don’t spam it with too many throwaway constructors. After a while, you’ll begin to intuitively see which style shines in which situations! (And, in some case, there might not even be a definitive “better” style to use.)&lt;/p&gt;
&lt;h2 id=&quot;serializing-networks&quot;&gt;Serializing Networks&lt;/h2&gt;
&lt;p&gt;To drive things home, let’s apply what we learned about existential types and reification to another simple application: serialization.&lt;/p&gt;
&lt;h3 id=&quot;recap-on-the-binary-library&quot;&gt;Recap on the Binary Library&lt;/h3&gt;
&lt;p&gt;Serializing networks of &lt;em&gt;known&lt;/em&gt; size — whose sizes are statically in their types — is pretty straightforward, and its ease is one of the often-quoted advantages of having sizes in your types.&lt;a href=&quot;#fn5&quot; class=&quot;footnoteRef&quot; id=&quot;fnref5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; I’m going to be using the &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/binary&quot;&gt;binary&lt;/a&gt;&lt;/em&gt; library, which offers a very standard typeclass-based approach for serializing and deserializing data. There are a lot of tutorials online (and I even &lt;a href=&quot;https://blog.jle.im/entry/streaming-huffman-compression-in-haskell-part-2-binary.html&quot;&gt;wrote a small one&lt;/a&gt; myself a few years ago), but a very high-level view is that the library offers monads (&lt;code&gt;Get&lt;/code&gt;, &lt;code&gt;Put&lt;/code&gt;) for describing serialization schemes and also a typeclass used to provide serialization instructions for different types.&lt;/p&gt;
&lt;p&gt;In practice, we usually don’t write our own instances from scratch. Instead, we use GHC’s generics features to give us instances for free:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L25-30&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; wBiases ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o)
                     ,&lt;span class=&quot;ot&quot;&gt; wNodes  ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;L&lt;/span&gt; o i)
                     }
  &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Generic&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Binary&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For simple types like &lt;code&gt;Weights&lt;/code&gt;, which simply contain serializable things, the &lt;em&gt;binary&lt;/em&gt; library is smart enough to write your instances automatically for you! This gives us &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;get ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Get&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o)

&lt;span class=&quot;ot&quot;&gt;put ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Put&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, for GADTs like &lt;code&gt;Network&lt;/code&gt;, we have to things manually.&lt;/p&gt;
&lt;h4 id=&quot;serializing-network&quot;&gt;Serializing &lt;code&gt;Network&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;Taking advantage of having the entire structure in the type, &lt;code&gt;put&lt;/code&gt; is simple:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L89-94&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;putNet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Put&lt;/span&gt;
putNet &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w     &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; put w
    w &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; put w &lt;span class=&quot;fu&quot;&gt;*&amp;gt;&lt;/span&gt; putNet n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If it’s an &lt;code&gt;O w&lt;/code&gt;, just serialize the &lt;code&gt;w&lt;/code&gt;. If it’s a &lt;code&gt;w :&amp;amp;~ net&lt;/code&gt;, serialize the &lt;code&gt;w&lt;/code&gt; then the rest of the &lt;code&gt;net&lt;/code&gt;. Normally, we might have to put a “flag” to tell what constructor we serializing, so that the deserializer can know what constructor to deserialize at every step. But for &lt;code&gt;Network&lt;/code&gt;, we don’t have to:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L96-101&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;getNet ::&lt;/span&gt; forall i hs o&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; hs
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Get&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o)
getNet &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;            &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;     &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; get
    &lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; ss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; get &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; getNet ss&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;getNet&lt;/code&gt; doesn’t need flags because we already &lt;em&gt;know&lt;/em&gt; how many &lt;code&gt;:&amp;amp;~&lt;/code&gt; layers to expect &lt;em&gt;just from the type&lt;/em&gt;. If we want to deserialize a &lt;code&gt;Network 5 &#39;[10,6,3] 2&lt;/code&gt;, we &lt;em&gt;know&lt;/em&gt; we want three &lt;code&gt;(:&amp;amp;~)&lt;/code&gt;’s and one &lt;code&gt;O&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getNet&lt;/code&gt; is written similarly to how we wrote &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L79-83&quot;&gt;&lt;code&gt;randomNet&#39;&lt;/code&gt;&lt;/a&gt;. We “pattern match” on &lt;code&gt;hs&lt;/code&gt; (using singletons) to get the constructors we are expecting to deserialize and just follow what the singleton’s structure tells us.&lt;/p&gt;
&lt;p&gt;To write a &lt;code&gt;Binary&lt;/code&gt; instance for &lt;code&gt;Network&lt;/code&gt;, we can’t have &lt;code&gt;get&lt;/code&gt; take a &lt;code&gt;Sing hs&lt;/code&gt; input — that’d change the arity/type of the function. We have to switch to &lt;code&gt;SingI&lt;/code&gt;-style had have their &lt;code&gt;Binary&lt;/code&gt; instances require a &lt;code&gt;SingI hs&lt;/code&gt; constraint.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L103-105&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; hs, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Binary&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    put &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; putNet
    get &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; getNet sing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;serializating-opaquenet&quot;&gt;Serializating &lt;code&gt;OpaqueNet&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;It’s arguably much more useful to serialize/deserialize &lt;code&gt;OpaqueNet&lt;/code&gt;s. Between different iterations of your program, you might have the same inputs/outputs, but want to try out different internal structures. You’d want to store them and access them uniformly, or send them over a network without requiring the receiver to know the internal structure beforehand. Remember, you can’t even &lt;em&gt;load&lt;/em&gt; a &lt;code&gt;Network i hs o&lt;/code&gt; without knowing its complete structure!&lt;/p&gt;
&lt;p&gt;Because the complete structure of the network is not in the type, we need to encode it as a flag in the binary serialization so that the deserializer will know what constructors to expect and deserialize. We can write a simple function to get the &lt;code&gt;[Integer]&lt;/code&gt; of a network’s structure:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L72-77&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;hiddenStruct ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;]
hiddenStruct &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; _    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; []
    _ &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;n&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; h hs&amp;#39; o)
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; natVal (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;h)
            &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; hiddenStruct n&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Recall that &lt;code&gt;natVal :: KnownNat n =&amp;gt; Proxy n -&amp;gt; Integer&lt;/code&gt; returns the value-level &lt;code&gt;Integer&lt;/code&gt; corresponding to the type-level &lt;code&gt;n :: Nat&lt;/code&gt;. (I’m also using GHC 8’s fancy &lt;em&gt;TypeApplications&lt;/em&gt; syntax, and &lt;code&gt;Proxy @h&lt;/code&gt; is the same as &lt;code&gt;Proxy :: Proxy h&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;natVal&lt;/code&gt; and &lt;code&gt;hiddenStruct&lt;/code&gt; are kind of interesting — they take type-level information (&lt;code&gt;n&lt;/code&gt;, &lt;code&gt;hs&lt;/code&gt;) and turns them into term-level values (&lt;code&gt;Integer&lt;/code&gt;s, &lt;code&gt;[Integer]&lt;/code&gt;s). They are the opposites of our reification functions (like &lt;code&gt;toSing&lt;/code&gt;). Going from the “type level” to the “value level” is known in Haskell as &lt;strong&gt;reflection&lt;/strong&gt;, and is the dual concept of reification. (The &lt;em&gt;singletons&lt;/em&gt; library offers reflectors for all of its singletons, as &lt;code&gt;fromSing&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;That’s all we need!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L133-138&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;putONet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
        &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Put&lt;/span&gt;
putONet (&lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; net) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    put (hiddenStruct net)
    putNet net&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“Put the structure (as a binary flag), and then put the network itself.”&lt;/p&gt;
&lt;p&gt;Now, to deserialize, we want to &lt;em&gt;load&lt;/em&gt; the list of &lt;code&gt;Integer&lt;/code&gt;s and reify it back to the type level to know what type of network we’re expecting to load:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L140-145&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;getONet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
        &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Get&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o)
getONet &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    hs &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; get
    withSomeSing hs &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \ss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; getNet ss&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We load our flag, reify it, and once we’re back in the typed land again, we can do our normal business. Isn’t it nice that GHC is also there at every step to make sure we make the transition safely?&lt;/p&gt;
&lt;p&gt;Our final instance:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L147-149&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Binary&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    put &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; putONet
    get &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; getONet&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And, of course, we used the constructor-style existential this whole time instead of the continuation-style one because we can’t directly write typeclass instances for the latter.&lt;/p&gt;
&lt;h2 id=&quot;an-existence-for-all&quot;&gt;An Existence For All&lt;/h2&gt;
&lt;p&gt;We’ve learned about how to “cross” from the untyped world to the typed world and bring about contexts involving types that can depend on runtime factors. To me, this is really the point where dependently typed programming starts — when you start having to work with types that depend on run-time factors.&lt;/p&gt;
&lt;p&gt;We’ve already been able to reap a lot of benefits. All of the type safety we discovered in the last part is now available to us in a fully dynamic world, as well. We also learned the advantages of &lt;em&gt;separating&lt;/em&gt; the typed world from the untyped world and how the compiler helps us make the transition safely.&lt;/p&gt;
&lt;p&gt;But really, this is all just the &lt;em&gt;start&lt;/em&gt; of dependently typed programming. This is where things &lt;em&gt;really&lt;/em&gt; start to get fun.&lt;/p&gt;
&lt;p&gt;Stepping into this new world can be disorienting at first. There’s a lot of unexpected things that come up when we start working more with these fancy new types. We have to deal with types coming from different sources, convince the type system about their properties and relationships between them, and deal with a whole bunch of other concerns that just don’t happen when you program only at the value level. But don’t worry! Like all things, it will more naturally with practice.&lt;/p&gt;
&lt;p&gt;Now that we have existential types and run-time types out of the way, come back for the next post in the series, where we start to have the &lt;em&gt;real&lt;/em&gt; fun! :D&lt;/p&gt;
&lt;h4 id=&quot;exercises&quot;&gt;Exercises&lt;/h4&gt;
&lt;p&gt;Here are some fun exercises you can try, if you want to test your understanding! Links are to the solutions.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Implement &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L188-193&quot;&gt;&lt;code&gt;putONet&#39;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L195-203&quot;&gt;&lt;code&gt;getONet&#39;&lt;/code&gt;&lt;/a&gt; using the continuation-style existentials, instead.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Work with an existential wrapper over the &lt;em&gt;entire&lt;/em&gt; network structure (inputs and outputs, too):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeNet&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SNet&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
         &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o
         &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeNet&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(We need the &lt;code&gt;KnownNat&lt;/code&gt; constraints because of type erasure, to recover the original input/output dimensions back once we pattern match)&lt;/p&gt;
&lt;p&gt;And write:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A function to &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L231-234&quot;&gt;convert &lt;code&gt;SomeNet&lt;/code&gt;s to &lt;code&gt;OpaqueNet&lt;/code&gt;s&lt;/a&gt;. Return the &lt;code&gt;OpaqueNet&lt;/code&gt; with existentially quantified &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;o&lt;/code&gt; in continuation-style. (You can write a data type to return it in constructor-style, too, for funsies.)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L236-245&quot;&gt;&lt;code&gt;randomSNet&lt;/code&gt;&lt;/a&gt;, returning &lt;code&gt;m SomeNet&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;While you’re at it, write it to return &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L247-258&quot;&gt;a random continuation-style &lt;code&gt;SomeNet&lt;/code&gt;, too&lt;/a&gt;! (See the type of &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L178-186&quot;&gt;&lt;code&gt;withRandomONet&#39;&lt;/code&gt;&lt;/a&gt; for reference on how to write the type)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L260-274&quot;&gt;binary instance&lt;/a&gt; for &lt;code&gt;SomeNet&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Hint: Remember &lt;code&gt;natVal :: KnownNat n =&amp;gt; Proxy n -&amp;gt; Integer&lt;/code&gt;!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hint: Remember that &lt;code&gt;toSomeSing&lt;/code&gt; also works for &lt;code&gt;Integer&lt;/code&gt;s, to get &lt;code&gt;Sing&lt;/code&gt;s for &lt;code&gt;Nat&lt;/code&gt;s, too!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;A bit of a stretch, because the set of all &lt;code&gt;[Nat]&lt;/code&gt;s is non-enumerable and uncountable, but hopefully you get the picture!&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;Recall that I recommend (personally, and subjectively) a style where your external API functions and typeclass instances are implemented in &lt;code&gt;SingI a =&amp;gt;&lt;/code&gt; style, and your internal ones in &lt;code&gt;Sing a -&amp;gt;&lt;/code&gt; style. This lets all of your internal functions fit together more nicely (&lt;code&gt;Sing a -&amp;gt;&lt;/code&gt; style tends to be easier to write in, especially if you stay in it the entire time, because &lt;code&gt;Sing&lt;/code&gt;s are normal first-class values, unlike those global and magical typeclasses) while at the same time removing the burden of calling with explicit singletons from people using the functionality externally.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;In older versions of singletons, before GHC 8 and &lt;em&gt;TypeInType&lt;/em&gt;, we had to implement it using “kind proxies”. Don’t worry if you’re following along in 7.10; the basic usage of &lt;code&gt;SomeSing&lt;/code&gt; is essentially identical either way.&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;Skolemization is probably one of the coolest words you’ll encounter when learning/using Haskell, and sometimes just knowing that you’re “skolemizing” something makes you feel cooler. Thank you &lt;a href=&quot;https://en.wikipedia.org/wiki/Thoralf_Skolem&quot;&gt;Thoralf Skolem&lt;/a&gt;. If you ever see a “rigid, skolem” error in GHC, you can thank him for that too! He is also the inspiration behind my decision to name my first-born son Thoralf. (My second son’s name will be Curry)&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn5&quot;&gt;&lt;p&gt;It even lets you write &lt;code&gt;Storable&lt;/code&gt; instances!&lt;a href=&quot;#fnref5&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html</guid><pubDate>Thu, 30 Jun 2016 18:59:23 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings</dc:subject><dc:date>2016-06-30</dc:date></item><item><title>Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 1)</title><link>https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html</link><description>&lt;p&gt;It seems these days like programming with dependent types in Haskell (and its advantages) is moving slowly but steadily to the mainstream of Haskell programming. In the current state of Haskell education, dependent types are often considered topics for “advanced” Haskell users. However, I can foresee a day where the ease of use of modern Haskell libraries relying on dependent types forces programming with dependent types to be an integral part of normal intermediate (or even beginner) Haskell education.&lt;/p&gt;
&lt;p&gt;There are &lt;a href=&quot;https://www.youtube.com/watch?v=rhWMhTjQzsU&quot;&gt;more&lt;/a&gt; and &lt;a href=&quot;http://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/&quot;&gt;more&lt;/a&gt; and &lt;a href=&quot;https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety&quot;&gt;more&lt;/a&gt; and &lt;a href=&quot;http://jozefg.bitbucket.org/posts/2014-08-25-dep-types-part-1.html&quot;&gt;more&lt;/a&gt; great resources and tutorials and introductions to integrating dependent types into your Haskell every day. The point of this series is to show more some practical examples of using dependent types in guiding your programming, and to also walk through the “why” and high-level philosophy of the way you structure your Haskell programs. It’ll also hopefully instill an intuition of a dependently typed work flow of “exploring” how dependent types can help your current programs. The intended audience of this post is for intermediate Haskell programmers in general, with no required knowledge of dependently typed programming. I should also point out that I’m no expert — I’m still in the process of learning this all, myself :)&lt;/p&gt;
&lt;p&gt;The first project in this series will build up to a type-safe &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_neural_network&quot;&gt;artificial neural network&lt;/a&gt;&lt;/strong&gt; implementation with back-propagation training.&lt;/p&gt;
&lt;h4 id=&quot;setup&quot;&gt;Setup&lt;/h4&gt;
&lt;p&gt;This post is written on &lt;em&gt;&lt;a href=&quot;http://www.haskellstack.org&quot;&gt;stack&lt;/a&gt;&lt;/em&gt; snapshot &lt;em&gt;&lt;a href=&quot;https://www.stackage.org/nightly-2016-06-28&quot;&gt;nightly-2016-06-28&lt;/a&gt;&lt;/em&gt;, with &lt;em&gt;singletons-2.2&lt;/em&gt;, but uses an unreleased version of &lt;em&gt;hmatrix&lt;/em&gt;, &lt;em&gt;&lt;a href=&quot;https://github.com/albertoruiz/hmatrix/tree/42a88fbcb6bd1d2c4dc18fae5e962bd34fb316a1&quot;&gt;hmatrix-0.18 (commit 42a88fb)&lt;/a&gt;&lt;/em&gt;. I &lt;a href=&quot;http://mstksg.github.io/hmatrix/&quot;&gt;maintain my own documentation&lt;/a&gt; for reference.&lt;/p&gt;
&lt;p&gt;If you’re forced to use GHC 7.10 for some reason, there’s also a bug in &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/singletons-2.0.1&quot;&gt;singletons-2.0.1&lt;/a&gt;&lt;/em&gt; package that’s fixed in &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/singletons-2.1&quot;&gt;singletons-2.1&lt;/a&gt;&lt;/em&gt;, but &lt;em&gt;2.1&lt;/em&gt; is not available with GHC 7.10 – I have a &lt;a href=&quot;https://github.com/mstksg/singletons/releases/tag/v2.0.2&quot;&gt;github fork&lt;/a&gt; that fixes the bug if you want to stay on GHC 7.10.&lt;/p&gt;
&lt;p&gt;You can add this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;packages:&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;location:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;git:&lt;/span&gt; git@github.com:albertoruiz/hmatrix.git
    &lt;span class=&quot;fu&quot;&gt;commit:&lt;/span&gt; 42a88fbcb6bd1d2c4dc18fae5e962bd34fb316a1
  &lt;span class=&quot;fu&quot;&gt;subdirs:&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; packages/base
&lt;span class=&quot;co&quot;&gt;# # If stuck on GHC 7.10:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# - location:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#     git: git@github.com:mstksg/singletons.git&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#     commit: v2.0.2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to the &lt;code&gt;packages&lt;/code&gt; field of your directory or global &lt;em&gt;stack.yaml&lt;/em&gt; and &lt;em&gt;stack&lt;/em&gt; will know what version of &lt;em&gt;hmatrix&lt;/em&gt; and &lt;em&gt;singletons&lt;/em&gt; to use when you use &lt;code&gt;stack runghc&lt;/code&gt; or &lt;code&gt;stack ghc&lt;/code&gt;, etc. to build your files.&lt;/p&gt;
&lt;h2 id=&quot;neural-networks&quot;&gt;Neural Networks&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_neural_network&quot;&gt;Artificial neural networks&lt;/a&gt; have been somewhat of a hot topic in computing recently. Implementations of training algorithms (like back-propagation) are tricky to implement correctly — despite being simple, there are many locations where accidental bugs might pop up when multiplying the wrong matrices, for example.&lt;/p&gt;
&lt;p&gt;Though some might recognize that complicated matrix and vector arithmetic is a common application of phantom type-based dependent types, it’s not necessarily always easy to gauge before-the-fact what would or would not be a good candidate for adding dependent types to. Often times, it can even be considered premature to start off with “as powerful types as you can”. So let’s walk through programming things with as “dumb” types as possible, and see where types can help.&lt;/p&gt;
&lt;p&gt;We’ll be following a process called “type-driven development” — start with general and non-descriptive types, write the implementation and recognize partial functions and red flags, and slowly refine and add more and more powerful types to fix the problems.&lt;/p&gt;
&lt;h3 id=&quot;background&quot;&gt;Background&lt;/h3&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/entries/dependent-haskell-1/ffneural.png&quot; title=&quot;Feed-forward ANN architecture&quot; alt=&quot;Feed-forward ANN architecture&quot; /&gt;&lt;figcaption&gt;Feed-forward ANN architecture&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Here’s a quick run through on background for ANN’s — but remember, this isn’t an article on ANN’s, so we are going to be glossing over some of the details.&lt;/p&gt;
&lt;p&gt;We’re going to be implementing a &lt;em&gt;feed-forward neural network&lt;/em&gt; with back-propagation training. These networks are layers of “nodes”, each connected to the each of the nodes of the previous layer. Input goes to the first layer, which feeds information to the next layer, which feeds it to the next, etc., until the final layer, where we read it off as the “answer” that the network is giving us. Layers between the input and output layers are called &lt;em&gt;hidden&lt;/em&gt; layers. Every node “outputs” a weighted sum of all of the outputs of the &lt;em&gt;previous&lt;/em&gt; layer, plus an always-on “bias” term (so that its result can be non-zero even when all of its inputs are zero). Symbolically, it looks like:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0Ay_j%20%3D%20b_j%20%2B%20%5Csum_i%5Em%20w_%7Bij%7D%20x_i%0A&quot; alt=&quot;
y_j = b_j + \sum_i^m w_{ij} x_i
&quot; title=&quot;
y_j = b_j + \sum_i^m w_{ij} x_i
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Or, if we treat the output of a layer and the list of list of weights as a matrix, we can write it a little cleaner:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Cmathbf%7By%7D%20%3D%20%5Cmathbf%7Bb%7D%20%2B%20W%20%5Cmathbf%7Bx%7D%0A&quot; alt=&quot;
\mathbf{y} = \mathbf{b} + W \mathbf{x}
&quot; title=&quot;
\mathbf{y} = \mathbf{b} + W \mathbf{x}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;The result, the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n&quot; alt=&quot;n&quot; title=&quot;n&quot; /&gt;-vector of nodes &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cmathbf%7By%7D&quot; alt=&quot;\mathbf{y}&quot; title=&quot;\mathbf{y}&quot; /&gt;, is computed from the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n&quot; alt=&quot;n&quot; title=&quot;n&quot; /&gt;-vector of biases &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cmathbf%7Bb%7D&quot; alt=&quot;\mathbf{b}&quot; title=&quot;\mathbf{b}&quot; /&gt; and the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n%20%5Ctimes%20m&quot; alt=&quot;n \times m&quot; title=&quot;n \times m&quot; /&gt; weight matrix &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?W&quot; alt=&quot;W&quot; title=&quot;W&quot; /&gt; multiplied with the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?m&quot; alt=&quot;m&quot; title=&quot;m&quot; /&gt;-vector input, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cmathbf%7Bx%7D&quot; alt=&quot;\mathbf{x}&quot; title=&quot;\mathbf{x}&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;To “scale” the result (and to give the system the magical powers of nonlinearity), we actually apply an “activation function” to the output before passing it down to the next step. We’ll be using the popular &lt;a href=&quot;https://en.wikipedia.org/wiki/Logistic_function&quot;&gt;logistic function&lt;/a&gt;, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f%28x%29%20%3D%201%20%2F%20%281%20%2B%20e%5E%7B-x%7D%29&quot; alt=&quot;f(x) = 1 / (1 + e^{-x})&quot; title=&quot;f(x) = 1 / (1 + e^{-x})&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Training&lt;/em&gt; a network involves picking the right set of weights to get the network to answer the question you want.&lt;/p&gt;
&lt;h2 id=&quot;vanilla-types&quot;&gt;Vanilla Types&lt;/h2&gt;
&lt;p&gt;We can store a network by storing the matrix of of weights and biases between each layer:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L18-20&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; wBiases ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;-- n&lt;/span&gt;
                 ,&lt;span class=&quot;ot&quot;&gt; wNodes  ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;-- n x m&lt;/span&gt;
                 }                              &lt;span class=&quot;co&quot;&gt;-- &amp;quot;m to n&amp;quot; layer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, a &lt;code&gt;Weights&lt;/code&gt; linking an &lt;em&gt;m&lt;/em&gt;-node layer to an &lt;em&gt;n&lt;/em&gt;-node layer has an &lt;em&gt;n&lt;/em&gt;-dimensional bias vector (one component for each output) and an &lt;em&gt;n&lt;/em&gt;-by-&lt;em&gt;m&lt;/em&gt; node weight matrix (one column for each output, one row for each input).&lt;/p&gt;
&lt;p&gt;(We’re using the &lt;code&gt;Matrix&lt;/code&gt; type from the awesome &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/hmatrix&quot;&gt;hmatrix&lt;/a&gt;&lt;/em&gt; library for performant linear algebra, implemented using blas/lapack under the hood)&lt;/p&gt;
&lt;p&gt;A feed-forward neural network is then just a linked list of these weights:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L22-28&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;     ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    (:&amp;amp;~) ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we’re using &lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/GADT&quot;&gt;GADT&lt;/a&gt; syntax here, which just lets us define &lt;code&gt;Network&lt;/code&gt; (with a kind signature, &lt;code&gt;*&lt;/code&gt;) by providing the type of its &lt;em&gt;constructors&lt;/em&gt;, &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;(:&amp;amp;~)&lt;/code&gt;. It’d be equivalent to the following normal data declaration:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A network with one input layer, two inner layers, and one output layer would look like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ih &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; hh &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; ho&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first component is the weights from the input to first inner layer, the second is the weights between the two hidden layers, and the last is the weights between the last hidden layer and the output layer.&lt;/p&gt;
&lt;!-- TODO: graphs using diagrams? --&gt;
&lt;p&gt;We can write simple procedures, like generating random networks:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L46-56&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomWeights ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;
randomWeights i o &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    seed1 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getRandom
&lt;span class=&quot;ot&quot;&gt;    seed2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getRandom
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; randomVector  seed1 &lt;span class=&quot;dt&quot;&gt;Uniform&lt;/span&gt; o &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
        wN &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; uniformSample seed2 o (replicate i (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN

&lt;span class=&quot;ot&quot;&gt;randomNet ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
randomNet i []     o &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;     &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights i o
randomNet i (h&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;hs) o &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights i h &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; randomNet h hs o&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(We’re using the &lt;code&gt;MonadRandom&lt;/code&gt; typeclass from the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/MonadRandom&quot;&gt;MonadRandom&lt;/a&gt;&lt;/em&gt; library, which uses the mechanisms in &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/random-1.1/docs/System-Random.html&quot;&gt;System.Random&lt;/a&gt;&lt;/em&gt; and gives us a generic way of working with monads where we can get random values with &lt;code&gt;getRandom&lt;/code&gt;, etc.)&lt;/p&gt;
&lt;p&gt;(&lt;a href=&quot;http://hackage.haskell.org/package/hmatrix-0.17.0.1/docs/Numeric-LinearAlgebra.html#v:randomVector&quot;&gt;&lt;code&gt;randomVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://hackage.haskell.org/package/hmatrix-0.17.0.1/docs/Numeric-LinearAlgebra.html#v:uniformSample&quot;&gt;&lt;code&gt;uniformSample&lt;/code&gt;&lt;/a&gt; are from the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/hmatrix&quot;&gt;hmatrix&lt;/a&gt;&lt;/em&gt; library, generating random vectors and matrices from a random &lt;code&gt;Int&lt;/code&gt; seed. We manipulate them here to generate them with numbers between -1 and 1)&lt;/p&gt;
&lt;p&gt;And now we can write a function to “run” our network on a given input vector, following the matrix equation we wrote earlier:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L30-44&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;logistic ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Floating&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
logistic x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; exp (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;x))

&lt;span class=&quot;ot&quot;&gt;runLayer ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;
runLayer (&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN) v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; v

&lt;span class=&quot;ot&quot;&gt;runNet ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;
runNet (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w)      &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic (runLayer w v)
runNet (w &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39;) &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic (runLayer w v)
                       &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  runNet n&amp;#39; v&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;#&amp;gt;&lt;/code&gt; is matrix-vector multiplication)&lt;/p&gt;
&lt;!-- TODO: examples of running --&gt;
&lt;p&gt;If you’re a non-Haskell programmer, this might all seem perfectly fine and normal, and you probably have only a slightly elevated heart rate. If you are a Haskell programmer, you are most likely already having heart attacks. Let’s imagine all of the bad things that could happen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;How do we know that we didn’t accidentally mix up the dimensions for our implementation of &lt;code&gt;randomWeights&lt;/code&gt;? We could have switched parameters and be none the wiser.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How do we even know that each subsequent matrix in the network is “compatible”? We want the outputs of one matrix to line up with the inputs of the next, but there’s no way to know. It’s possible to build a bad network, and things will just explode at runtime.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How do we know the size of vector the network expects? What stops you from sending in a bad vector at run-time? We might do runtime-checks, but the compiler won’t help us.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How do we verify that we have implemented &lt;code&gt;runLayer&lt;/code&gt; and &lt;code&gt;runNet&lt;/code&gt; in a way that they won’t suddenly fail at runtime? We write &lt;code&gt;l #&amp;gt; v&lt;/code&gt;, but how do we know that it’s even correct…what if we forgot to multiply something, or used something in the wrong places? We can it prove ourselves, but the compiler won’t help us.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;back-propagation&quot;&gt;Back-propagation&lt;/h3&gt;
&lt;p&gt;Now, let’s try implementing back-propagation! It’s a textbook gradient descent algorithm. There are &lt;a href=&quot;https://en.wikipedia.org/wiki/Backpropagation&quot;&gt;many explanations&lt;/a&gt; on the internet; the basic idea is that you try to minimize the squared error of what the neural network outputs for a given input vs. the actual expected output. You find the direction of change that minimizes the error (by finding the derivative), and move that direction. The implementation of backpropagation is found in many sources online and in literature, so let’s see the implementation in Haskell:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L58-96&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;train ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- ^ learning rate&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;-- ^ input vector&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;-- ^ target vector&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;-- ^ network to train&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
train rate x0 target &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fst &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; go x0
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    go ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;-- ^ input vector&lt;/span&gt;
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;-- ^ network to train&lt;/span&gt;
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;)
    &lt;span class=&quot;co&quot;&gt;-- handle the output layer&lt;/span&gt;
    go &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;x (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN))
        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runLayer w x
              o    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic y
              &lt;span class=&quot;co&quot;&gt;-- the gradient (how much y affects the error)&lt;/span&gt;
              &lt;span class=&quot;co&quot;&gt;--   (logistic&amp;#39; is the derivative of logistic)&lt;/span&gt;
              dEdy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic&amp;#39; y &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; (o &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; target)
              &lt;span class=&quot;co&quot;&gt;-- new bias weights and node weights&lt;/span&gt;
              wB&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; scale rate dEdy
              wN&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; scale rate (dEdy &lt;span class=&quot;ot&quot;&gt;`outer`&lt;/span&gt; x)
              w&amp;#39;   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB&amp;#39; wN&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- bundle of derivatives for next step&lt;/span&gt;
              dWs  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; tr wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; dEdy
          &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w&amp;#39;, dWs)
    &lt;span class=&quot;co&quot;&gt;-- handle the inner layers&lt;/span&gt;
    go &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;x (w&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN) &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n)
        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runLayer w x
              o          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic y
              &lt;span class=&quot;co&quot;&gt;-- get dWs&amp;#39;, bundle of derivatives from rest of the net&lt;/span&gt;
              (n&amp;#39;, dWs&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go o n
              &lt;span class=&quot;co&quot;&gt;-- the gradient (how much y affects the error)&lt;/span&gt;
              dEdy       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic&amp;#39; y &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; dWs&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- new bias weights and node weights&lt;/span&gt;
              wB&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; scale rate dEdy
              wN&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; scale rate (dEdy &lt;span class=&quot;ot&quot;&gt;`outer`&lt;/span&gt; x)
              w&amp;#39;   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB&amp;#39; wN&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- bundle of derivatives for next step&lt;/span&gt;
              dWs  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; tr wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; dEdy
          &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (w&amp;#39; &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39;, dWs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The algorithm computes the &lt;em&gt;updated&lt;/em&gt; network by recursively updating the layers, backwards up from the output layer. At every step, it returns the updated layer/network, as well as a bundle of derivatives (&lt;code&gt;dWs&lt;/code&gt;) for the next layer up to use to calculate its descent direction.&lt;/p&gt;
&lt;p&gt;At the output layer, all it needs to calculate the direction of descent is just &lt;code&gt;o - targ&lt;/code&gt;, the target. At the inner layers, it has to use the &lt;code&gt;dWs&lt;/code&gt; bundle it receives from the lower layers to figure it out. &lt;code&gt;dWs&lt;/code&gt; essentially “bubbles up” from the output layer up to the input layer calculations.&lt;/p&gt;
&lt;p&gt;Writing this is a bit of a struggle. I actually implemented this incorrectly several times before writing it as you see here. The type system doesn’t help you like it normally does in Haskell, and you can’t really use parametricity to help you write your code like normal Haskell. Everything is monomorphic, and everything multiplies with everything else. You don’t have any hints about what to multiply with what at any point in time. It’s like all of the bad things mentioned before, but amplified.&lt;/p&gt;
&lt;p&gt;In short, you’re leaving yourself open to many potential bugs…and the compiler doesn’t help you write your code at all! This is the nightmare of every Haskell programmer. There must be a better way!&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;putting-it-to-the-test&quot;&gt;Putting it to the test&lt;/h4&gt;
&lt;p&gt;Pretty much the only way you can verify this code is to test it out on example cases. In the &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs&quot;&gt;source file&lt;/a&gt;, I have &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L128-136&quot;&gt;&lt;code&gt;main&lt;/code&gt;&lt;/a&gt; test out the backprop, training a network on a 2D function that was “on” for two small circles and “off” everywhere else (A nice cute non-linearly-separable function to test our network on). We basically train the network to be able to recognize the two-circle pattern. I implemented a simple printing function and tested the trained network on a grid:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;stack&lt;/span&gt; install hmatrix MonadRandom
$ &lt;span class=&quot;ex&quot;&gt;stack&lt;/span&gt; ghc -- -O2 ./NetworkUntyped.hs
$ &lt;span class=&quot;ex&quot;&gt;./NetworkUntyped&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# Training network...&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#            .=########=&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          .##############.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          ################&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          ################&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          .##############-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#            .###########&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                 ...             ...&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                             -##########.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                           -##############.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                           ################&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                           ################&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                            =############=&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                              .#######=.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not too bad! The network learned to recognize the circles. But, I was basically forced to resort to unit testing to ensure my code was correct. Let’s see if we can do better.&lt;/p&gt;
&lt;h3 id=&quot;the-call-of-types&quot;&gt;The Call of Types&lt;/h3&gt;
&lt;p&gt;Before we go on to the “typed” version of our program, let’s take a step back and look at some big checks you might want to ask yourself after you write code in Haskell.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Are any of my functions either partial or implemented using partial functions?&lt;/li&gt;
&lt;li&gt;How could I have written things that are &lt;em&gt;incorrect&lt;/em&gt;, and yet still type check? Where does the compiler &lt;em&gt;not&lt;/em&gt; help me by restricting my choices?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Both of these questions usually yield some truth about the code you write and the things you should worry about. As a Haskeller, they should always be at the back of your mind!&lt;/p&gt;
&lt;p&gt;Looking back at our untyped implementation, we notice some things:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Literally every single function we wrote is partial. Like, actually.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; If we had passed in the incorrectly sized matrix/vector, or stored mismatched vectors in our network, everything would fall apart.&lt;/li&gt;
&lt;li&gt;There are billions of ways we could have implemented our functions where they would still typechecked. We could multiply mismatched matrices, or forget to multiply a matrix, etc.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;with-static-size-indexed-types&quot;&gt;With Static Size-Indexed Types&lt;/h2&gt;
&lt;h3 id=&quot;networks&quot;&gt;Networks&lt;/h3&gt;
&lt;p&gt;Gauging our potential problems, it seems like the first major class of bugs we can address is improperly sized and incompatible matrices. If the compiler always made sure we used compatible matrices, we can avoid bugs at compile-time, and we also can get a friendly helper when we write programs (by knowing what works with what, and what we need were, and helping us organize our logic)&lt;/p&gt;
&lt;p&gt;Let’s write a &lt;code&gt;Weights&lt;/code&gt; type that tells you the size of its output and the input it expects. Let’s have, say, a &lt;code&gt;Weights 10 5&lt;/code&gt; be a set of weights that takes you from a layer of 10 nodes to a layer of 5 nodes. &lt;code&gt;w :: Weights 4 6&lt;/code&gt; would take you from a layer of 4 nodes to a layer of 6 nodes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L21-23&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; wBiases ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o)
                     ,&lt;span class=&quot;ot&quot;&gt; wNodes  ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;L&lt;/span&gt; o i)
                     }                      &lt;span class=&quot;co&quot;&gt;-- an &amp;quot;o x i&amp;quot; layer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type constructor &lt;code&gt;Weights&lt;/code&gt; has the kind &lt;code&gt;Weights :: Nat -&amp;gt; Nat -&amp;gt; *&lt;/code&gt; — it takes two types of kind &lt;code&gt;Nat&lt;/code&gt; (from the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-TypeLits.html&quot;&gt;GHC.TypeLits&lt;/a&gt;&lt;/em&gt; module, which the integer type literals give us with &lt;em&gt;&lt;a href=&quot;https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell#type-level-naturals&quot;&gt;DataKinds&lt;/a&gt;&lt;/em&gt; enabled) and returns a &lt;code&gt;*&lt;/code&gt; — a “normal type”.&lt;/p&gt;
&lt;p&gt;We’re using the &lt;em&gt;&lt;a href=&quot;http://mstksg.github.io/hmatrix/Numeric-LinearAlgebra-Static.html&quot;&gt;Numeric.LinearAlgebra.Static&lt;/a&gt;&lt;/em&gt; module from &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/hmatrix&quot;&gt;hmatrix&lt;/a&gt;&lt;/em&gt;, which offers matrix and vector types with their size in their types: an &lt;code&gt;R 5&lt;/code&gt; is a vector of Doubles with 5 elements, and a &lt;code&gt;L 3 6&lt;/code&gt; is a 3x6 vector of Doubles.&lt;/p&gt;
&lt;p&gt;These types are called “dependent” types because the type itself &lt;em&gt;depends&lt;/em&gt; on its value. If an &lt;code&gt;R n&lt;/code&gt; contains a 5-element vector, its type is &lt;code&gt;R 5&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;Static&lt;/em&gt; module in &lt;em&gt;hmatrix&lt;/em&gt; relies on the &lt;a href=&quot;http://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-TypeLits.html#t:KnownNat&quot;&gt;&lt;code&gt;KnownNat&lt;/code&gt;&lt;/a&gt; mechanism that GHC offers. Almost all operations in the library require a &lt;code&gt;KnownNat&lt;/code&gt; constraint on the type-level Nats — for example, you can take the dot product of two vectors with &lt;code&gt;dot :: KnownNat n =&amp;gt; R n -&amp;gt; R n -&amp;gt; Double&lt;/code&gt;. It lets the library use the information in the &lt;code&gt;n&lt;/code&gt; at runtime as an &lt;code&gt;Integer&lt;/code&gt;. (More on this later!)&lt;/p&gt;
&lt;p&gt;Moving on, our network type for this post will be something like &lt;code&gt;Network 10 &#39;[7,5,3] 2&lt;/code&gt;: Take 10 inputs, return 2 outputs — and internally, have hidden layers of size 7, 5, and 3. (The &lt;code&gt;&#39;[7,5,3]&lt;/code&gt; is a type-level list of Nats; the optional &lt;code&gt;&#39;&lt;/code&gt; apostrophe is just for our own benefit to distinguish it from a value-level list of integers.)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L25-32&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;     ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o)
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i &lt;span class=&quot;ch&quot;&gt;&amp;#39;[] o&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    (:&amp;amp;~) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; h
          &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i h)
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; h hs o)
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i (h &lt;span class=&quot;ch&quot;&gt;&amp;#39;: hs) o&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We use GADT syntax here again. The &lt;em&gt;kind signature&lt;/em&gt; of the type constructor means that the &lt;code&gt;Network&lt;/code&gt; type constructor takes three inputs: a &lt;code&gt;Nat&lt;/code&gt; (type-level numeral, like &lt;code&gt;10&lt;/code&gt; or &lt;code&gt;5&lt;/code&gt;), list of &lt;code&gt;Nat&lt;/code&gt;s, and another &lt;code&gt;Nat&lt;/code&gt; (the input, hidden layers, and output sizes). Let’s go over the two constructors.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;O&lt;/code&gt; constructor takes a &lt;code&gt;Weights i o&lt;/code&gt; and returns a &lt;code&gt;Network i &#39;[] o&lt;/code&gt;. That is, if your network is just weights from &lt;code&gt;i&lt;/code&gt; inputs to &lt;code&gt;o&lt;/code&gt; outputs, your network itself just takes &lt;code&gt;i&lt;/code&gt; inputs and returns &lt;code&gt;o&lt;/code&gt; outputs, with no hidden layers.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;(:&amp;amp;~)&lt;/code&gt; constructor takes a &lt;code&gt;Network h hs o&lt;/code&gt; – a network with &lt;code&gt;h&lt;/code&gt; inputs and &lt;code&gt;o&lt;/code&gt; outputs – and “conses” an extra input layer in front. If you give it a &lt;code&gt;Weights i h&lt;/code&gt;, its outputs fit perfectly into the inputs of the subnetwork, and you get a &lt;code&gt;Network i (h &#39;: hs) o&lt;/code&gt;. (&lt;code&gt;(&#39;:)&lt;/code&gt;, or &lt;code&gt;(:)&lt;/code&gt;, is the same as normal &lt;code&gt;(:)&lt;/code&gt;, but is for type-level lists. The apostrophe is optional here too, but it’s just nice to be able to visually distinguish the two)&lt;/p&gt;
&lt;p&gt;We add a &lt;code&gt;KnownNat&lt;/code&gt; constraint on the &lt;code&gt;h&lt;/code&gt;, so that whenever you pattern match on &lt;code&gt;w :&amp;amp;~ net&lt;/code&gt;, you automatically get a &lt;code&gt;KnownNat&lt;/code&gt; constraint for the input size of &lt;code&gt;net&lt;/code&gt; (and the output of &lt;code&gt;w&lt;/code&gt;) that the &lt;em&gt;hmatrix&lt;/em&gt; library can use.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can still construct them the same way:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- given:&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;ih ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;hh ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;ho ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- we have:&lt;/span&gt;
              &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ho ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[] 2&lt;/span&gt;
       hh &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ho ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[4] 2&lt;/span&gt;
ih &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; hh &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ho ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[7,4] 2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the shape of the constructors requires all of the weight vectors to “fit together”. &lt;code&gt;ih :&amp;amp;~ O ho&lt;/code&gt; would be a type error (feeding a 7-output layer to a 4-input layer). Also, if we ever pattern match on &lt;code&gt;:&amp;amp;~&lt;/code&gt;, we know that the resulting matrices and vectors are compatible!&lt;/p&gt;
&lt;p&gt;One neat thing is that this approach is also self-documenting. I don’t need to specify what the dimensions are in the docs and trust the users to read it and obey it. The types tell them! And if they don’t listen, they get a compiler error! (You should, of course, still provide reasonable documentation. But, in this case, the compiler actually enforces your documentation’s statements!)&lt;/p&gt;
&lt;p&gt;Generating random weights and networks is even nicer now:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L56-63&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomWeights ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
              &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o)
randomWeights &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    s1 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getRandom
&lt;span class=&quot;ot&quot;&gt;    s2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getRandom
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; randomVector  s1 &lt;span class=&quot;dt&quot;&gt;Uniform&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
        wN &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; uniformSample s2 (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice that the &lt;em&gt;Static&lt;/em&gt; versions of &lt;a href=&quot;http://mstksg.github.io/hmatrix/Numeric-LinearAlgebra-Static.html#v:randomVector&quot;&gt;&lt;code&gt;randomVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://mstksg.github.io/hmatrix/Numeric-LinearAlgebra-Static.html#v:uniformSample&quot;&gt;&lt;code&gt;uniformSample&lt;/code&gt;&lt;/a&gt; don’t actually require the size of the vector/matrix you want as an input – they just use &lt;em&gt;type inference&lt;/em&gt; to figure out what size you want! This is the same process that &lt;a href=&quot;http://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; uses to figure out what type of thing you want to return. You would use &lt;code&gt;randomVector s Uniform :: R 10&lt;/code&gt;, and type inference would give you a 10-element vector the same way &lt;code&gt;read &amp;quot;hello&amp;quot; :: Int&lt;/code&gt; would give you an &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It’s important to note that it’s much harder to implement this incorrectly. Before, you could give the matrix the wrong dimensions (maybe you flipped the parameters?), or gave the wrong parameter to the vector generator.&lt;/p&gt;
&lt;p&gt;But here, you are guaranteed/forced to return the correctly sized vectors and matrices. In fact, you &lt;em&gt;don’t even have to worry&lt;/em&gt; about it — it’s handled automatically by the magic of type inference&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;! I consider this a very big victory. One of the whole points of types is to give you less to “worry about”, as a programmer. Here, we completely eliminate an &lt;em&gt;entire dimension&lt;/em&gt; of programmer concern.&lt;/p&gt;
&lt;h4 id=&quot;benefits-to-the-user&quot;&gt;Benefits to the user&lt;/h4&gt;
&lt;p&gt;Not only is this style nicer for you as the implementer, it’s also very beneficial for the &lt;em&gt;user&lt;/em&gt; of the function. Consider looking at the two competing type signatures side-by-side:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;randomWeights ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomWeights ::&lt;/span&gt;               m (&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you want to &lt;em&gt;use&lt;/em&gt; this function, you have to look up some things from the documentation:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;What do the two arguments represent?&lt;/li&gt;
&lt;li&gt;What &lt;em&gt;order&lt;/em&gt; is the function expecting these two arguments?&lt;/li&gt;
&lt;li&gt;What will be the dimension of the result?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These are three things you &lt;em&gt;need&lt;/em&gt; to look up in the documentation. There’s simply no way around it.&lt;/p&gt;
&lt;p&gt;But, here, all of these questions are answered &lt;em&gt;immediately&lt;/em&gt;, just from the type (which you can get from GHC, or from ghci). You don’t need to worry about arguments. You don’t need to worry about what order the function is expecting the arguments to be in. And you already know &lt;em&gt;exactly&lt;/em&gt; what the dimensions of the result is, right in the type.&lt;/p&gt;
&lt;p&gt;I often implement many of my functions in this style, even if the rest of my program isn’t intended to be dependently typed (I can just convert the type to a “dumb” type as soon as I get the result). All of these benefits come even when the caller doesn’t &lt;em&gt;care&lt;/em&gt; at all about dependently typed programming — it’s just a better style of defining functions/offering an API!&lt;/p&gt;
&lt;h3 id=&quot;singletons-and-induction&quot;&gt;Singletons and Induction&lt;/h3&gt;
&lt;p&gt;The code for the updated &lt;code&gt;randomNet&lt;/code&gt; takes a bit of background to understand, so let’s take a quick detour through the concepts of singletons, dependent pattern matching, and induction on dependent data types.&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Let’s say we want to implement an algorithm that can create any &lt;code&gt;Network i hs o&lt;/code&gt;, so that we can construct a &lt;code&gt;Network 4 &#39;[3,2] 1&lt;/code&gt; or something. In true Haskell fashion, we want do this recursively (“inductively”). After all, we know how to make a &lt;code&gt;Network i &#39;[] o&lt;/code&gt; (just &lt;code&gt;O &amp;lt;$&amp;gt; randomWeights&lt;/code&gt;), and we know how to create a &lt;code&gt;Network i (h &#39;: hs) o&lt;/code&gt; if we had a &lt;code&gt;Network h hs o&lt;/code&gt; (just use &lt;code&gt;(:&amp;amp;~)&lt;/code&gt; with &lt;code&gt;randomWeights&lt;/code&gt;). Now all we have to do is just “pattern match” on the type-level list, and…&lt;/p&gt;
&lt;p&gt;Oh wait. We can’t pattern match on types like that in Haskell. This is a consequence of one of Haskell’s fundamental design decisions: types are &lt;strong&gt;erased&lt;/strong&gt; at runtime. We need to have a way to “access” the type (at run-time) as a &lt;em&gt;value&lt;/em&gt; so we can pattern match on it and do things with it.&lt;/p&gt;
&lt;p&gt;In Haskell, the popular way to deal with this is by using &lt;em&gt;singletons&lt;/em&gt; — (parameterized) types which only have valid constructor. The canonical method of working with singletons in Haskell is with the &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/singletons&quot;&gt;singletons&lt;/a&gt;&lt;/em&gt; library, which provides a uniform interface for all sorts of singletons of types you’ll encounter in everyday use.&lt;/p&gt;
&lt;p&gt;We want to “pattern match” on a type-level list, so we want a singleton for lists. The &lt;em&gt;singletons&lt;/em&gt; library provides them:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[]&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; as &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (a &lt;span class=&quot;ch&quot;&gt;&amp;#39;: as)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that if we ever get value of type &lt;code&gt;Sing as&lt;/code&gt; (and &lt;code&gt;as&lt;/code&gt; is a type-level list), we can pattern match on it. If we match on the &lt;code&gt;SNil&lt;/code&gt; constructor, we &lt;em&gt;know&lt;/em&gt; it’s a &lt;code&gt;Sing &#39;[]&lt;/code&gt; in that branch, and if we match on the &lt;code&gt;SCons&lt;/code&gt; constructor, we &lt;em&gt;know&lt;/em&gt; it’s a &lt;code&gt;Sing (a &#39;: as)&lt;/code&gt; – a non-empty list. This is called &lt;em&gt;dependent pattern matching&lt;/em&gt;. Every “branch” of your case statement has a different inferred type of the arguments, depending on the constructor you match on.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; foo &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- here, GHC knows `foo :: Sing &amp;#39;[]`&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt; _ _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- here, GHC knows `foo :: Sing (a &amp;#39;: as)`&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;singletons&lt;/em&gt; actually provides a whole bunch of singleton constructors for different types and kinds, like for &lt;code&gt;Bool&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;True&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SFalse&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(That’s the &lt;em&gt;type&lt;/em&gt; &lt;code&gt;&#39;True&lt;/code&gt;, of &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;Bool&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;So, if we ever are given a &lt;code&gt;Sing b&lt;/code&gt; with some type-level &lt;code&gt;Bool&lt;/code&gt; we don’t know, we can pattern match on it. And in the branch that &lt;code&gt;STrue&lt;/code&gt; matches on, &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;&#39;True&lt;/code&gt;, and in the branch that &lt;code&gt;SFalse&lt;/code&gt; matches on, &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Singletons give us a way to pattern match on types by having an actual term-level value we can pattern match on. So, we &lt;em&gt;could&lt;/em&gt; implement:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;randomNet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
          &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; hs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And &lt;code&gt;randomNet&lt;/code&gt; gets to directly pattern match and deconstruct on &lt;code&gt;Sing hs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, for actual API’s, it’s often more convenient to &lt;em&gt;not&lt;/em&gt; require the extra parameter, and have it be “inferred” in the way we’ve been doing it before. That way the &lt;em&gt;user&lt;/em&gt; doesn’t have the burden of supplying it. The &lt;em&gt;singletons&lt;/em&gt; library offers a typeclass we can use to implicitly conjure up values of a singleton type – &lt;code&gt;SingI&lt;/code&gt;. We can use &lt;code&gt;sing :: SingI s =&amp;gt; Sing s&lt;/code&gt; to generate the “inferred” singleton:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; sing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[]&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; sing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;True&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; sing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[&amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;ch&quot;&gt;&amp;#39;False, &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;]
&lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SFalse&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So if you have a function &lt;code&gt;SingI hs =&amp;gt; ...&lt;/code&gt;, it’s really no different than &lt;code&gt;Sing hs -&amp;gt; ...&lt;/code&gt;. The function itself gets to use a &lt;code&gt;Sing hs&lt;/code&gt; either way … but for the first, the argument is implicit.&lt;/p&gt;
&lt;p&gt;The final piece of the puzzle is the singleton for a type-level &lt;code&gt;Nat&lt;/code&gt;. It’s a little different because when you pattern match on it, instead of directly learning about the type, you “receive” a &lt;code&gt;KnownNat&lt;/code&gt; instance you can use.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- `foo :: Sing n`, but we don&amp;#39;t know what `n` it is&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; foo &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- in this branch, we have a `KnownNat n` instance&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Essentially, the data constructor comes “packaged” with a &lt;code&gt;KnownNat n&lt;/code&gt; instance. The &lt;em&gt;creation&lt;/em&gt; of &lt;code&gt;SNat :: Sing n&lt;/code&gt; requires the presence of &lt;code&gt;KnownNat n&lt;/code&gt;. So if you ever pattern match on a validly created &lt;code&gt;SNat&lt;/code&gt;, the fact that that &lt;code&gt;SNat&lt;/code&gt; constructor even exists (instead of, say, being &lt;code&gt;undefined&lt;/code&gt;) is a &lt;em&gt;witness&lt;/em&gt; to that very &lt;code&gt;KnownNat&lt;/code&gt; instance, and the type system lets us use this. It’s as if you “pattern match” out the instance itself, like any other value the constructor might have.&lt;/p&gt;
&lt;p&gt;Now we have enough pieces of the puzzle:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L65-74&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomNet ::&lt;/span&gt; forall m i hs o&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; hs, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
          &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o)
randomNet &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go sing
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    go ::&lt;/span&gt; forall h hs&amp;#39;&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; h
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; hs&amp;#39;
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; h hs&amp;#39; o)
    go &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;            &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;     &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights
        &lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; ss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; go ss&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The real heavy lifting is done by &lt;code&gt;go&lt;/code&gt; (written with &lt;a href=&quot;https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#lambdacase&quot;&gt;LambdaCase&lt;/a&gt;), which takes the singleton structure it needs and recursively calls it until it reaches the base case (&lt;code&gt;SNil&lt;/code&gt;, an output layer). We just call &lt;code&gt;go sing&lt;/code&gt; to give it the initial structure it needs. Note there, &lt;code&gt;sing :: Sing hs&lt;/code&gt;, but this is inferred, because &lt;code&gt;go&lt;/code&gt; is &lt;code&gt;Sing hs -&amp;gt; Network i hs o&lt;/code&gt;, and it’s being asked to return a &lt;code&gt;Network i hs o&lt;/code&gt;, so it’s safely inferable that we want &lt;code&gt;Sing hs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Remember that we can write &lt;code&gt;O &amp;lt;$&amp;gt; randomWeights&lt;/code&gt; because &lt;code&gt;randomWeights&lt;/code&gt;, like &lt;code&gt;read&lt;/code&gt;, adapts to whatever type we want from it — in this case, we ask for a &lt;code&gt;Weights h o&lt;/code&gt;, and type inference is the real hero.&lt;/p&gt;
&lt;p&gt;When possible, we like to write functions like &lt;code&gt;go&lt;/code&gt; that take &lt;em&gt;explicit&lt;/em&gt; singletons. In a lot of situations, we’ll actually write our internal &lt;em&gt;logic&lt;/em&gt; itself using explicit singletons, and only use &lt;code&gt;SingI&lt;/code&gt; and implicit singletons at the &lt;em&gt;external&lt;/em&gt; boundaries of our API (like &lt;code&gt;randomNet&lt;/code&gt;) for convenience to the user.&lt;/p&gt;
&lt;p&gt;We’ve stumbled upon common pattern in dependent Haskell: “building up” a value-level singleton &lt;em&gt;structure&lt;/em&gt; from a type that we want (either explicitly given as an argument, or provided through a typeclass like &lt;code&gt;SingI&lt;/code&gt;) and then inductively piggybacking on that structure’s constructors to build the thing you &lt;em&gt;really&lt;/em&gt; want (called “elimination”). Here, we use &lt;code&gt;SingI hs&lt;/code&gt; and “eliminate” that structure to create our &lt;code&gt;Network i hs o&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;on-typeclasses-and-dictionaries&quot;&gt;On Typeclasses and Dictionaries&lt;/h4&gt;
&lt;p&gt;One of the more bizarre things here, to me, is that &lt;code&gt;SNat&lt;/code&gt; somehow gave us a &lt;code&gt;KnownNat n&lt;/code&gt; instance that we can use and pass off to &lt;code&gt;randomWeights&lt;/code&gt;. However, once you realize that typeclasses in Haskell really aren’t any more than a way to pass in implicit arguments, it starts to make sense.&lt;/p&gt;
&lt;p&gt;The only thing you can really do from a &lt;code&gt;KnownNat&lt;/code&gt; is to get an &lt;code&gt;Integer&lt;/code&gt; from it with &lt;code&gt;natVal&lt;/code&gt;. So really, &lt;code&gt;KnownNat n =&amp;gt; ...&lt;/code&gt; is more or less the same as &lt;code&gt;Integer -&amp;gt; ...&lt;/code&gt;. That’s right — at runtime, a &lt;code&gt;KnownNat n&lt;/code&gt; constraint is more or less just an &lt;code&gt;Integer&lt;/code&gt; that GHC passes around automatically for you, to save you the hassle of manually passing it in yourself. (We say that the “dictionary” of &lt;code&gt;KnownNat&lt;/code&gt; is &lt;code&gt;Integer&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;So, the constructor:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Is really &lt;em&gt;kind&lt;/em&gt; of like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n
&lt;span class=&quot;co&quot;&gt;-- or, in normal data type notation&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- kinda!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The GADT constructor for &lt;code&gt;SNat&lt;/code&gt; requires a &lt;code&gt;KnownNat n&lt;/code&gt; instance in scope to produce. That instance is essentially stored inside the constructor (as if it were just an &lt;code&gt;Integer&lt;/code&gt;). Then, later, when you pattern match on it, you pattern match out the instance that was originally put in there, and you can use it!&lt;/p&gt;
&lt;p&gt;So what’s the big deal, why not just ditch &lt;code&gt;KnownNat&lt;/code&gt; and just pass around integers? The difference is that GHC and the compiler can now &lt;em&gt;track&lt;/em&gt; these at compile-time to give you &lt;em&gt;checks&lt;/em&gt; on how your Nat’s act together on the type level, allowing it to catch mismatches with compile-time checks instead of run-time checks.&lt;/p&gt;
&lt;h3 id=&quot;running-with-it&quot;&gt;Running with it&lt;/h3&gt;
&lt;p&gt;So now, you can use &lt;code&gt;randomNet :: IO (Network 5 &#39;[4,3] 2)&lt;/code&gt; to get a random network of the desired dimensions! (&lt;code&gt;IO&lt;/code&gt; is an instance of &lt;code&gt;MonadRandom&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;Can we just pause right here to just appreciate how awesome it is that we can generate random networks of whatever size we want by &lt;em&gt;just requesting something by its type&lt;/em&gt;? Our implementation is also &lt;em&gt;guaranteed&lt;/em&gt; to have the right sized matrices — no worrying about using the right size parameters for the right matrix in the right order. GHC does it for you automatically! And, for the person who &lt;em&gt;uses&lt;/em&gt; &lt;code&gt;randomNet&lt;/code&gt;, they don’t have to bungle around with figuring out what function argument indicates what, and in what order, and they don’t have to play a guessing game about the shape of the returned matrix.&lt;/p&gt;
&lt;p&gt;The code for &lt;em&gt;running&lt;/em&gt; the nets is actually literally identical from before:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L42-54&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;runLayer ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
         &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o
         &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; i
         &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o
runLayer (&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN) v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; v

&lt;span class=&quot;ot&quot;&gt;runNet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; i
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o
runNet (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w)      &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic (runLayer w v)
runNet (w &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39;) &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic (runLayer w v)
                       &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  runNet n&amp;#39; v&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But now, we get the assurance that the matrices and vectors all fit each-other, at compile-time. GHC basically writes our code for us. The operations all demand vectors and matrices that “fit together”, so you can only ever multiply a matrix by a properly sized vector.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;(+)  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n
     &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n
&lt;span class=&quot;ot&quot;&gt;(#&amp;gt;) ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; m)
     &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;L&lt;/span&gt; n m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n

&lt;span class=&quot;ot&quot;&gt;logistic ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n
         &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The source code is the same from before, so there isn’t any extra overhead in annotation. The correctness proofs and guarantees basically come without any extra work — they’re free!&lt;/p&gt;
&lt;p&gt;Our back-prop algorithm is ported pretty nicely too:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L76-116&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;train ::&lt;/span&gt; forall i hs o&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
      &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- ^ learning rate&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; i              &lt;span class=&quot;co&quot;&gt;-- ^ input vector&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o              &lt;span class=&quot;co&quot;&gt;-- ^ target vector&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o   &lt;span class=&quot;co&quot;&gt;-- ^ network to train&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o
train rate x0 target &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fst &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; go x0
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    go  ::&lt;/span&gt; forall j js&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; j
        &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; j              &lt;span class=&quot;co&quot;&gt;-- ^ input vector&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; j js o   &lt;span class=&quot;co&quot;&gt;-- ^ network to train&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; j js o, &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; j)
    &lt;span class=&quot;co&quot;&gt;-- handle the output layer&lt;/span&gt;
    go &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;x (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN))
        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runLayer w x
              o    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic y
              &lt;span class=&quot;co&quot;&gt;-- the gradient (how much y affects the error)&lt;/span&gt;
              &lt;span class=&quot;co&quot;&gt;--   (logistic&amp;#39; is the derivative of logistic)&lt;/span&gt;
              dEdy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic&amp;#39; y &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; (o &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; target)
              &lt;span class=&quot;co&quot;&gt;-- new bias weights and node weights&lt;/span&gt;
              wB&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; konst rate &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; dEdy
              wN&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; konst rate &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; (dEdy &lt;span class=&quot;ot&quot;&gt;`outer`&lt;/span&gt; x)
              w&amp;#39;   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB&amp;#39; wN&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- bundle of derivatives for next step&lt;/span&gt;
              dWs  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; tr wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; dEdy
          &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w&amp;#39;, dWs)
    &lt;span class=&quot;co&quot;&gt;-- handle the inner layers&lt;/span&gt;
    go &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;x (w&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN) &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n)
        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runLayer w x
              o          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic y
              &lt;span class=&quot;co&quot;&gt;-- get dWs&amp;#39;, bundle of derivatives from rest of the net&lt;/span&gt;
              (n&amp;#39;, dWs&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go o n
              &lt;span class=&quot;co&quot;&gt;-- the gradient (how much y affects the error)&lt;/span&gt;
              dEdy       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic&amp;#39; y &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; dWs&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- new bias weights and node weights&lt;/span&gt;
              wB&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; konst rate &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; dEdy
              wN&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; konst rate &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; (dEdy &lt;span class=&quot;ot&quot;&gt;`outer`&lt;/span&gt; x)
              w&amp;#39;   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB&amp;#39; wN&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- bundle of derivatives for next step&lt;/span&gt;
              dWs  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; tr wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; dEdy
          &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (w&amp;#39; &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39;, dWs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It’s pretty much again almost an exact copy-and-paste, but now with GHC checking to make sure everything fits together in our implementation.&lt;/p&gt;
&lt;p&gt;One thing that’s hard for me to convey here without walking through the implementation step-by-step is how much the types &lt;em&gt;help you&lt;/em&gt; in writing this code.&lt;/p&gt;
&lt;p&gt;Before starting writing a back-prop implementation without the help of types, I’d probably be a bit concerned. I mentioned earlier that writing the untyped version was no fun at all. But, with the types, writing the implementation became a &lt;em&gt;joy&lt;/em&gt; again. And, you have the help of &lt;em&gt;hole driven development&lt;/em&gt;, too.&lt;/p&gt;
&lt;p&gt;If you need, say, an &lt;code&gt;R n&lt;/code&gt;, there might be only one way get it! And if you have something that you need to combine with something you don’t know about, you can use typed holes (&lt;code&gt;_&lt;/code&gt;) and GHC will give you a list of all the values you have in scope that can fit there. Your programs basically write themselves!&lt;/p&gt;
&lt;p&gt;The more you can restrict the implementations of your functions with your types, the more of a joy programming in Haskell is. Things fit together and fall together before your eyes…and the best part is that if they’re wrong, the compiler will nudge you gently into the correct direction.&lt;/p&gt;
&lt;p&gt;The most stressful part of programming happens when you have to tenuously hold a complex and fragile network of ideas and constraints in your brain, and any slight distraction or break in focus causes everything to crash down in your mind. Over time, people have begun to believe that this is “normal” in programming. Don’t believe this lie — it’s &lt;em&gt;not&lt;/em&gt;! A good programming experience involves maintaining as &lt;em&gt;little&lt;/em&gt; in your head as possible, and letting the compiler handle remembering/checking the rest.&lt;/p&gt;
&lt;h4 id=&quot;the-final-test&quot;&gt;The final test&lt;/h4&gt;
&lt;p&gt;You can download the &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs&quot;&gt;typed network&lt;/a&gt; source code and run it yourself. Again, the &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L151-159&quot;&gt;&lt;code&gt;main&lt;/code&gt;&lt;/a&gt; method is written identically to that of the other file and tests the identical function.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;stack&lt;/span&gt; install hmatrix MonadRandom singletons
$ &lt;span class=&quot;ex&quot;&gt;stack&lt;/span&gt; ghc -- -O2 ./NetworkTyped.hs
$ &lt;span class=&quot;ex&quot;&gt;./NetworkTyped&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# Training network...&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#             -#########-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#           -#############=&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          -###############-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          =###############=&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#           ##############=.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#            .##########=.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                               .==#=-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                            -###########-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                           =##############.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                          .###############=&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                           =##############-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                            =############-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                              -######=-.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;finding-something-to-depend-on&quot;&gt;Finding Something to Depend on&lt;/h2&gt;
&lt;p&gt;We wrote out an initial “non-typed” implementation and recognized a lot red flags that you might already be trained to recognize if you have been programming Haskell for a while: &lt;em&gt;partial functions&lt;/em&gt; and &lt;em&gt;multiple potential implementations&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We followed our well-tuned Haskell guts, listened to our hearts, and introduced extra power in our types to remove all partial functions and eliminate &lt;em&gt;most&lt;/em&gt; potential implementations (though not all, yet — there are more gains to be made from pulling in more parametric polymorphism).&lt;/p&gt;
&lt;p&gt;Though we might have been able to find the bugs we avoided “eventually”, we were able to remove entire &lt;em&gt;dimensions&lt;/em&gt; of programmer concern and also leverage parametric polymorphism to help write our programs for us. We found joy again in programming.&lt;/p&gt;
&lt;p&gt;In the process, however, we encountered some unexpected resistance from Haskell (the language). We couldn’t directly pattern match on our types, so we ended up playing games with singletons and GADT constructors to pass instances.&lt;/p&gt;
&lt;p&gt;In practice, using types as powerful and descriptive as these begin to require a whole new set of tools once you get past the simplest use cases here. For example, our &lt;code&gt;Network&lt;/code&gt; types so far required you to specify their size in the program itself (&lt;code&gt;Network 2 &#39;[16, 8] 1&lt;/code&gt; in the example source code, for instance). But what if we wanted to generate a network that has runtime-determined size (For example, getting the size from user input)? What if we wanted to load a pre-trained network whose size we don’t know? How can we manipulate our networks in a “dynamic” and generic way that still gives us all of the benefits of type-safe programming? We’ll found out next post!&lt;/p&gt;
&lt;p&gt;What we’re looking at here is a world where &lt;em&gt;types&lt;/em&gt; can depend on run-time values … and values can depend on types. A world where types can be returned from functions and where types become as much of a manipulatable citizen of as values are.&lt;/p&gt;
&lt;p&gt;The art of working with types like this is &lt;em&gt;dependently typed programming&lt;/em&gt;. We’re going to feel a bit of push back from Haskell at first, but after we hit our stride and tame the tools we need, we’re going to open up a whole new world of potential!&lt;/p&gt;
&lt;h3 id=&quot;exercises&quot;&gt;Exercises&lt;/h3&gt;
&lt;p&gt;Here are some exercises you can do for fun to test your understanding and apply some of the concepts! The links are to the solutions in the source file.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Write a function that &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L167-168&quot;&gt;“pops” the input layer&lt;/a&gt; off of a &lt;code&gt;Network&lt;/code&gt;, returning both the input layer’s weights and the rest of the network, &lt;code&gt;(Weights i h, Network h hs o)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Think about what its type would have to be. Could it possibly be called with a network that cannot be popped? (that is, that has only one layer?)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Write a &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L170-184&quot;&gt;function that takes two networks of the same dimensions and adds together their weights&lt;/a&gt;. Remember that &lt;code&gt;L m n&lt;/code&gt; has a &lt;code&gt;Num&lt;/code&gt; instance that adds the matrices together element-by-element.&lt;/p&gt;
&lt;p&gt;Could this function ever be accidentally called on two networks that have different internal structures?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Write a function that takes a &lt;code&gt;Network i hs o&lt;/code&gt; and &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L186-189&quot;&gt;returns the singleton representing its hidden layer structure&lt;/a&gt; — &lt;code&gt;Sing hs&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;hiddenSing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; hs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;&amp;lt;- randomNet ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[5,3] 1)&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; s &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; hiddenSing n
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t s
&lt;span class=&quot;ot&quot;&gt;s ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[5,3]&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; s
&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;This sentence is the story of my Haskell life.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;Okay, maybe not &lt;em&gt;literally&lt;/em&gt; every one. But, pretty much every one.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;Thank you based Hindley-Milner.&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;This entire section was previously written to use the &lt;a href=&quot;http://hackage.haskell.org/package/typelits-witnesses&quot;&gt;typelits-witnesses&lt;/a&gt; library, but has now been re-written to use the canonical &lt;a href=&quot;https://hackage.haskell.org/package/singletons&quot;&gt;singletons&lt;/a&gt; library after a &lt;a href=&quot;https://www.reddit.com/r/haskell/comments/4l199z/practical_dependent_types_in_haskell_type_safe/d3jkslv&quot;&gt;conversation&lt;/a&gt; with Andras Kovacs. The &lt;a href=&quot;https://github.com/mstksg/inCode/blob/697c1f726b9ab9c3f9830ed5521bfeee6ec10727/entry/practical-dependent-types-in-haskell-1.md#singletons-and-induction&quot;&gt;old version&lt;/a&gt; is still online at github, if you want to look at it or compare!&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html</guid><pubDate>Wed, 25 May 2016 19:46:21 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings</dc:subject><dc:date>2016-05-25</dc:date></item><item><title>Automatic Propagation of Uncertainty with AD</title><link>https://blog.jle.im/entry/automatic-propagation-of-uncertainty-with-ad.html</link><description>&lt;blockquote&gt;
&lt;p&gt;This post and &lt;a href=&quot;https://blog.jle.im/entries/series/+uncertain.html&quot;&gt;series&lt;/a&gt; is a walk-through of the implementation of my &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/uncertain&quot;&gt;uncertain&lt;/a&gt;&lt;/em&gt; library, now on hackage!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Some of my favorite Haskell “tricks” involve working with exotic numeric types with custom “overloaded” numeric functions and literals that let us work with data in surprisingly elegant and expressive ways.&lt;/p&gt;
&lt;p&gt;Here is one example — from my work in experimental physics and statistics, we often deal with experimental/sampled values with inherent uncertainty. If you ever measure something to be &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?12.3%5C%2C%5Cmathrm%7Bcm%7D&quot; alt=&quot;12.3\,\mathrm{cm}&quot; title=&quot;12.3\,\mathrm{cm}&quot; /&gt;, that doesn’t mean it’s &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?12.300000%5C%2C%5Cmathrm%7Bcm%7D&quot; alt=&quot;12.300000\,\mathrm{cm}&quot; title=&quot;12.300000\,\mathrm{cm}&quot; /&gt; — it means that it’s somewhere between &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?12.2%5C%2C%5Cmathrm%7Bcm%7D&quot; alt=&quot;12.2\,\mathrm{cm}&quot; title=&quot;12.2\,\mathrm{cm}&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?12.4%5C%2C%5Cmathrm%7Bcm%7D&quot; alt=&quot;12.4\,\mathrm{cm}&quot; title=&quot;12.4\,\mathrm{cm}&quot; /&gt;…and we don’t know exactly. We can write it as &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?12.3%20%5Cpm%200.1%5C%2C%5Cmathrm%7Bcm%7D&quot; alt=&quot;12.3 \pm 0.1\,\mathrm{cm}&quot; title=&quot;12.3 \pm 0.1\,\mathrm{cm}&quot; /&gt;. The interesting thing happens when we try to add, multiply, divide numbers with uncertainty. What happens when you “add” &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?12%20%5Cpm%203&quot; alt=&quot;12 \pm 3&quot; title=&quot;12 \pm 3&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?19%20%5Cpm%206&quot; alt=&quot;19 \pm 6&quot; title=&quot;19 \pm 6&quot; /&gt;?&lt;/p&gt;
&lt;p&gt;The initial guess might be &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?31%20%5Cpm%209&quot; alt=&quot;31 \pm 9&quot; title=&quot;31 \pm 9&quot; /&gt;, because one is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cpm%203&quot; alt=&quot;\pm 3&quot; title=&quot;\pm 3&quot; /&gt; and the other is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cpm%206&quot; alt=&quot;\pm 6&quot; title=&quot;\pm 6&quot; /&gt;. But! If you actually do experiments like this several times, you’ll see that this isn’t the case. If you tried this out experimentally and simulate several hundred trials, you’ll see that the answer is actually something like &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?31%20%5Cpm%207&quot; alt=&quot;31 \pm 7&quot; title=&quot;31 \pm 7&quot; /&gt;. (We’ll explain why later, but feel free to stop reading this article now and try this out yourself!&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Let’s write ourselves a Haskell data type that lets us work with “numbers with inherent uncertainty”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;14.6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.8&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;   &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y
&lt;span class=&quot;dv&quot;&gt;46&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y
&lt;span class=&quot;dv&quot;&gt;450&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;40&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; sqrt (x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y)
&lt;span class=&quot;fl&quot;&gt;6.8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; logBase y x
&lt;span class=&quot;fl&quot;&gt;0.78&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.02&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; log (x&lt;span class=&quot;fu&quot;&gt;**&lt;/span&gt;y)
&lt;span class=&quot;fl&quot;&gt;85.9&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Along the way, we’ll also learn how to harness the power of awesome &lt;a href=&quot;https://hackage.haskell.org/package/ad&quot;&gt;ad&lt;/a&gt; library, a library used in implementing back-propagation and other optimization algorithms, to analyze numerical functions in a mathematical way and break down their derivatives and gradients.&lt;/p&gt;
&lt;p&gt;You can follow along with &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs&quot;&gt;the source code&lt;/a&gt;, which is actually a &lt;em&gt;&lt;a href=&quot;http://www.haskellstack.org&quot;&gt;stack&lt;/a&gt;&lt;/em&gt; executable! If you download the source and you have &lt;em&gt;&lt;a href=&quot;http://www.haskellstack.org&quot;&gt;stack&lt;/a&gt;&lt;/em&gt; installed, you can run it (and run the tests above) as an executable:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;./Uncertain.hs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Otherwise, you can run it directly with stack (using &lt;code&gt;runhaskell&lt;/code&gt;) and the &lt;a href=&quot;shttp://hackage.haskell.org/package/linear/docs/Linear-V2.html&quot;&gt;linear&lt;/a&gt; and &lt;a href=&quot;https://hackage.haskell.org/package/ad&quot;&gt;ad&lt;/a&gt; packages installed…or load it up with &lt;code&gt;stack ghci&lt;/code&gt; to play with it. If you want to be sure to reproduce the behavior, this article was written under &lt;a href=&quot;https://www.stackage.org/&quot;&gt;stackage&lt;/a&gt; snapshot &lt;a href=&quot;https://www.stackage.org/lts-5.15&quot;&gt;lts-5.15&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;dealing-with-uncertainty-precisely&quot;&gt;Dealing with Uncertainty Precisely&lt;/h2&gt;
&lt;p&gt;First of all, let’s think about why adding two “uncertain” values doesn’t involve simply adding the uncertainties linearly. (If you don’t care about the math and just want to get on to the Haskell, feel free to skip this section!)&lt;/p&gt;
&lt;p&gt;If I have a value &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?16%20%5Cpm%203&quot; alt=&quot;16 \pm 3&quot; title=&quot;16 \pm 3&quot; /&gt; (maybe I have a ruler whose ticks are 3 units apart, or an instrument that produces measurements with 3 units of noise), it either means that it’s a little below 16 or a little above 16. If I have an independently sampled value &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?25%20%5Cpm%204&quot; alt=&quot;25 \pm 4&quot; title=&quot;25 \pm 4&quot; /&gt;, it means that it’s a little below 25 or a little above 25.&lt;/p&gt;
&lt;p&gt;What happens if I want to think about their sum? Well, it’s going to be somewhere around 41. But, the uncertainty won’t be &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cpm%207&quot; alt=&quot;\pm 7&quot; title=&quot;\pm 7&quot; /&gt;. It would only be &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cpm%207&quot; alt=&quot;\pm 7&quot; title=&quot;\pm 7&quot; /&gt; if the errors in the two values are &lt;em&gt;always aligned&lt;/em&gt;. Only if or when every “little bit above” 16 error lines up perfectly with a “little bit above” 25 error, and when every single “little bit below” 16 error lines up perfectly with a “little bit above” 25 error, would you really get something that is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cpm%207&quot; alt=&quot;\pm 7&quot; title=&quot;\pm 7&quot; /&gt;. But, because the two values are sampled independently, you shouldn’t expect such alignment. So, you’ll get an uncertainty that’s &lt;em&gt;less than&lt;/em&gt; &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cpm%207&quot; alt=&quot;\pm 7&quot; title=&quot;\pm 7&quot; /&gt;. In fact, it’ll actually be around &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cpm%205&quot; alt=&quot;\pm 5&quot; title=&quot;\pm 5&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;In general, we find that for &lt;em&gt;independent&lt;/em&gt; &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?X&quot; alt=&quot;X&quot; title=&quot;X&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?Y&quot; alt=&quot;Y&quot; title=&quot;Y&quot; /&gt;:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Coperatorname%7BVar%7D%5BaX%20%2B%20bY%20%2B%20c%5D%20%3D%20a%5E2%20%5Csigma_X%5E2%20%2B%20b%5E2%20%5Csigma_Y%5E2%0A&quot; alt=&quot;
\operatorname{Var}[aX + bY + c] = a^2 \sigma_X^2 + b^2 \sigma_Y^2
&quot; title=&quot;
\operatorname{Var}[aX + bY + c] = a^2 \sigma_X^2 + b^2 \sigma_Y^2
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Csigma_X%5E2&quot; alt=&quot;\sigma_X^2&quot; title=&quot;\sigma_X^2&quot; /&gt; is the variance in &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?X&quot; alt=&quot;X&quot; title=&quot;X&quot; /&gt;. We consider &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Csigma_X&quot; alt=&quot;\sigma_X&quot; title=&quot;\sigma_X&quot; /&gt; to be the standard deviation of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?X&quot; alt=&quot;X&quot; title=&quot;X&quot; /&gt;, or the “plus or minus” part of our numbers. In the simple case of addition, we have &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Coperatorname%7BVar%7D%5BX%20%2B%20Y%5D%20%3D%20%5Csigma_X%5E2%20%2B%20%5Csigma_Y%5E2&quot; alt=&quot;\operatorname{Var}[X + Y] = \sigma_X^2 + \sigma_Y^2&quot; title=&quot;\operatorname{Var}[X + Y] = \sigma_X^2 + \sigma_Y^2&quot; /&gt;, so our new uncertainty is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Csqrt%7B%5Csigma_X%5E2%20%2B%20%5Csigma_Y%5E2%7D&quot; alt=&quot;\sqrt{\sigma_X^2 + \sigma_Y^2}&quot; title=&quot;\sqrt{\sigma_X^2 + \sigma_Y^2}&quot; /&gt;.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;However, not all functions that combine &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?X&quot; alt=&quot;X&quot; title=&quot;X&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?Y&quot; alt=&quot;Y&quot; title=&quot;Y&quot; /&gt; can be expressed as simple linear combinations &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?aX%20%2B%20bY%20%2B%20c&quot; alt=&quot;aX + bY + c&quot; title=&quot;aX + bY + c&quot; /&gt;. But! If you dig back to your days of high school calculus, you might remember a method for expressing any arbitrary function as a linear approximation – the &lt;a href=&quot;https://en.wikipedia.org/wiki/Taylor_series&quot;&gt;Taylor Expansion&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;In general, we can attempt to approximate any well-behaving function around a point as its tangent hyperplane:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0Af%28x_0%20%2B%20x%2C%20y_0%20%2B%20y%29%20%5Capprox%20f_x%28x_0%2C%20y_0%29%20x%20%2B%20f_y%28x_0%2C%20y_0%29%20y%20%2B%20f%28x_0%2C%20y_0%29%0A&quot; alt=&quot;
f(x_0 + x, y_0 + y) \approx f_x(x_0, y_0) x + f_y(x_0, y_0) y + f(x_0, y_0)
&quot; title=&quot;
f(x_0 + x, y_0 + y) \approx f_x(x_0, y_0) x + f_y(x_0, y_0) y + f(x_0, y_0)
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f_x%28x_0%2Cy_0%29&quot; alt=&quot;f_x(x_0,y_0)&quot; title=&quot;f_x(x_0,y_0)&quot; /&gt; is the first (partial) derivative with respect to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?x&quot; alt=&quot;x&quot; title=&quot;x&quot; /&gt; at &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%28x_0%2C%20y_0%29&quot; alt=&quot;(x_0, y_0)&quot; title=&quot;(x_0, y_0)&quot; /&gt;. This gives us an approximation of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f&quot; alt=&quot;f&quot; title=&quot;f&quot; /&gt; at locations close to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%28x_0%2C%20y_0%29&quot; alt=&quot;(x_0, y_0)&quot; title=&quot;(x_0, y_0)&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;Look familiar? This is exactly the form that we used earlier to calculate “combined” variance! If we approximate the functions around &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%28%5Cmu_X%2C%20%5Cmu_Y%29&quot; alt=&quot;(\mu_X, \mu_Y)&quot; title=&quot;(\mu_X, \mu_Y)&quot; /&gt;, the center/expected value of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?X&quot; alt=&quot;X&quot; title=&quot;X&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?Y&quot; alt=&quot;Y&quot; title=&quot;Y&quot; /&gt;, we see:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Coperatorname%7BVar%7D%5Bf%28X%2CY%29%5D%20%5Capprox%20f_x%28%5Cmu_X%2C%20%5Cmu_Y%29%5E2%20%5Csigma_X%5E2%20%2B%20f_y%28%5Cmu_X%2C%5Cmu_Y%29%5E2%20%5Csigma_Y%5E2%0A&quot; alt=&quot;
\operatorname{Var}[f(X,Y)] \approx f_x(\mu_X, \mu_Y)^2 \sigma_X^2 + f_y(\mu_X,\mu_Y)^2 \sigma_Y^2
&quot; title=&quot;
\operatorname{Var}[f(X,Y)] \approx f_x(\mu_X, \mu_Y)^2 \sigma_X^2 + f_y(\mu_X,\mu_Y)^2 \sigma_Y^2
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;A similar analysis can be used to figure out how the expected value changes by taking the taylor expansion to the &lt;em&gt;second&lt;/em&gt; degree:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Coperatorname%7BE%7D%5Bf%28X%2CY%29%5D%20%5Capprox%0Af%28%5Cmu_X%2C%20%5Cmu_Y%29%20%2B%20%5Cfrac%7B1%7D%7B2%7D%0A%5Cleft%5B%20f_%7Bxx%7D%28%5Cmu_X%2C%20%5Cmu_Y%29%20%5Csigma_X%5E2%20%2B%20f_%7Byy%7D%28%5Cmu_X%2C%20%5Cmu_Y%29%20%5Csigma_Y%5E2%20%5Cright%5D%0A&quot; alt=&quot;
\operatorname{E}[f(X,Y)] \approx
f(\mu_X, \mu_Y) + \frac{1}{2}
\left[ f_{xx}(\mu_X, \mu_Y) \sigma_X^2 + f_{yy}(\mu_X, \mu_Y) \sigma_Y^2 \right]
&quot; title=&quot;
\operatorname{E}[f(X,Y)] \approx
f(\mu_X, \mu_Y) + \frac{1}{2}
\left[ f_{xx}(\mu_X, \mu_Y) \sigma_X^2 + f_{yy}(\mu_X, \mu_Y) \sigma_Y^2 \right]
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f_%7Bxx%7D%28%5Cmu_X%2C%20%5Cmu_Y%29&quot; alt=&quot;f_{xx}(\mu_X, \mu_Y)&quot; title=&quot;f_{xx}(\mu_X, \mu_Y)&quot; /&gt; is the second (partial) derivative with respect to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?x&quot; alt=&quot;x&quot; title=&quot;x&quot; /&gt; twice at &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%28%5Cmu_X%2C%20%5Cmu_Y%29&quot; alt=&quot;(\mu_X, \mu_Y)&quot; title=&quot;(\mu_X, \mu_Y)&quot; /&gt;&lt;/p&gt;
&lt;p&gt;For our case of simple addition, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Coperatorname%7BE%7D%5BX%20%2B%20Y%5D%20%3D%20%5Cmu_X%20%2B%20%5Cmu_Y&quot; alt=&quot;\operatorname{E}[X + Y] = \mu_X + \mu_Y&quot; title=&quot;\operatorname{E}[X + Y] = \mu_X + \mu_Y&quot; /&gt;, because the second-order partials of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f%28x%2Cy%29%20%3D%20x%20%2B%20y&quot; alt=&quot;f(x,y) = x + y&quot; title=&quot;f(x,y) = x + y&quot; /&gt; are 0.&lt;/p&gt;
&lt;h2 id=&quot;uncertain-values-in-haskell&quot;&gt;Uncertain Values in Haskell&lt;/h2&gt;
&lt;p&gt;So, how are we going to model our uncertain values in Haskell … ? With an Algebraic Data Type, of course!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L18-20&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; uMean ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;a
                   ,&lt;span class=&quot;ot&quot;&gt; uVar  ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;a
                   }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We’ll keep track of the mean (the central point) and the &lt;em&gt;variance&lt;/em&gt;, which is the standard deviation &lt;em&gt;squared&lt;/em&gt;. We keep track of the variance and not the standard deviation (the “plus or minus”) because the mathematics is a bit more straightforward.&lt;/p&gt;
&lt;p&gt;We can write a function to turn a “plus or minus” statement into an &lt;code&gt;Uncert&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L22-23&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;(+/-) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
x &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; dx &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x (dx&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;dx)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Give the &lt;code&gt;dx&lt;/code&gt; (the standard deviation) and store &lt;code&gt;dx^2&lt;/code&gt;, the variance.&lt;/p&gt;
&lt;p&gt;Let’s also throw in a handy helper function for “exact” values:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L25-26&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;exact ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
exact x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But, we can do better (if just for fun). We can use pattern synonyms to basically “abstract” away the data type itself, and let people pattern match on a mean and standard deviation:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L29-34&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- pattern (:+/-) :: () =&amp;gt; Floating a =&amp;gt; a -&amp;gt; a -&amp;gt; Uncert a&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- [GHC 8.0:]&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- pattern (:+/-) :: Floating a =&amp;gt; a -&amp;gt; a -&amp;gt; Uncert a&lt;/span&gt;
pattern x &lt;span class=&quot;fu&quot;&gt;:+/-&lt;/span&gt; dx &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x (sqrt&lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;dx)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    x &lt;span class=&quot;fu&quot;&gt;:+/-&lt;/span&gt; dx &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x (dx&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;dx)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Note that the type signature you need for this is different depending on if you’re in GHC 8.0 and GHC 7.10; they’re mutually incompatible. How unfortunate!)&lt;/p&gt;
&lt;p&gt;Now, people can pattern match on &lt;code&gt;x :+/- dx&lt;/code&gt; and receive the mean and uncertainty directly. Neat!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L36-37&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;uStdev ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Floating&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
uStdev (_ &lt;span class=&quot;fu&quot;&gt;:+/-&lt;/span&gt; dx) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;making-it-numeric&quot;&gt;Making it Numeric&lt;/h3&gt;
&lt;p&gt;Now, time for the magic! Let’s write a &lt;code&gt;Num&lt;/code&gt; instance!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fromIntegral      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; exact &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromIntegral
    &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y)    (vx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; vy)
    &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; y)    (vx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; vy)
    &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y)    (y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vy)
    negate (&lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (negate x) vx
    &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…that’s it! Do the same thing for every numeric typeclass, and you get automatic propagation of uncertainty.&lt;/p&gt;
&lt;h3 id=&quot;the-problem&quot;&gt;The Problem&lt;/h3&gt;
&lt;p&gt;But, wait — this method is definitely not ideal. It’s pretty repetitive, and involves a but of copy-and-pasting code that is slightly different in ways the typechecker can’t verify. What if we didn’t change something we were supposed to? And, if you look at the &lt;code&gt;Fractional&lt;/code&gt; instance…&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fromRational      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; exact &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromRational
    &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (x&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;y &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;vy)   (x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;vx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; vy&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
    recip (&lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx)   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (recip x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; vx&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) (vx &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Yikes. All that ugly and complicated numerical code that the typechecker can’t help us with (and, honestly, I’m not very confident in the results myself!). Those are runtime bugs just waiting to happen. How do we even &lt;em&gt;know&lt;/em&gt; that we calculated the right derivatives, and implemented the formula correctly?&lt;/p&gt;
&lt;p&gt;What if we could reduce this boilerplate? What if we could somehow analytically compute derivatives for functions instead of computing them manually?&lt;/p&gt;
&lt;h2 id=&quot;automatic-differentiation&quot;&gt;Automatic Differentiation&lt;/h2&gt;
&lt;p&gt;Automatic differentiation is honestly one of the coolest Haskell tricks you can show that any beginner can immediately understand. Like our trick with &lt;code&gt;Uncert&lt;/code&gt;, it’s nice to use because of its overloaded &lt;code&gt;Num&lt;/code&gt;/numeric typeclasses.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; diff (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- 2*x&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; diff (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; sin x) &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;-- cos x&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; diff (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;-- 3*x^2 - 6*x + 2&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A very rough explanation about how forward-mode automatic differentiation works is that it uses a wrapper type (like ours) that defines &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;negate&lt;/code&gt;, etc. so that they also compute the &lt;em&gt;derivative(s)&lt;/em&gt; of the function, instead of just the &lt;em&gt;result&lt;/em&gt;, like normal. There are a lot of nice tutorials online, like &lt;a href=&quot;http://www.danielbrice.net/blog/10/&quot;&gt;this one&lt;/a&gt; by Daniel Brice, if you want to follow up on this fun little subject.&lt;/p&gt;
&lt;h3 id=&quot;single-variable-functions&quot;&gt;Single-variable functions&lt;/h3&gt;
&lt;p&gt;And, now that we can automatically differentiate functions, we can use this knowledge directly in our implementations. Let’s define a universal “lifter” of single-variable functions.&lt;/p&gt;
&lt;p&gt;We use the function &lt;code&gt;diffs0&lt;/code&gt; to get a “tower” of derivatives:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; diffs0 (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
[&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;112&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;88&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;46&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first value is actually &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?4%5E2%20-%202%20%5Ctimes%204%5E3&quot; alt=&quot;4^2 - 2 \times 4^3&quot; title=&quot;4^2 - 2 \times 4^3&quot; /&gt;. The second is the derivative (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?2%20x%20-%206x%5E2&quot; alt=&quot;2 x - 6x^2&quot; title=&quot;2 x - 6x^2&quot; /&gt;) at 4, the third is the second derivative &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?2%20-%2012%20x&quot; alt=&quot;2 - 12 x&quot; title=&quot;2 - 12 x&quot; /&gt; at 4, then the third derivative &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?-12&quot; alt=&quot;-12&quot; title=&quot;-12&quot; /&gt;, then the fourth derivative &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?0&quot; alt=&quot;0&quot; title=&quot;0&quot; /&gt;, etc.&lt;/p&gt;
&lt;p&gt;We only need the actual value and the first two derivatives, so we can pattern match them as &lt;code&gt;fx:dfx:ddfx:_ = diffs0 f x&lt;/code&gt;, the derivatives and values of the function we lift, &lt;code&gt;f&lt;/code&gt;, around the mean &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At that point, the equations we have from before just translate nicely:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Coperatorname%7BE%7D%5Bf%28X%29%5D%20%3D%20f%28%5Cmu_X%29%20%2B%20%5Cfrac%7B1%7D%7B2%7D%20f_%7Bxx%7D%28%5Cmu_X%29%20%5Csigma_X%5E2%0A&quot; alt=&quot;
\operatorname{E}[f(X)] = f(\mu_X) + \frac{1}{2} f_{xx}(\mu_X) \sigma_X^2
&quot; title=&quot;
\operatorname{E}[f(X)] = f(\mu_X) + \frac{1}{2} f_{xx}(\mu_X) \sigma_X^2
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Coperatorname%7BVar%7D%5Bf%28X%29%5D%20%3D%20f_x%28%5Cmu_X%29%5E2%20%5Csigma_X%5E2%0A&quot; alt=&quot;
\operatorname{Var}[f(X)] = f_x(\mu_X)^2 \sigma_X^2
&quot; title=&quot;
\operatorname{Var}[f(X)] = f_x(\mu_X)^2 \sigma_X^2
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;And we call &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cmu_X&quot; alt=&quot;\mu_X&quot; title=&quot;\mu_X&quot; /&gt; &lt;code&gt;x&lt;/code&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Csigma_X%5E2&quot; alt=&quot;\sigma_X^2&quot; title=&quot;\sigma_X^2&quot; /&gt; &lt;code&gt;vx&lt;/code&gt;, and this becomes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;y  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; ddfx &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vx &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
vy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dfx&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Putting it all together:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L39-47&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;liftU ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a
      &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Tower&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Tower&lt;/span&gt; a))
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
liftU f (&lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fx&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;dfx&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ddfx&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; diffs0 f x
    y             &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; ddfx &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vx &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
    vy            &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dfx&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type &lt;code&gt;forall s. AD s (Tower a) -&amp;gt; AD s (Tower a)&lt;/code&gt; looks a little scary, but you can think of it as representing a function on &lt;code&gt;a&lt;/code&gt; (like &lt;code&gt;negate&lt;/code&gt;, &lt;code&gt;(*2)&lt;/code&gt;, etc.) that the &lt;em&gt;ad&lt;/em&gt; library can differentiate several times — something you could use with &lt;code&gt;diff0&lt;/code&gt; to get a “tower” of derivatives.&lt;/p&gt;
&lt;p&gt;And … that’s it! We can already define things like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;negate &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU negate
recip  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU recip
sqrt   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU sqrt
sin    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU sin&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;multivariable-functions&quot;&gt;Multivariable functions&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;ad&lt;/em&gt; also lets you work multivariable functions, too. To model multivariable functions, it takes a function from a &lt;code&gt;Traversable&lt;/code&gt; of vales to a single value. We can use the &lt;code&gt;V2&lt;/code&gt; type from the &lt;em&gt;&lt;a href=&quot;shttp://hackage.haskell.org/package/linear/docs/Linear-V2.html&quot;&gt;linear&lt;/a&gt;&lt;/em&gt; package to pass in a two-variable function:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; grad (\(&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; x y) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x) (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The gradient of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f%28x%2C%20y%29%20%3D%20x%20y%5E2%20%2B%203x&quot; alt=&quot;f(x, y) = x y^2 + 3x&quot; title=&quot;f(x, y) = x y^2 + 3x&quot; /&gt; is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%28y%5E2%20%2B%203%2C%202xy%29&quot; alt=&quot;(y^2 + 3, 2xy)&quot; title=&quot;(y^2 + 3, 2xy)&quot; /&gt;, which, at &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%283%2C%201%29&quot; alt=&quot;(3, 1)&quot; title=&quot;(3, 1)&quot; /&gt;, is indeed &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%284%2C%206%29&quot; alt=&quot;(4, 6)&quot; title=&quot;(4, 6)&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;The gradient gives us the first order partials, but we need the second order partials to calculate the new mean, so for that, we can use &lt;code&gt;hessian&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hessian (\(&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; x y) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x) (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
   (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Hessian_matrix&quot;&gt;hessian&lt;/a&gt; of a function &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f%28x%2Cy%29&quot; alt=&quot;f(x,y)&quot; title=&quot;f(x,y)&quot; /&gt; is basically a matrix of second-order partial derivatives:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Cbegin%7Bbmatrix%7D%0Af_%7Bxx%7D%28x%2C%20y%29%20%26%20f_%7Byx%7D%28x%2C%20y%29%20%5C%5C%0Af_%7Byx%7D%28x%2C%20y%29%20%26%20f_%7Byy%7D%28x%2C%20y%29%0A%5Cend%7Bbmatrix%7D%0A&quot; alt=&quot;
\begin{bmatrix}
f_{xx}(x, y) &amp;amp; f_{yx}(x, y) \\
f_{yx}(x, y) &amp;amp; f_{yy}(x, y)
\end{bmatrix}
&quot; title=&quot;
\begin{bmatrix}
f_{xx}(x, y) &amp;amp; f_{yx}(x, y) \\
f_{yx}(x, y) &amp;amp; f_{yy}(x, y)
\end{bmatrix}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;In our case, we only care about the diagonal – the repeated double-derivatives, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f_%7Bxx%7D&quot; alt=&quot;f_{xx}&quot; title=&quot;f_{xx}&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f_%7Byy%7D&quot; alt=&quot;f_{yy}&quot; title=&quot;f_{yy}&quot; /&gt;. Indeed, the double-partial of our function respect to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?x&quot; alt=&quot;x&quot; title=&quot;x&quot; /&gt; is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?0&quot; alt=&quot;0&quot; title=&quot;0&quot; /&gt;, and the double-partial with respect to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?y&quot; alt=&quot;y&quot; title=&quot;y&quot; /&gt; is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?2x&quot; alt=&quot;2x&quot; title=&quot;2x&quot; /&gt;, which gives us a hessian with a diagonal &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%280%2C%206%29&quot; alt=&quot;(0, 6)&quot; title=&quot;(0, 6)&quot; /&gt; for the input &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%283%2C%201%29&quot; alt=&quot;(3, 1)&quot; title=&quot;(3, 1)&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;ad&lt;/em&gt; package generously gives us a function that lets us calculate the function’s result, its gradient, and its hessian all in one pass:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hessian&amp;#39; (\(&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; x y) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x) (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
(&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)
     &lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can access the gradient by using &lt;code&gt;fmap fst&lt;/code&gt; on the second component of the tuple and access the hessian by using &lt;code&gt;fmap snd&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We need a couple of helpers, first — one to get the “diagonal” of our hessian, because we only care about the repeated partials:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L49-53&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;diag ::&lt;/span&gt; [[a]] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a]
diag &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    []        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; []
    []   &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;yss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; diag (drop &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; yss)
    (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_)&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;yss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; diag (drop &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; yss)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And then a “dot product”, utility function, which just multiplies two lists together component-by-component and sums the results:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L55-56&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;dot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
dot xs ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sum (zipWith (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;) xs ys)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now we can write our multi-variate function lifter:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L58-75&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;liftUF ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; f, &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a)
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; f (&lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a))
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f (&lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a)
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
liftUF f us &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    xs          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;         uMean &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; us
    vxs         &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; toList (uVar  &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; us)
    (fx, hgrad) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; hessian&amp;#39; f xs
    dfxs        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fst &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; hgrad
    hess        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; snd &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; hgrad
    y           &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; partials &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        partials &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dot vxs
                 &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; diag
                 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; toList (fmap toList hess) &lt;span class=&quot;co&quot;&gt;-- from f (f a) to [[a]]&lt;/span&gt;
    vy          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dot vxs
                &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; toList ((&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; dfxs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Again, don’t mind the scary type &lt;code&gt;forall s. f (AD s (Sparse a)) -&amp;gt; AD s (Sparse a)&lt;/code&gt;, it’s just &lt;em&gt;ad&lt;/em&gt;’s type for things you can use &lt;code&gt;hessian&#39;&lt;/code&gt; on)&lt;/p&gt;
&lt;p&gt;And we can write some nice helper functions so we can use them more naturally:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L77-90&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;liftU2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a))
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
liftU2 f x y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftUF (\(&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; x&amp;#39; y&amp;#39;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f x&amp;#39; y&amp;#39;) (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; x y)

&lt;span class=&quot;ot&quot;&gt;liftU3 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a))
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
liftU3 f x y z &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftUF (\(&lt;span class=&quot;dt&quot;&gt;V3&lt;/span&gt; x&amp;#39; y&amp;#39; z&amp;#39;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f x&amp;#39; y&amp;#39; z&amp;#39;) (&lt;span class=&quot;dt&quot;&gt;V3&lt;/span&gt; x y z)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At this point, our code is pretty much complete. We can fill in the other two-argument functions from the numeric typeclasses:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;(&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;)     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU2 (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;)
(&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;)     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU2 (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;)
(&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;)     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU2 (&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;)
(&lt;span class=&quot;fu&quot;&gt;**&lt;/span&gt;)    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU2 (&lt;span class=&quot;fu&quot;&gt;**&lt;/span&gt;)
logBase &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU2 logBase&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Admittedly, there’s still some slight boilerplate (that you can get rid of with some Template Haskell, maybe), but you have a &lt;em&gt;lot&lt;/em&gt; less room for error, and a lot simpler to check over and read to make sure you didn’t miss any bugs.&lt;/p&gt;
&lt;h2 id=&quot;wrapping-it-up&quot;&gt;Wrapping it up&lt;/h2&gt;
&lt;p&gt;The full code (with all of the numeric instances fully implemented) is up &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs&quot;&gt;on github&lt;/a&gt;, which you can run and explore and test by executing it or loading it with &lt;code&gt;stack ghci&lt;/code&gt;. I’ve added a special &lt;em&gt;Show&lt;/em&gt; instance that “rounds” your values to as many digits that your uncertainty suggests, to give more meaningful &lt;code&gt;show&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;All of what’s in this post is actually up on my &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/uncertain&quot;&gt;uncertain&lt;/a&gt;&lt;/em&gt; package on hackage, if you want to use it in your own projects, or see how I take this and make it more robust for real-world applications. The project also has more features on top of the basic things shown here.&lt;/p&gt;
&lt;h3 id=&quot;verification-and-accuracy&quot;&gt;Verification and Accuracy&lt;/h3&gt;
&lt;p&gt;My &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/uncertain&quot;&gt;uncertain&lt;/a&gt;&lt;/em&gt; package has a Monte Carlo module to propagate uncertainty through Monte Carlo simulations. Let’s see how the values compare!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y         &lt;span class=&quot;co&quot;&gt;-- Monte Carlo Results:&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;46&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;            &lt;span class=&quot;co&quot;&gt;-- actually 46 +/- 2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y
&lt;span class=&quot;dv&quot;&gt;450&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;40&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;-- actually 450 +/- 40&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; sqrt (x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y)
&lt;span class=&quot;fl&quot;&gt;6.8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.2&lt;/span&gt;         &lt;span class=&quot;co&quot;&gt;-- actually 6.8 +/- 0.2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; logBase y x
&lt;span class=&quot;fl&quot;&gt;0.78&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.02&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- actually 0.78 +/- 0.02&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; log (x&lt;span class=&quot;fu&quot;&gt;**&lt;/span&gt;y)
&lt;span class=&quot;fl&quot;&gt;85.9&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.3&lt;/span&gt;        &lt;span class=&quot;co&quot;&gt;-- actually 83 +/- 6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, it looks like the mathematical model of uncertainty propagation matched up well with the “actual” results we gain from Monte Carlo simulations! The only one of our examples that was significantly wrong was the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Coperatorname%7Blog%7D%28x%5Ey%29&quot; alt=&quot;\operatorname{log}(x^y)&quot; title=&quot;\operatorname{log}(x^y)&quot; /&gt; example, which heavily underestimated the uncertainty by about a factor of 20. But, remember, the model was derived after dropping the 2nd, 3rd, 4th, etc. terms of the taylor expansion for the calculation of the new uncertainty, and the 4th, 6th, etc. terms of the taylor expansion for the calculation of the new mean. For functions that have high second, third, fourth derivatives relative to the mean and the uncertainty, it’s going to be a bit off.&lt;/p&gt;
&lt;h3 id=&quot;what-next&quot;&gt;What next?&lt;/h3&gt;
&lt;p&gt;For an extension on the mathematics behind this method, Dan Piponi has a &lt;a href=&quot;http://blog.sigfpe.com/2011/08/computing-errors-with-square-roots-of.html&quot;&gt;great article&lt;/a&gt; with a lot of good references for further reading on the formal method.&lt;/p&gt;
&lt;p&gt;Going off of what we’ve done here, a simple extension of this would be to implement the Monte Carlo simulator I mentioned above, which is pretty straightforward to implement with the &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/mwc-random&quot;&gt;mwc-random&lt;/a&gt;&lt;/em&gt; package.&lt;/p&gt;
&lt;p&gt;However, the most unsettling thing here that we never deal with is what happens correlated terms that are combined. All of our math assumed uncorrelated samples. But what happens if we have expressions that involve additions of correlated values?&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;14.6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.8&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; x
&lt;span class=&quot;dv&quot;&gt;29&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;14.6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.8&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x
&lt;span class=&quot;dv&quot;&gt;29&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unfortunately, &lt;code&gt;x + x&lt;/code&gt; is different than &lt;code&gt;2*x&lt;/code&gt;. This is because &lt;code&gt;x&lt;/code&gt; acts like an &lt;em&gt;independent generator&lt;/em&gt;, so when you say &lt;code&gt;x + x&lt;/code&gt;, it expands to &lt;code&gt;(14.6 +/- 0.8) + (14.6 +/- 0.8)&lt;/code&gt;, which represents the addition of two independent samples.&lt;/p&gt;
&lt;p&gt;When you say &lt;code&gt;2*x&lt;/code&gt;, that represents sampling &lt;code&gt;x&lt;/code&gt; &lt;em&gt;once&lt;/em&gt; and &lt;em&gt;doubling&lt;/em&gt; it. If you sample &lt;code&gt;x&lt;/code&gt; and double it, any error in &lt;code&gt;x&lt;/code&gt; will also be doubled. That’s why the uncertainty is greater in the &lt;code&gt;2*x&lt;/code&gt; version.&lt;/p&gt;
&lt;p&gt;How can we account for correlated values that are combined in complex ways? Stay tuned for the next part of the &lt;a href=&quot;https://blog.jle.im/entries/series/+uncertain.html&quot;&gt;series&lt;/a&gt;!&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;You can simulate noisy data by using uniform noise distributions, Gaussian distributions, or however manner you like that has a given expected value (mean) and “spread”. Verify by checking the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt; of the sums!&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;This law actually comes from the mathematical &lt;em&gt;definition&lt;/em&gt; of variance, so does not assume anything about the underlying distribution of the sampling — just that they are independent, and that they have defined variances.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;Or just look at my &lt;a href=&quot;https://hackage.haskell.org/package/uncertain&quot;&gt;package&lt;/a&gt; :)&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Tutorials</category><guid isPermaLink="true">https://blog.jle.im/entry/automatic-propagation-of-uncertainty-with-ad.html</guid><pubDate>Mon,  9 May 2016 19:38:24 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Tutorials</dc:subject><dc:date>2016-05-09</dc:date></item><item><title>Blog Rewrite with Hakyll and Purescript</title><link>https://blog.jle.im/entry/blog-rewrite-with-hakyll-and-purescript.html</link><description>&lt;p&gt;It’s been almost a year since my last post! Things have been a bit hectic with research and related things, and with the unrelenting academia publishing cycle, any time I can get to write or explore has been a nice escape.&lt;/p&gt;
&lt;p&gt;Admittedly, I’ve also run into some friction updating my blog because it was a compiled web server with some delicate dependencies and required environment configuration to build/deploy. It was written/built at a time when a lot of the infrastructure we have now in the Haskell ecosystem either wasn’t there, or wasn’t mature. We didn’t have easy &lt;a href=&quot;https://haskellonheroku.com/&quot;&gt;Heroku deployment&lt;/a&gt;, and we didn’t have great tools like &lt;a href=&quot;http://haskellstack.org/&quot;&gt;stack&lt;/a&gt; to let us create reproducible builds. One of my &lt;a href=&quot;http://blog.jle.im/entry/deploying-medium-to-large-haskell-apps-to-heroku.html&quot;&gt;first posts&lt;/a&gt; in 2013 was actually about hoops to jump through &lt;em&gt;just&lt;/em&gt; to get a simple Heroku deployment. I’ve had to maintain a virtual machine just to compile and push changes!&lt;/p&gt;
&lt;p&gt;My blog was one of my first Haskell projects ever, and if I had started it now, in 2016, things would definitely be a bit different. By this point, it’s been long enough and the slight inconveniences have been building up enough that I thought it’d be time to sit down and finally migrate my “first large-ish Haskell project” and bring it into modern times, by using &lt;a href=&quot;https://jaspervdj.be/hakyll/&quot;&gt;hakyll&lt;/a&gt; and &lt;a href=&quot;http://www.purescript.org/&quot;&gt;purescript&lt;/a&gt;. Here are my thoughts and observations on how the migration went, with insight on Haskell migrations in general!&lt;/p&gt;
&lt;p&gt;My blog engine is open-source, and the &lt;a href=&quot;https://github.com/mstksg/inCode&quot;&gt;source for this specific instance&lt;/a&gt; is up on github, for those interested in checking it out!&lt;/p&gt;
&lt;h2 id=&quot;hakyll&quot;&gt;Hakyll&lt;/h2&gt;
&lt;p&gt;To be honest, there was little actual practical reasons why my site wasn’t static to begin with. The main reason, feature-wise, was for me to be able to schedule blog posts and updates without requiring me to actually re-render and re-push every time I wanted to make a post. The real underlying reason, however, was that this blog was my first major Haskell project, and I wanted to take the opportunity to be able to learn how to interface with databases in Haskell.&lt;/p&gt;
&lt;p&gt;Now that that learning impetus is behind me, I felt free to throw it all out the window and rewrite things to be a completely 100% static site!&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaspervdj.be/hakyll/&quot;&gt;Hakyll&lt;/a&gt; was great; it’s basically like a very specialized &lt;em&gt;make&lt;/em&gt;-like tool for building sites. It takes a bit of time to get used to “thinking in Hakyll” — generating standalone pages instead of just ones based off of files, getting used to the identifier/snapshot system — but once you do, things go pretty smoothly. I started thinking about snapshots as customized “object files” that you can leave behind in the process of creating pages that other pages can use. Hakyll manages all the dependencies for you, so pages that depend on the things left from other pages will be sequenced properly, and rebuilding your website only requires rebuilding pages that depend on files you changed. Neat!&lt;/p&gt;
&lt;p&gt;Before, I had gotten the impression that Hakyll was mostly for generating “simple”, pre-built blog layouts, but I was able to use Hakyll (without much friction, at all) to generate the complex, intricate, and arbitrary site map that I had designed for my &lt;a href=&quot;http://hackage.haskell.org/package/scotty&quot;&gt;scotty&lt;/a&gt;-based blog. I definitely recommend it for any static site generating needs, blogs or not.&lt;/p&gt;
&lt;p&gt;An unexpected consequence of the static-site-hosted-by-github-pages approach, however, is that I don’t have any control over MIME types anymore (or 301 redirects), so I had to do some migrations to move pages over to “.html” and set up redirects and stuff (and get redirects to work with google analytics), but those were made super simple with Hakyll.&lt;/p&gt;
&lt;h2 id=&quot;refactoring-haskell-code&quot;&gt;Refactoring Haskell Code&lt;/h2&gt;
&lt;p&gt;One thing that did not disappoint me was how &lt;em&gt;easy&lt;/em&gt; and &lt;em&gt;painless&lt;/em&gt; it is to refactor Haskell code. This is something I always trumpet/brag about Haskell, and getting the opportunity to actually refactor a major-ish codebase.&lt;/p&gt;
&lt;p&gt;And, yes, I was not disappointed! For the most part, I already had my html templates, CSS, static javascript, etc. in place. All of the mechanisms were extremely modular and very easy to port. The type system made sure everything fit together well at the boundaries. They also instantly told me what did what, and ensured that sweeping changes in my code were safe. The “if it compiles, it works” mantra served me greatly here. I can’t even begin to imagine migrating one of my old ruby projects in the same way. With this, I was confident that my compiled code was correct and did what I wanted. The types were a guide and also a avenue of insight into my 3-years-removed past self.&lt;/p&gt;
&lt;p&gt;Thanks to the types, I was able to pick up something I hadn’t touched in 3 years, figure out how all things fit together, and completely gut everything apart and use them for a new build system … with compile-time assurances that I didn’t do anything incorrectly!&lt;/p&gt;
&lt;p&gt;It’s hard for me to really explain how amazing the feeling of refactoring Haskell code is. I used to dread refactors and migrations, but now I look forward to them and find any opportunity to do one! :D It’s something that’s difficult to convey the sublime joy of until you actually try it, so I recommend trying it some day :)&lt;/p&gt;
&lt;h2 id=&quot;purescript&quot;&gt;Purescript&lt;/h2&gt;
&lt;h3 id=&quot;on-fay&quot;&gt;on Fay&lt;/h3&gt;
&lt;p&gt;With my &lt;a href=&quot;http://blog.jle.im/entry/blog-engine-updates-markdown-preprocessor-fay-scripts.html#fay&quot;&gt;last major blog update&lt;/a&gt;, I ported all of my one-off javascript scripts to fay. This time around, I figured I’d move away from &lt;a href=&quot;https://github.com/faylang/fay/wiki&quot;&gt;fay&lt;/a&gt;, because it was slightly clunky to build/get working/integrate in the way that GHCJS spoiled me to be accustomed to. In the future, I might return … but at this point in time, Fay seems a bit awkward in the ecosystem. GHCJS lets you use the full power of Haskell (including all of &lt;em&gt;base&lt;/em&gt;’s concurrency mechanisms and almost every library on hackage), at the expense of creating large and unreadable javascript blobs.&lt;/p&gt;
&lt;p&gt;Fay seemed like just a &lt;em&gt;weaker&lt;/em&gt; GHCJS to me, but in all the ways that mattered. It doesn’t have all of the awesome GHC things that make modern Haskell what it is (not just the lack of base’s identical API, but also … no typeclasses? Lens abstractions? Hackage libraries?), so almost all of my normal Haskell programming flow is thrown out the window. It’s a subset of Haskell, but lacks most of the tools people use to write &lt;em&gt;actual&lt;/em&gt; Haskell like they’d write everyday. The generated javascript blobs are still decently opaque.&lt;/p&gt;
&lt;p&gt;So, if you’re going to be spending your time writing something that is like Haskell, but forces you to write it in a way that is nothing like any actual Haskell code you’d normally write… why even bother keeping up with Haskell semantics and Haskell compatibility? Why not break out and try something new and fresh, unbound by Haskell and compatibility issues?&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;on-purescript&quot;&gt;on Purescript&lt;/h3&gt;
&lt;p&gt;With that mindset, I looked at &lt;em&gt;&lt;a href=&quot;http://www.purescript.org/&quot;&gt;purescript&lt;/a&gt;&lt;/em&gt;, which is a language that’s inspired by Haskell, with a lot of Haskell features we use every day, and throws in things we all wish we had in Haskell, like extensible records!&lt;/p&gt;
&lt;p&gt;(Note — I &lt;em&gt;did&lt;/em&gt; rewrite all of my fay in GHCJS at first. This resulted in a javascript blob that was &lt;em&gt;1.4 MB&lt;/em&gt; in size for just a bunch of small DOM manipulation scripts. Definitely not practical, unfortunately!)&lt;/p&gt;
&lt;p&gt;I liked that purescript was able to throw away a lot of warts in the Haskell ecosystem, with a cleaner typeclass hierarchy and just a lot of design decisions “done right”, that we’d all change in Haskell if we could. And extensible records being built into the language is quite refreshing; not having to deal with fancy GADT’s in Haskell was a nice step back from the craziness that is type-level programming in Haskell. Alongside all of that, I was also able to rely and seamlessly use a lot of Haskell idioms that we all know and love, like lenses and traversals and compositions.&lt;/p&gt;
&lt;p&gt;At many moments, I felt like writing in Purescript felt like writing in &lt;em&gt;the language that Haskell should have been&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;But one of my favorite aspects about purescript ended up being the sheer beauty and conciseness of the generated javascript. Look at how&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&quot;purescript&quot;&gt;&lt;code&gt;appendTopLinks doc = do
    hs &amp;lt;- querySelectorAll headers (documentToParentNode doc)
    flip traverseNodeList_ hs \h -&amp;gt; do
      topLink &amp;lt;- createElement &amp;quot;a&amp;quot; doc
      let topLinkNode = elementToNode topLink
      setAttribute &amp;quot;href&amp;quot; &amp;quot;#title&amp;quot; topLink
      setClassName &amp;quot;top-link&amp;quot; topLink
      setTextContent &amp;quot;top&amp;quot; topLinkNode
      appendChild topLinkNode (elementToNode h)
      return unit&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gets translated to:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode javascript&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; appendTopLinks &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (doc) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;__do&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; v &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;querySelectorAll&lt;/span&gt;(headers)(&lt;span class=&quot;at&quot;&gt;documentToParentNode&lt;/span&gt;(doc))()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;flip&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;traverseNodeList_&lt;/span&gt;(monadEffEff))(v)(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (h) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;__do&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; v1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;createElement&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;)(doc)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; topLinkNode &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;elementToNode&lt;/span&gt;(v1)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;at&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;href&amp;quot;&lt;/span&gt;)(&lt;span class=&quot;st&quot;&gt;&amp;quot;#title&amp;quot;&lt;/span&gt;)(v1)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;at&quot;&gt;setClassName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;top-link&amp;quot;&lt;/span&gt;)(v1)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;at&quot;&gt;setTextContent&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;top&amp;quot;&lt;/span&gt;)(topLinkNode)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;at&quot;&gt;appendChild&lt;/span&gt;(topLinkNode)(&lt;span class=&quot;at&quot;&gt;elementToNode&lt;/span&gt;(h))()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; unit&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And it’s not just the IO-based imperative code that looks nice, either. Everything gets compiled to clean, readable javascript that you’d be happy to import in your node/normal javascript project.&lt;/p&gt;
&lt;p&gt;The total exported javascript blob is only &lt;em&gt;88 kB&lt;/em&gt;, even smaller than fay’s &lt;em&gt;100 kB&lt;/em&gt; output (but not significantly so), and much smaller than GHCJS’s &lt;em&gt;1.4 MB&lt;/em&gt;&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; output (which, to be fair, has to also contain the entire Haskell runtime, implementing Haskell semantics, as well).&lt;/p&gt;
&lt;p&gt;Interestingly enough, the &lt;em&gt;original&lt;/em&gt; raw javacript I wrote in 2013 came out to about the same size, about &lt;em&gt;80 kB&lt;/em&gt;. (Well, it is about &lt;em&gt;2 kB&lt;/em&gt; of actual script, but it utilized all of &lt;em&gt;jquery&lt;/em&gt;, which implements a lot of the functionality.) Getting comparable filesizes to jquery bundles is something that’s pretty impressive to me!&lt;/p&gt;
&lt;p&gt;I’d recommend purescript to anyone who has to write simple javascript &lt;em&gt;scripts&lt;/em&gt; and wants to do it in a sane, beautiful language. I still use &lt;em&gt;ghcjs&lt;/em&gt; for actual &lt;em&gt;applications&lt;/em&gt;, for now, because I still love Haskell and its ecosystem, along with the free data type sharing and code re-usage. But for small scripts like these, purescript might just be the ideal and perfect solution!&lt;/p&gt;
&lt;p&gt;You can check out &lt;a href=&quot;https://github.com/mstksg/inCode/blob/28f6a5da4c83356c4be87067ab88171879c68784/app-purescript/Entry.purs&quot;&gt;the actual purescript script&lt;/a&gt; on github!&lt;/p&gt;
&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;My main takeways —&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;I will never be able to never work on a Haskell project/application without &lt;em&gt;stack&lt;/em&gt; again (how did we even survive before &lt;em&gt;stack&lt;/em&gt;?)&lt;/li&gt;
&lt;li&gt;Hakyll is a fun little library that is a great specialized &lt;em&gt;make&lt;/em&gt; for building static websites&lt;/li&gt;
&lt;li&gt;Refactoring Haskell is an amazing experience; I would recommend it to anyone to try it out at least once in their lives&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Purescript&lt;/em&gt; is an amazing and beautiful technology that I had the pleasure of learning during this process, and generates elegant, readable javascript scripts.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This reflection post has been to help me organize my thoughts, but I hope they can be useful for those of you looking for new technologies to learn and ways to implement/approach your stack or next programming project, as well!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;I definitely don’t mean to bash on &lt;em&gt;fay&lt;/em&gt; here! It definitely has its role and place in the ecosystem. It’s for my specific application that I was looking for an alternative with.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;There’s another thing here that I skipped over slightly – &lt;a href=&quot;http://haste-lang.org/&quot;&gt;Haste&lt;/a&gt;. I haven’t had much experience with it myself, but for this purpose, I decided to jump into something not-Haskell and try out something new!&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;Unfortunately, &lt;em&gt;&lt;a href=&quot;https://github.com/jgm/highlighting-kate&quot;&gt;highlighting-kate&lt;/a&gt;&lt;/em&gt; doesn’t yet support purescript syntax highlighting?&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;A previous version of this post claimed that the javascript bundle was &lt;em&gt;140 MB&lt;/em&gt;, instead of &lt;em&gt;1.4 MB&lt;/em&gt;. My bad!&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Meta</category><guid isPermaLink="true">https://blog.jle.im/entry/blog-rewrite-with-hakyll-and-purescript.html</guid><pubDate>Fri, 25 Mar 2016 16:59:18 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Meta</dc:subject><dc:date>2016-03-25</dc:date></item><item><title>Introducing the “Prompt” library</title><link>https://blog.jle.im/entry/introducing-the-prompt-library.html</link><description>&lt;p&gt;&lt;strong&gt;Prompt&lt;/strong&gt;: &lt;a href=&quot;https://github.com/mstksg/prompt/blob/master/README.md&quot;&gt;README&lt;/a&gt; / &lt;a href=&quot;http://hackage.haskell.org/package/prompt&quot;&gt;hackage&lt;/a&gt; / &lt;a href=&quot;https://github.com/mstksg/prompt&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Have you ever wanted to specify a computation involving some limited form of IO — like querying a database, or asking stdio — but didn’t want a computation in the &lt;code&gt;IO&lt;/code&gt; monad, opening the entire can of worms that is arbitrary &lt;code&gt;IO&lt;/code&gt;? Have you ever looked at complicated &lt;code&gt;IO a&lt;/code&gt; you wrote last week at 4am and prayed that it didn’t launch missiles if you decided to execute it? Do you want to be able to run an effectful computation and explicitly &lt;em&gt;say&lt;/em&gt; what IO it can or cannot do?&lt;/p&gt;
&lt;p&gt;Introducing the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/prompt&quot;&gt;prompt&lt;/a&gt;&lt;/em&gt; library! It’s a small little lightweight library that allows you to specify and describe computations involving forms of effects where you “ask” with a value and receive a value in return (such as a database query, etc.), but not ever care about how the effects are fulfilled — freeing you from working directly with IO.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; fooBar ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
               ,&lt;span class=&quot;ot&quot;&gt; fooBaz ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
               } &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- ask with a String, receive a String as an answer&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;promptFoo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Prompt&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
promptFoo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; fmap length (prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;running&quot;&gt;Running&lt;/h2&gt;
&lt;p&gt;You can now “run it” in IO, by talking to stdio —&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runPromptM promptFoo &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \str &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; putStrLn str &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; getLine
bar                 &lt;span class=&quot;co&quot;&gt;-- stdout prompt&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;            &lt;span class=&quot;co&quot;&gt;-- stdin response typed in&lt;/span&gt;
baz                 &lt;span class=&quot;co&quot;&gt;-- stdout prompt&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; i am baz          &lt;span class=&quot;co&quot;&gt;-- stdin response typed in&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;-- result&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(this is also just &lt;code&gt;interactP promptFoo&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;Or you can maybe request it from the environment variables:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;System.Environment&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; setEnv &lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; setEnv &lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;i am baz&amp;quot;&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runPromptM promptFoo getEnv
&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or maybe you want to fulfill the prompts purely:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;import qualified&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Data.Map&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;M&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; testMap &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; M.fromList [(&lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt;), (&lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;i am baz&amp;quot;&lt;/span&gt;)]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runPrompt promptFoo (testMap &lt;span class=&quot;fu&quot;&gt;M.!&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With &lt;code&gt;Prompt&lt;/code&gt;, specify the computation and your logic &lt;em&gt;without involving any IO&lt;/em&gt;, so you can write safe code without arbitrary side effects. If you ever receive a &lt;code&gt;Prompt&lt;/code&gt;, you know it can’t wipe out your hard drive or do any IO other than exactly what you allow it to do! I’d feel more safe running a &lt;code&gt;Prompt a b r&lt;/code&gt; than an &lt;code&gt;IO r&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can also do some cute tricks; &lt;code&gt;Prompt a () r&lt;/code&gt; with a “prompt response function” like &lt;code&gt;putStrLn&lt;/code&gt; lets you do streaming logging, and defer &lt;em&gt;how&lt;/em&gt; the logging is done — to IO, to a list?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; logHelloWord &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mapM_ prompt [&lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt;]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runPromptM logHelloWorld putStrLn
hello
world
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; execWriter &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; runPromptM logHelloWorld tell
&lt;span class=&quot;st&quot;&gt;&amp;quot;helloworld&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Prompt () b r&lt;/code&gt; is like a fancy &lt;code&gt;ReaderT b m r&lt;/code&gt;, where you “defer” the choice of the Monad.&lt;/p&gt;
&lt;h2 id=&quot;combining-with-other-effects&quot;&gt;Combining with other effects&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Prompt&lt;/code&gt; can be used as an underlying “effects” source for libraries like &lt;em&gt;pipes&lt;/em&gt;, &lt;em&gt;conduit&lt;/em&gt;, and &lt;em&gt;auto&lt;/em&gt;. If your effects are only ever asking and prompting and receiving, there’s really no need to put the entire power of &lt;code&gt;IO&lt;/code&gt; underneath your DSL as an effects source. That’s just crazy!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Prompt&lt;/code&gt; can be used with monad transformers to give you safe underlying effect sources, like &lt;code&gt;StateT s (Prompt a b) r&lt;/code&gt;, which is a stateful computation which can sometimes sequence “prompty” effects. &lt;code&gt;Prompt&lt;/code&gt; is also itself a “Traversable transformer”, with &lt;code&gt;PrompT a b t r&lt;/code&gt;. It can perform computations in the context of a Traversable &lt;code&gt;t&lt;/code&gt;, to be able to incorporate built-in short-circuiting and logging, etc.&lt;/p&gt;
&lt;p&gt;This is all abstracted over with &lt;code&gt;MonadPrompt&lt;/code&gt;, &lt;code&gt;MonadError&lt;/code&gt;, &lt;code&gt;MonadPlus&lt;/code&gt;, etc., typeclasses —&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;promptFoo2 ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadPlus&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;MonadPrompt&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; m) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
promptFoo2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    bar &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;
    str &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; readMaybe str &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; baz &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; bar baz
        &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; mzero

&lt;span class=&quot;co&quot;&gt;-- more polymorphic&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;promptFoo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadPrompt&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
promptFoo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; fmap length (prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can run &lt;code&gt;promptFoo&lt;/code&gt; as a &lt;code&gt;MaybeT (Prompt String String) Foo&lt;/code&gt;, and manually unwrap:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; interactP &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; runMaybeT &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; promptFoo2
bar
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
baz
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; i am baz
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; interactP &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; runMaybeT &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; promptFoo2
bar
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
baz
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or you can run it as a &lt;code&gt;PromptT String String MaybeT Foo&lt;/code&gt;, to have &lt;code&gt;PromptT&lt;/code&gt; handle the wrapping/unwrapping itself:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; interactPT promptFoo2
bar
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
baz
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; i am baz
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; interactPT &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; promptFoo2 &lt;span class=&quot;fu&quot;&gt;&amp;lt;|&amp;gt;&lt;/span&gt; promptFoo
bar
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
baz
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; i am baz
bar                 &lt;span class=&quot;co&quot;&gt;-- failed to parse --- retrying with promptFoo!&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
baz
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; i am baz
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The previous example of &lt;code&gt;logHelloWorld&lt;/code&gt;?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runPromptT (&lt;span class=&quot;ot&quot;&gt;logHelloWorld ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; () (&lt;span class=&quot;dt&quot;&gt;Writer&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;) ()) tell
&lt;span class=&quot;st&quot;&gt;&amp;quot;helloworld&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;runners&quot;&gt;Runners&lt;/h2&gt;
&lt;p&gt;The “runners” are:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;interactP   ::&lt;/span&gt;                  &lt;span class=&quot;dt&quot;&gt;Prompt&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;   r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; r
&lt;span class=&quot;ot&quot;&gt;interactPT  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; t &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; t r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (t r)

&lt;span class=&quot;ot&quot;&gt;runPrompt   ::&lt;/span&gt;                  &lt;span class=&quot;dt&quot;&gt;Prompt&lt;/span&gt;  a b   r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;   b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r
&lt;span class=&quot;ot&quot;&gt;runPromptM  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Prompt&lt;/span&gt;  a b   r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m r

&lt;span class=&quot;ot&quot;&gt;runPromptT  ::&lt;/span&gt;                  &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; a b t r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;    t b)  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; t r
&lt;span class=&quot;ot&quot;&gt;runPromptTM ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; a b t r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (t b)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (t r)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;runPromptM&lt;/code&gt; and &lt;code&gt;runPromptTM&lt;/code&gt; can run in monads (like &lt;code&gt;IO&lt;/code&gt;) that are &lt;em&gt;completely unrelated&lt;/em&gt; to the &lt;code&gt;Prompt&lt;/code&gt; type itself. It sequences them all “after the fact”. It’s also interesting to note that &lt;code&gt;runPrompt&lt;/code&gt; is just a glorified &lt;code&gt;Reader (a -&amp;gt; b) r&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;runPromptTM&lt;/code&gt;, you can incorporate &lt;code&gt;t&lt;/code&gt; in your “prompt response” function, too. Which brings us to our grand finale – environment variable parsing!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad.Error.Class&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad.Prompt&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Text.Read&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import qualified&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Data.Map&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;M&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Val&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MENoParse&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Val&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MENotFound&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;promptRead ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;MonadPrompt&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Val&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;Read&lt;/span&gt; b)
           &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m b
&lt;span class=&quot;co&quot;&gt;-- promptRead :: Read b =&amp;gt; Key -&amp;gt; PromptT Key Val (Either MyError) b&lt;/span&gt;
promptRead k &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    resp &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; prompt k
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; readMaybe resp &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; throwError &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MEParse&lt;/span&gt; k resp
      &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; v  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; return v

&lt;span class=&quot;ot&quot;&gt;promptFoo3 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadPrompt&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Val&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- promptFoo3 :: Applicative t =&amp;gt; PromptT Key Val t Foo&lt;/span&gt;
promptFoo3 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; promptRead &lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- running!&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- Lookup environment variables, and &amp;quot;throw&amp;quot; an error if not found&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;throughEnv ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;)
throughEnv &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runPromptTM parseFoo3 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    env &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; lookupEnv k
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; env &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MENotFound&lt;/span&gt; k)
      &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; v  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; v

&lt;span class=&quot;co&quot;&gt;-- Fulfill the prompt through user input&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;throughStdIO ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;)
throughStdIO &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; interactPT parseFoo3

&lt;span class=&quot;co&quot;&gt;-- Fulfill the prompt through user input; count blank responses as &amp;quot;not found&amp;quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;throughStdIOBlankIsError ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;)
throughStdIOBlankIsError &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runPromptTM parseFoo3 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    putStrLn k
    resp &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getLine
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; null resp
      &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MENotFound&lt;/span&gt; k)
      &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; resp

&lt;span class=&quot;co&quot;&gt;-- Fulfill the prompt purely through a Map lookup&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;throughMap ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;M.Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Val&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
throughMap m &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runPromptT parseFoo3 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; M.lookup k m &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MENotFound&lt;/span&gt; k)
      &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; v  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; v&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hope you enjoy! Please feel free to leave a comment, find me on &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;twitter&lt;/a&gt;, leave an issue on the &lt;a href=&quot;https://github.com/mstksg/prompt&quot;&gt;github&lt;/a&gt;, etc. — and I’m usually on freenode’s &lt;em&gt;#haskell&lt;/em&gt; as &lt;em&gt;jle`&lt;/em&gt; if you have any questions!&lt;/p&gt;
&lt;h2 id=&quot;comparisons&quot;&gt;Comparisons&lt;/h2&gt;
&lt;p&gt;To lay it all on the floor,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; a b t r &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; runPromptTM ::&lt;/span&gt; forall m&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (t b)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (t r) }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There is admittedly a popular misconception that I’ve seen going around that equates this sort of type to &lt;code&gt;Free&lt;/code&gt; from the &lt;em&gt;free&lt;/em&gt; package. However, &lt;code&gt;Free&lt;/code&gt; doesn’t really have anything significant to do with this. Sure, you might be able to generate this type by using &lt;code&gt;FreeT&lt;/code&gt; over a specifically chosen Functor, but…this is the case for literally any Monad ever, so that doesn’t really mean much :)&lt;/p&gt;
&lt;p&gt;It’s also unrelated in this same manner to &lt;code&gt;Prompt&lt;/code&gt; from the &lt;em&gt;MonadPrompt&lt;/em&gt; package, and &lt;code&gt;Program&lt;/code&gt; from &lt;em&gt;operational&lt;/em&gt; too.&lt;/p&gt;
&lt;p&gt;One close relative to this type is &lt;code&gt;forall m. ReaderT (a -&amp;gt; m b) m r&lt;/code&gt;, where &lt;code&gt;prompt k = ReaderT ($ k)&lt;/code&gt;. This is more or less equivalent to &lt;code&gt;Prompt&lt;/code&gt;, but still can’t do the things that &lt;code&gt;PromptT&lt;/code&gt; can do without a special instance of Monad.&lt;/p&gt;
&lt;p&gt;This type is also similar in structure to &lt;code&gt;Bazaar&lt;/code&gt;, from the &lt;em&gt;lens&lt;/em&gt; package. The biggest difference that makes &lt;code&gt;Bazaar&lt;/code&gt; unusable is because the RankN constraint is only &lt;code&gt;Applicative&lt;/code&gt;, not &lt;code&gt;Monad&lt;/code&gt;, so a &lt;code&gt;Monad&lt;/code&gt; instance is impossible. Ignoring that (or if it’s okay for you to only use the &lt;code&gt;Applicative&lt;/code&gt; instance), &lt;code&gt;Bazaar&lt;/code&gt; forces the “prompting effect” to take place in the same context as the &lt;code&gt;Traversable&lt;/code&gt; &lt;code&gt;t&lt;/code&gt;…which really defeats the purpose of this whole thing in the first place (the idea is to be able to separate your prompting effect from your application logic). If the &lt;code&gt;Traversable&lt;/code&gt; you want to transform has a “monad transformer” version, then you can somewhat simulate &lt;code&gt;PromptT&lt;/code&gt; for that specifc &lt;code&gt;t&lt;/code&gt; with the transformer version.&lt;/p&gt;
&lt;p&gt;It’s also somewhat similar to the &lt;code&gt;Client&lt;/code&gt; type from &lt;em&gt;pipes&lt;/em&gt;, but it’s also a bit tricky to use that with a different effect type than the logic &lt;code&gt;Traversable&lt;/code&gt;, as well…so it has a lot of the same difference as &lt;code&gt;Bazaar&lt;/code&gt; here.&lt;/p&gt;
&lt;p&gt;But this type is common/simple enough that I’m sure someone has it somewhere in a library that I haven’t been able to find. If you find it, let me know!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Projects</category><guid isPermaLink="true">https://blog.jle.im/entry/introducing-the-prompt-library.html</guid><pubDate>Tue, 30 Jun 2015 17:42:11 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Projects</dc:subject><dc:date>2015-06-30</dc:date></item><item><title>Fixed-Length Vector Types in Haskell, 2015</title><link>https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html</link><description>&lt;p&gt;Fixed-length vector types (vector types that indicate the length of the vector in the type itself) are one of the more straightforward applications of the “super-Haskell” GHC type extensions. There’s a lot of magic you can do with GHC’s advanced type mechanisms, but I think fixed length vectors are a good first step to beginning to understand several extensions, including (potentially):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ConstraintKinds&lt;/li&gt;
&lt;li&gt;DataKinds&lt;/li&gt;
&lt;li&gt;GADTs&lt;/li&gt;
&lt;li&gt;KindSignatures&lt;/li&gt;
&lt;li&gt;TypeFamilies&lt;/li&gt;
&lt;li&gt;TypeOperators&lt;/li&gt;
&lt;li&gt;OverloadedLists&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And using type system plugins. (And of course the usual &lt;code&gt;UndecidableInstances&lt;/code&gt; etc.) We’ll be discussing two different ways to implement this — using type-level nats, and using the &lt;em&gt;GHC.TypeLits&lt;/em&gt; model to actually be able to use numeric literals in your types. These things are seen in the wild like with the popular &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/linear-1.18.0.1/docs/Linear-V.html&quot;&gt;linear&lt;/a&gt;&lt;/em&gt; package’s &lt;code&gt;V&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;There are a few great tutorials/writeups on this topic, but many of them are from the time before we had some of these extensions, or only discuss a few. I hope to provide a nice comprehensive look about the tools available today to really approach this topic. That being said, I am no expert myself, so I would appreciate any tips/edits/suggestions for things that I’ve missed or done not-the-best :) This post has a lot of open questions that I’m sure people who know more about this than me can answer.&lt;/p&gt;
&lt;p&gt;Most of the code in this article can be &lt;a href=&quot;https://github.com/mstksg/inCode/blob/master/code-samples/fixvec&quot;&gt;downloaded and tried out&lt;/a&gt;, so follow along if you want!&lt;/p&gt;
&lt;h2 id=&quot;the-idea&quot;&gt;The Idea&lt;/h2&gt;
&lt;p&gt;The basic idea is we’ll have a type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is a vector with items of type &lt;code&gt;a&lt;/code&gt;, whose length is somehow encoded in the &lt;code&gt;n&lt;/code&gt;. We’ll then discuss ways to do useful operations on this, as if it were a list.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; can really only be a certain “kind” of thing — a type that encodes a length. We can represent this by giving it a “kind signature”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which says that our &lt;code&gt;Vec&lt;/code&gt; type constructor takes two arguments: something of kind &lt;code&gt;Nat&lt;/code&gt; (so it can’t be any type…it has to be a type of kind &lt;code&gt;Nat&lt;/code&gt;), something of kind &lt;code&gt;*&lt;/code&gt; (the “normal” kind, of things that have values, like &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Maybe Bool&lt;/code&gt;, etc.), and returns something of kind &lt;code&gt;*&lt;/code&gt; (our vector itself).&lt;/p&gt;
&lt;h2 id=&quot;using-datakinds-for-type-level-nats&quot;&gt;Using DataKinds for Type-Level Nats&lt;/h2&gt;
&lt;p&gt;(The code in this section for this type is &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs&quot;&gt;available online&lt;/a&gt;, if you wanted to play along!)&lt;/p&gt;
&lt;p&gt;There are a couple of ways to find something for that &lt;code&gt;n&lt;/code&gt; &lt;code&gt;Nat&lt;/code&gt; kind, and one way is to use the simple inductive &lt;code&gt;Nat&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L26-27&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
         &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You might have seen this type before…it gives us value-level natural numbers, where &lt;code&gt;Z&lt;/code&gt; is zero, &lt;code&gt;S Z&lt;/code&gt; is one, &lt;code&gt;S (S Z)&lt;/code&gt; is two, &lt;code&gt;S (S (S Z))&lt;/code&gt; is three, etc. So if we had something of type &lt;code&gt;Nat&lt;/code&gt;, it could represent any natural number. This declaration gives you:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A type &lt;code&gt;Nat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A value constructor &lt;code&gt;Z :: Nat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A value constructor &lt;code&gt;S :: Nat -&amp;gt; Nat&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, with the &lt;em&gt;DataKinds&lt;/em&gt; extension, when you define this, you also define some extra fancy things. You also define a &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;Nat&lt;/code&gt;! More specifically, you get:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A kind &lt;code&gt;Nat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A type &lt;code&gt;Z :: Nat&lt;/code&gt; (&lt;code&gt;Z&lt;/code&gt;, of &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;Nat&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;A type constructor &lt;code&gt;S :: Nat -&amp;gt; Nat&lt;/code&gt; (&lt;code&gt;S&lt;/code&gt;, which takes something of kind &lt;code&gt;Nat&lt;/code&gt;, and returns a new thing of kind &lt;code&gt;Nat&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(Note that, to be principled, GHC would prefer us to use &lt;code&gt;&#39;Z&lt;/code&gt; and &lt;code&gt;&#39;S&lt;/code&gt; when we are referring to the &lt;em&gt;types&lt;/em&gt;, and this is how it’ll print them out in error messages. But we’re going to run with this for now…mostly for aesthetic reasons)&lt;/p&gt;
&lt;p&gt;We can check this out in GHCi:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;set &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XDataKinds&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So now we have a &lt;em&gt;type&lt;/em&gt; that can encode numbers. Something of type &lt;code&gt;Z&lt;/code&gt; represents zero…something of type &lt;code&gt;S Z&lt;/code&gt; represents 1…something of type &lt;code&gt;S (S Z)&lt;/code&gt; represents two.&lt;/p&gt;
&lt;p&gt;Note that you can’t ever have anything like &lt;code&gt;S Bool&lt;/code&gt;…that doesn’t work, because &lt;code&gt;Bool&lt;/code&gt; is of kind &lt;code&gt;*&lt;/code&gt;, but &lt;code&gt;S&lt;/code&gt; expects only &lt;code&gt;Nat&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;Now we can make our &lt;code&gt;Vec&lt;/code&gt; data type, with the &lt;em&gt;GADTs&lt;/em&gt; extension, or “generalized algebraic data types”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L37-44&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; a
&lt;span class=&quot;ot&quot;&gt;    (:#) ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n) a

&lt;span class=&quot;kw&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)
&lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you’ve never seen GADTs before, think of it as a way of declaring a type by giving the type of your constructors instead of just the normal boring form. It’s nothing too crazy…it’s basically like defining &lt;code&gt;Maybe&lt;/code&gt; as:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a
    &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;instead of&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In both cases, they create constructors of type &lt;code&gt;Nothing :: Maybe a&lt;/code&gt; and &lt;code&gt;Just :: a -&amp;gt; Maybe a&lt;/code&gt; anyway…so the GADT form just gives us a way to state it explicitly.&lt;/p&gt;
&lt;p&gt;Oh, we also used the &lt;em&gt;KindSignatures&lt;/em&gt; extension to be able to give a kind signature to &lt;code&gt;Vec&lt;/code&gt;…this is important because we want to make sure the first argument has to be a &lt;code&gt;Nat&lt;/code&gt;. That is, we can’t have anything silly like &lt;code&gt;Vec Bool Int&lt;/code&gt;. We also have to put a separate &lt;em&gt;StandaloneDeriving&lt;/em&gt;-extension standalone deriving clause instead of just having &lt;code&gt;deriving Show&lt;/code&gt; because &lt;code&gt;Vec&lt;/code&gt; isn’t a type that can be expressed in “normal Haskell”.&lt;/p&gt;
&lt;p&gt;Note that our type is basically like a list:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; []&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    []&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; [a]
&lt;span class=&quot;ot&quot;&gt;    (:) ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Except now our type constructor actually has a new &lt;code&gt;Nat&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This means that, because of type erasure, everything “runtime” on our new type is basically going to be identical to &lt;code&gt;[]&lt;/code&gt; (not considering compiler tricks). In-memory, this new type is essentially exactly &lt;code&gt;[]&lt;/code&gt;, but its type has an extra tag that is erased at compile-time.&lt;/p&gt;
&lt;p&gt;Okay, let’s define some useful methods:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L93-97&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;headV ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n) a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
headV (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; _)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x

&lt;span class=&quot;ot&quot;&gt;tailV ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n) a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a
tailV (_ &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ah, the classic &lt;code&gt;head&lt;/code&gt;/&lt;code&gt;tail&lt;/code&gt; duo from the days pre-dating Haskell. &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; are somewhat of a sore spot or wart in Haskell’s list API&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;, because they’re &lt;em&gt;partial functions&lt;/em&gt;. You tell people all about how Haskell is great because it can prevent run-time errors by ensuring completeness and having the type system enforce null-pointer checks…but then you go ahead and put unsafe functions that throw errors for empty lists anyways in Prelude.&lt;/p&gt;
&lt;p&gt;But here…this will never happen! We can only use &lt;code&gt;headV&lt;/code&gt; and &lt;code&gt;tailV&lt;/code&gt; on non-empty lists…it won’t typecheck for empty lists. Do you see why?&lt;/p&gt;
&lt;p&gt;It’s because all empty lists are of type &lt;code&gt;Vec Z a&lt;/code&gt;. But &lt;code&gt;headV&lt;/code&gt; and &lt;code&gt;tailV&lt;/code&gt; only take things of &lt;em&gt;type&lt;/em&gt; &lt;code&gt;Vec (S n) a&lt;/code&gt;, for any &lt;code&gt;Nat&lt;/code&gt; &lt;code&gt;n&lt;/code&gt;. So, if you ever try to use it on an empty list, it won’t even compile! No more pesky runtime bugs. &lt;code&gt;headV&lt;/code&gt; and &lt;code&gt;tailV&lt;/code&gt; are safe and will never crash at runtime!&lt;/p&gt;
&lt;p&gt;Note that the return type of &lt;code&gt;tailV&lt;/code&gt; is a vector of a length one less than the given vector. &lt;code&gt;tailV :: Vec (S Z) a -&amp;gt; Vec Z a&lt;/code&gt;, for instance…or &lt;code&gt;tailV :: Vec (S (S Z)) a -&amp;gt; Vec (S Z) a&lt;/code&gt;. Just like we want!&lt;/p&gt;
&lt;p&gt;If you tried implementing this yourself, you might notice that you actually get an &lt;em&gt;error&lt;/em&gt; from GHC if you even &lt;em&gt;try&lt;/em&gt; to handle the &lt;code&gt;Nil&lt;/code&gt; case for &lt;code&gt;tailV&lt;/code&gt; or &lt;code&gt;headV&lt;/code&gt;. GHC will know when you’ve handled all possible cases, and get mad at you if you try to handle a case that doesn’t even make sense!&lt;/p&gt;
&lt;h3 id=&quot;type-families-and-appending&quot;&gt;Type families and appending&lt;/h3&gt;
&lt;p&gt;We can also “append” vectors. But we need a way to add &lt;code&gt;Nat&lt;/code&gt;s together first. For that, we can use a type family, using the &lt;em&gt;TypeFamilies&lt;/em&gt; extension (with &lt;code&gt;TypeOperators&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L29-31&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; family (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;y ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;ch&quot;&gt;&amp;#39;Z   + y = y&lt;/span&gt;
    &lt;span class=&quot;ch&quot;&gt;&amp;#39;S x + y = &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A “type family” is like a type level function. Compare this to defining &lt;code&gt;(+)&lt;/code&gt; on the value level to the &lt;code&gt;Nat&lt;/code&gt; &lt;em&gt;data&lt;/em&gt; type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L33-35&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;(+#) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- types!&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;   &lt;span class=&quot;fu&quot;&gt;+#&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; y
&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+#&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;+#&lt;/span&gt; y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, we’re defining a new type-level function &lt;code&gt;(+)&lt;/code&gt; on two types &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, both of kind &lt;code&gt;Nat&lt;/code&gt;…and the result is their “sum”. Convince yourself that this “addition” is actually addition. Now, let’s use it for &lt;code&gt;appendV&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L99-101&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;appendV ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; m) a
appendV &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;       ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ys
appendV (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; appendV xs ys&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v1 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; v1 &lt;span class=&quot;ot&quot;&gt;`appendV`&lt;/span&gt; v2
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t v1 &lt;span class=&quot;ot&quot;&gt;`appendV`&lt;/span&gt; v2
v1 &lt;span class=&quot;ot&quot;&gt;`appendV` v2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;generating&quot;&gt;Generating&lt;/h3&gt;
&lt;p&gt;It’d be nice to have type-safe methods of &lt;em&gt;generating&lt;/em&gt; these things, too…functions like &lt;code&gt;iterate&lt;/code&gt;, or &lt;code&gt;enumFrom&lt;/code&gt;. One of the ways to do this is by using a typeclass. (Available in a &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs&quot;&gt;separate file&lt;/a&gt; to try out).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L7-8&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; v &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    unfold ::&lt;/span&gt; (b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a, b)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We’re going to call &lt;code&gt;v&lt;/code&gt; an &lt;code&gt;Unfoldable&lt;/code&gt; if you can build a &lt;code&gt;v&lt;/code&gt; from an “unfolding function” and an “initial state”. Run the function on the initial value and get the first item and a new state. Run the function on the new state and get the second item and the next state.&lt;/p&gt;
&lt;p&gt;The list instance should make it more clear:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L11-13&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; [] &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    unfold f x0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, x1) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x0
                  &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  y &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; unfold f x1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; take &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; unfold (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (x &lt;span class=&quot;ot&quot;&gt;`mod`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)) &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
[&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we can have an instance for any fixed-length vector type…where the thing “cuts off” after it’s filled the entire vector:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L46-51&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    unfold _ _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    unfold f x0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, x1) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x0
                  &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  y &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; unfold f x1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Take a moment to think about what these instances are doing.&lt;/p&gt;
&lt;p&gt;You can create a &lt;code&gt;Vec Z a&lt;/code&gt; from an unfolding function pretty easily, because the only thing with type &lt;code&gt;Vec Z a&lt;/code&gt; is &lt;code&gt;Nil&lt;/code&gt;. So just ignore the function/initial state and return &lt;code&gt;Nil&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The instance for &lt;code&gt;Vec (S n)&lt;/code&gt; is slightly more involved. To make a &lt;code&gt;Vec (S n) a&lt;/code&gt;, you need an &lt;code&gt;a&lt;/code&gt; and a &lt;code&gt;Vec n a&lt;/code&gt;. You can get the &lt;code&gt;a&lt;/code&gt; from the unfolding function…but where will you get the &lt;code&gt;Vec n a&lt;/code&gt; from? Well, you can use &lt;code&gt;unfold&lt;/code&gt; to make a &lt;code&gt;Vec n a&lt;/code&gt;! But that only makes sense if &lt;code&gt;Vec n&lt;/code&gt; is an &lt;code&gt;Unfoldable&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So, that’s why in the instance for &lt;code&gt;Vec (S n)&lt;/code&gt;, we constrain that &lt;code&gt;Vec n&lt;/code&gt; must also be an &lt;code&gt;Unfoldable&lt;/code&gt;. We make our result by using our function to create an &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;unfold&lt;/code&gt; to create a &lt;code&gt;Vec n a&lt;/code&gt; (provided &lt;code&gt;Vec n&lt;/code&gt; is an &lt;code&gt;Unfoldable&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Note that this style of declaration looks a lot like induction. We define our instance for zero…and then we say, “if &lt;code&gt;n&lt;/code&gt; is an instance, then so is &lt;code&gt;S n&lt;/code&gt;”. Induction!&lt;/p&gt;
&lt;p&gt;Let’s see this in action.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L15-24&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;replicateU ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; v &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v a
replicateU &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; unfold (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (x, x))

&lt;span class=&quot;ot&quot;&gt;iterateU ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; v &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v a
iterateU f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; unfold (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (x, f x))

&lt;span class=&quot;ot&quot;&gt;fromListMaybes ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; v &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a)
fromListMaybes &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; unfold &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \l &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; l &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                                  []   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, [])
                                  x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; x , xs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; replicateU &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;       ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; replicateU &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;       ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; iterateU succ &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;      ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListMaybes [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; tailV (iterateU succ &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;replicateU&lt;/code&gt; doesn’t need to take in an &lt;code&gt;Int&lt;/code&gt; parameter, like the on in Prelude, to say how many items to have. It just replicates enough to fill the entire vector we want!&lt;/p&gt;
&lt;h3 id=&quot;common-typeclasses&quot;&gt;Common Typeclasses&lt;/h3&gt;
&lt;p&gt;We can go in and implement common typeclasses, too. All the ones you’d expect.&lt;/p&gt;
&lt;p&gt;We can actually use the &lt;em&gt;DeriveFunctor&lt;/em&gt; extension to write a &lt;code&gt;Functor&lt;/code&gt; instance, but let’s write one on our own just for learning purposes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L53-55&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fmap _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
    fmap f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; fmap f xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For &lt;code&gt;Applicative&lt;/code&gt;, it isn’t so simple. The Applicative instance is going to be the “ZipList” instance…so we have to be able to make a &lt;code&gt;pure&lt;/code&gt; that depends on the type, and a &lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt; that depends on the type, too.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L57-63&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    pure _    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    pure x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; pure x
    (f &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; fs) &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; (fs &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; xs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For &lt;code&gt;Vec Z&lt;/code&gt;, it’s just &lt;code&gt;Nil&lt;/code&gt;. For &lt;code&gt;Vec (S n)&lt;/code&gt;…for pure, you need &lt;code&gt;x :#&lt;/code&gt; something…and that something has to be a &lt;code&gt;Vec n a&lt;/code&gt;. That’s just &lt;code&gt;pure&lt;/code&gt; for &lt;code&gt;Vec n&lt;/code&gt;! Remember, we can’t assume that &lt;code&gt;Vec n&lt;/code&gt; is an &lt;code&gt;Applicative&lt;/code&gt; just because &lt;code&gt;Vec (S n)&lt;/code&gt; is. So we need to add a constraint, that &lt;code&gt;Vec n&lt;/code&gt; an Applicative. Induction, again!&lt;/p&gt;
&lt;p&gt;For &lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt;, we can get the first item easily, it’s just &lt;code&gt;f x&lt;/code&gt;. But for the next item, we need a &lt;code&gt;Vec n a&lt;/code&gt;. Luckily…we have exactly that with the &lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt; for &lt;code&gt;Vec n&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;Remember, at the end, we’re saying “We have an &lt;code&gt;Applicative&lt;/code&gt; instance for &lt;em&gt;any&lt;/em&gt; type &lt;code&gt;Vec n&lt;/code&gt;”. The instance for &lt;code&gt;Vec Z&lt;/code&gt; has &lt;code&gt;pure _ = Nil&lt;/code&gt;. The instance for &lt;code&gt;Vec (S Z)&lt;/code&gt; has &lt;code&gt;pure x = x :# Nil&lt;/code&gt;. The instance for &lt;code&gt;Vec (S (S Z))&lt;/code&gt; has &lt;code&gt;pure x = x :# x :# Nil&lt;/code&gt;, etc. etc.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fmap (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; pure &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;         &lt;span class=&quot;co&quot;&gt;-- like replicateV!&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; liftA2 (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;) (&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;302&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;101&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;203&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;305&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I’ll leave the &lt;code&gt;Monad&lt;/code&gt; instance as an exercise, but it’s in the source files for this post. &lt;code&gt;join&lt;/code&gt; for this instance should be a “diagonal” — the first item of the first vector, the second item of the second vector, the third item of the third vector, etc.&lt;/p&gt;
&lt;p&gt;We can define &lt;code&gt;Foldable&lt;/code&gt; and &lt;code&gt;Traversable&lt;/code&gt; the same way. Like for &lt;code&gt;Functor&lt;/code&gt;, GHC can derive these with &lt;em&gt;DeriveFoldable&lt;/em&gt; and &lt;em&gt;DeriveTraversable&lt;/em&gt;…but we’ll do it again here just to demonstrate.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L65-75&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    foldMap _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mempty

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    foldMap f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; foldMap f xs

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    traverse _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; pure &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    traverse f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftA2 (&lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt;) (f x) (traverse f xs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we can only use &lt;code&gt;foldMap f xs&lt;/code&gt; on &lt;code&gt;xs :: Vec n a&lt;/code&gt;, if &lt;code&gt;Vec n&lt;/code&gt; is a &lt;code&gt;Foldable&lt;/code&gt;. So that’s why we add that constraint.&lt;/p&gt;
&lt;p&gt;Again, &lt;code&gt;liftA2 (:#) :: Applicative f =&amp;gt; f a -&amp;gt; f (Vec n a) -&amp;gt; f (Vec (S n) a)&lt;/code&gt;…so this only makes sense if &lt;code&gt;traverse f s&lt;/code&gt; gives us a &lt;code&gt;Vec n a&lt;/code&gt;. So we have to add that as a constraint.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; toList &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; traverse &lt;span class=&quot;dt&quot;&gt;Identity&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Identity&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; sequence_ &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; sequence &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; sequence &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Traversable&lt;/code&gt; of course opens a whole lot of doors. For example, we can write a “safe &lt;code&gt;fromList&lt;/code&gt;”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L26-27&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;fromListU ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; v, &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; v) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (v a)
fromListU &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sequence &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromListMaybes&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListU [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListU [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListU [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And, if you’re on GHC 7.8+, you have access to the &lt;em&gt;OverloadedLists&lt;/em&gt; language extension, where you can interpret list literals as if they were other structures.&lt;/p&gt;
&lt;p&gt;We’ve already already implemented both &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;toList&lt;/code&gt;, in a way, already, so this should be a breeze. The only trick you might see is that the &lt;code&gt;IsList&lt;/code&gt; typeclass asks for a type family to return the &lt;em&gt;type of the element in the container&lt;/em&gt; from the container type.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L86-91&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n), &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n)) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;L.IsList&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Item&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; a
    fromList xs &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; fromListU xs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; error &lt;span class=&quot;st&quot;&gt;&amp;quot;Demanded vector from a list that was too short.&amp;quot;&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; ys &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; ys
    toList      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; Data.Foldable.toList&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;set &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XOverloadedLists&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demanded&lt;/span&gt; vector from a list that was too short&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat! All of the benefits of list literals that &lt;em&gt;OverloadedLists&lt;/em&gt; offers is now available to us.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; Unfortunately, you now open yourself up to runtime errors, so…it’s actually a really bad idea for safety purposes unless you stick to only using it with infinite lists or are very disciplined. (Unless you really want to use list syntax, &lt;code&gt;fromListU&lt;/code&gt; is probably a safer choice for finite lists!)&lt;/p&gt;
&lt;h3 id=&quot;indexing&quot;&gt;Indexing&lt;/h3&gt;
&lt;p&gt;It’d be nice to be able to index into these, of course. For type-safe indexing, we can take advantage of a trick using the &lt;code&gt;Proxy&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;Many might remember having to get a &lt;code&gt;TypeRep&lt;/code&gt; for a &lt;code&gt;Typeable&lt;/code&gt; instance by doing something like &lt;code&gt;typeOf (undefined :: IO Double)&lt;/code&gt;. That’s because &lt;code&gt;typeOf :: Typeable a =&amp;gt; a -&amp;gt; TypeRep&lt;/code&gt;. If you wanted to get the &lt;code&gt;typeRep&lt;/code&gt; for an &lt;code&gt;IO Double&lt;/code&gt; using &lt;code&gt;typeOf&lt;/code&gt;, you have to pass in an &lt;code&gt;IO Double&lt;/code&gt;. But if you don’t have one at hand, you can just use &lt;code&gt;undefined&lt;/code&gt; with a type annotation. It’s a bit of a dirty hack, but it works because &lt;code&gt;typeOf&lt;/code&gt; doesn’t care about the first argument’s value…just its type.&lt;/p&gt;
&lt;p&gt;These days, we like to be a bit less embarrassing and use something called &lt;code&gt;Proxy&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Proxy a&lt;/code&gt; is a bit like &lt;code&gt;()&lt;/code&gt;. It only has one constructor, and doesn’t take any arguments. But we can use the type signature to “pass in types” to functions, as “arguments”.&lt;/p&gt;
&lt;p&gt;We have a couple of options here. One is to make a typeclass for type level nats to turn them into an &lt;code&gt;Integer&lt;/code&gt; or a value-level &lt;code&gt;Nat&lt;/code&gt;, and then do an “unsafe indexing” after verifying, through types, that the index is smaller than the length.&lt;/p&gt;
&lt;p&gt;However, this is a little bit silly because we’re just doing an unsafe indexing in the end anyway, so the compiler can’t help us at all. Wouldn’t it be nice if we could get the compiler on our side and write a &lt;em&gt;real&lt;/em&gt; safe index?&lt;/p&gt;
&lt;p&gt;There are many ways to approach this problem, but one way is to make a specific &lt;code&gt;Index&lt;/code&gt; typeclass: (or make another typeclass like &lt;code&gt;Take&lt;/code&gt;, and write &lt;code&gt;index&lt;/code&gt; in terms of it)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L77-78&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;n ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;) v &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    index ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, we can say that &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are instances of &lt;code&gt;Index n v&lt;/code&gt; if and only if you can safely (totally) index into &lt;code&gt;v a&lt;/code&gt; at index &lt;code&gt;n&lt;/code&gt;. That is, if every value of type &lt;code&gt;v a&lt;/code&gt; ever has an index at &lt;code&gt;n&lt;/code&gt;, a &lt;code&gt;Nat&lt;/code&gt;. (By the way, we need &lt;em&gt;MultiParamTypeClasses&lt;/em&gt; to be able to make a type class with two parameters)&lt;/p&gt;
&lt;p&gt;So, &lt;code&gt;n ~ S Z&lt;/code&gt; and &lt;code&gt;v ~ Vec (S (S Z)) a&lt;/code&gt; has an instance, because you can get the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n%20%3D%201&quot; alt=&quot;n = 1&quot; title=&quot;n = 1&quot; /&gt; element (the second element) from &lt;em&gt;any&lt;/em&gt; value of type &lt;code&gt;Vec (S (S Z)) a&lt;/code&gt; (a length-two vector).&lt;/p&gt;
&lt;p&gt;But &lt;code&gt;n ~ S Z&lt;/code&gt; and &lt;code&gt;v ~ Vec (S Z) a&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt;. There are actually &lt;em&gt;no&lt;/em&gt; length-1 vectors that have a &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?1&quot; alt=&quot;1&quot; title=&quot;1&quot; /&gt; index (second element).&lt;/p&gt;
&lt;p&gt;Note that we use the &lt;code&gt;Proxy&lt;/code&gt; trick we discussed, so that we can indicate somehow what index we really want. It is a trick that basically allows us to pass a &lt;em&gt;type&lt;/em&gt; (&lt;code&gt;S Z&lt;/code&gt;, &lt;code&gt;S (S Z)&lt;/code&gt;, etc.) as a “value”.&lt;/p&gt;
&lt;p&gt;Let’s write our instances — but only the instances that &lt;em&gt;make sense&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L80-84&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    index _ (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; _) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; forall n m&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; n (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n) (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; m)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    index _ (_ &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n) xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first case instance makes sense. We can definitely index at index &lt;code&gt;Z&lt;/code&gt; (zero) of &lt;em&gt;any&lt;/em&gt; &lt;code&gt;Vec (S n) a&lt;/code&gt; — the only thing we can’t index &lt;code&gt;Z&lt;/code&gt; into is &lt;code&gt;Vec Z a&lt;/code&gt;. So, if our vector is of length 1 or higher, we can index at position 0.&lt;/p&gt;
&lt;p&gt;The second case says that, if we can index into &lt;code&gt;n&lt;/code&gt; of a &lt;code&gt;Vec m a&lt;/code&gt;, then of course we can index into an &lt;code&gt;S n&lt;/code&gt; of a &lt;code&gt;Vec (S m) a&lt;/code&gt;. To index into &lt;code&gt;S n&lt;/code&gt; of a &lt;code&gt;Vec (S m) a&lt;/code&gt;, all we need to do is index into &lt;code&gt;n&lt;/code&gt; of the &lt;code&gt;Vec m a&lt;/code&gt; tail!&lt;/p&gt;
&lt;p&gt;We have to use the &lt;em&gt;ScopedTypeVariables&lt;/em&gt; extension to enable us to use, with the &lt;code&gt;forall&lt;/code&gt; statement, the &lt;code&gt;n&lt;/code&gt; in our instance when we are writing our type for &lt;code&gt;Proxy&lt;/code&gt;. If we didn’t, the &lt;code&gt;n&lt;/code&gt; in &lt;code&gt;Proxy n&lt;/code&gt; in our &lt;code&gt;index&lt;/code&gt; definition would be considered unrelated by GHC to the &lt;code&gt;n&lt;/code&gt; in the instance statement, &lt;code&gt;Index (S n) (Vec (S m))&lt;/code&gt;. (This is the only reason we need the &lt;code&gt;forall&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;In any case, note the similarity of this algorithm to the actual indexing function on lists:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!!&lt;/span&gt; (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_ ) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x
n &lt;span class=&quot;fu&quot;&gt;!!&lt;/span&gt; (_&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;!!&lt;/span&gt; xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;trying it out…&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Compile&lt;/span&gt; error&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It’s an error, but remember, it’s a &lt;em&gt;compiler&lt;/em&gt; error, that happens before any code is ever even run! No more indexing errors at runtime! Kiss your days of hunting segfault errors in C goodbye!&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This is something I haven’t really been able to find a good answer too. But notice that we actually could have written a “bad” instance of the second instance of &lt;code&gt;Index&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n) (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; m)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    index _ (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; _) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And this compiles fine…but gives the wrong behavior, or at least the behavior we don’t want!&lt;/p&gt;
&lt;p&gt;Does anybody know a way to state the type of &lt;code&gt;Index&lt;/code&gt; or &lt;code&gt;index&lt;/code&gt; in a way that implementations like this are impossible?&lt;/p&gt;
&lt;p&gt;There’s a “fundamental” problem here, it seems, because we can’t really demand or specify anything by the return type, like we could in the other examples. In the other examples, we sort of restricted the implementation by choosing our return type carefully…but for here, it’s just &lt;code&gt;a&lt;/code&gt;. I’d love to hear if anyone has any thoughts on this.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;You might notice that it’s a bit of a plain to write &lt;code&gt;S (S (S (S Z)))&lt;/code&gt;, etc., especially for large numbers. And I wouldn’t even think about writing it for the hundreds.&lt;/p&gt;
&lt;p&gt;We’ll “fix” this in the next section. However, even before this, you actually can generate these “automatically” with template haskell, using techniques from &lt;a href=&quot;http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf&quot;&gt;Functional Pearls: Implicit Configurations&lt;/a&gt;, and the &lt;a href=&quot;http://hackage.haskell.org/package/linear-1.18.0.1/docs/Linear-V.html&quot;&gt;linear&lt;/a&gt; package does just this. (This path slipped my mind before I posted because I didn’t really consider template Haskell, and I think I’ll edit in a section here soon). With this in mind, I still don’t really consider Template Haskell an optimal or clean approach :)&lt;/p&gt;
&lt;h2 id=&quot;using-typelits-and-type-checker-plugins&quot;&gt;Using TypeLits and Type Checker Plugins&lt;/h2&gt;
&lt;p&gt;(This next section uses code that is &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs&quot;&gt;also available online&lt;/a&gt;, as well!)&lt;/p&gt;
&lt;p&gt;Using a custom &lt;code&gt;Nat&lt;/code&gt; kind and &lt;em&gt;DataKinds&lt;/em&gt; is nice and all, but it’s a bit of a hassle to express large numbers like 100, 1000, etc. However, as of GHC 7.8, we’ve had the ability to actually &lt;em&gt;use&lt;/em&gt; numeric (integer) literals in our types. Instead of writing &lt;code&gt;S (S Z)&lt;/code&gt;, we can write &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;GHC can’t yet quite work with that well by default. It has trouble proving statements about variables, like &lt;code&gt;(n + 1) ~ (1 + n)&lt;/code&gt; (that &lt;code&gt;n + 1&lt;/code&gt; is “the same as” &lt;code&gt;1 + n&lt;/code&gt;). Fortunately for us, since GHC 7.10, we have a way to “extend” the type checker with custom plugins that &lt;em&gt;can&lt;/em&gt; prove things like this for us. (Note that this &lt;code&gt;+&lt;/code&gt; is the one from &lt;code&gt;GHC.TypeLits&lt;/code&gt;…not the one we defined earlier.)&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/ghc-typelits-natnormalise&quot;&gt;ghc-typelits-natnormalise&lt;/a&gt;&lt;/em&gt; package is a package providing such a plugin. We can have GHC use it to extend its type checking by passing in &lt;code&gt;-fplugin GHC.TypeLits.Normalise&lt;/code&gt; when we execute our code, or by adding a pragma:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L14-14&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to the top of our file, along with our &lt;code&gt;LANGUAGE&lt;/code&gt; pragmas. (Assuming, of course, a GHC 7.10+)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;set &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XDataKinds&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XTypeOperators&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XTypeFamilies&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;GHC.TypeLits&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; ((n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;~&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; n)) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Compile&lt;/span&gt; error&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cannot&lt;/span&gt; match &lt;span class=&quot;ot&quot;&gt;`1 + n`&lt;/span&gt; with &lt;span class=&quot;ot&quot;&gt;`n + 1`&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;set &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;fplugin &lt;span class=&quot;dt&quot;&gt;GHC.TypeLits.Normalise&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; ((n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;~&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; n)) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n
&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- success!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GHC now uses the plugin to prove that the two are really equivalent.&lt;/p&gt;
&lt;p&gt;If you wanted to play along or try out the code samples, I recommend you use a sandbox:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# in directory of your choice&lt;/span&gt;
$ &lt;span class=&quot;ex&quot;&gt;cabal&lt;/span&gt; sandbox init
$ &lt;span class=&quot;ex&quot;&gt;cabal&lt;/span&gt; install ghc-typelits-natnormalise
$ &lt;span class=&quot;ex&quot;&gt;cabal&lt;/span&gt; exec bash
&lt;span class=&quot;co&quot;&gt;# now the package is in scope, when you use ghci or runghc&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With that in mind, let’s start restating everything in terms of &lt;em&gt;TypeLits&lt;/em&gt; and see what it gains us.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L33-40&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; a
&lt;span class=&quot;ot&quot;&gt;    (:#) ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a

&lt;span class=&quot;kw&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)
&lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A little nicer, right? &lt;code&gt;Nil&lt;/code&gt; is a &lt;code&gt;Vec 0 a&lt;/code&gt;, and &lt;code&gt;x :# xs&lt;/code&gt; is an element with a &lt;code&gt;Vec (n - 1) a&lt;/code&gt;, which overall is a &lt;code&gt;Vec n a&lt;/code&gt;. Let’s go over everything again to see how it’d look in the new regime. (Note that the kind of the type number literals is also called &lt;code&gt;Nat&lt;/code&gt;…unrelated to our &lt;code&gt;Nat&lt;/code&gt; we used before.)&lt;/p&gt;
&lt;h2 id=&quot;a-new-look&quot;&gt;A new look&lt;/h2&gt;
&lt;p&gt;First of all, we’re going to have to define &lt;em&gt;TypeLit&lt;/em&gt; comparison operators, as they aren’t built in in a useful way.&lt;/p&gt;
&lt;p&gt;We have the type family (remember those?) &lt;code&gt;CmpNat x y&lt;/code&gt;, which returns an &lt;code&gt;Ordering&lt;/code&gt; (&lt;code&gt;LT&lt;/code&gt;, &lt;code&gt;EQ&lt;/code&gt;, or &lt;code&gt;GT&lt;/code&gt;) type (of kind &lt;code&gt;Ordering&lt;/code&gt;, using &lt;em&gt;DataKinds&lt;/em&gt;…lifting a type and its value constructors to a kind and its types), which is provided and defined for us by GHC in &lt;code&gt;GHC.TypeLits&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So defining a &lt;code&gt;x &amp;gt; y&lt;/code&gt; constraint is pretty straightforward:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L31-31&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CmpNat&lt;/span&gt; x y &lt;span class=&quot;fu&quot;&gt;~&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;GT&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we need the &lt;em&gt;ConstraintKinds&lt;/em&gt; extension for this to work, as &lt;code&gt;1 &amp;gt; 2&lt;/code&gt; is now a &lt;em&gt;constraint&lt;/em&gt;, of kind &lt;code&gt;Constraint&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Given this, let’s do our favorite list functions, &lt;code&gt;headV&lt;/code&gt; and &lt;code&gt;tailV&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L89-93&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;headV ::&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
headV (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; _)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x

&lt;span class=&quot;ot&quot;&gt;tailV ::&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) a
tailV (_ &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Magnificent!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; headV (&lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; ())
&lt;span class=&quot;co&quot;&gt;-- Error!  Cannot unite &amp;#39;EQ with &amp;#39;GT&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat! The error, remember, is at &lt;em&gt;compile time&lt;/em&gt;, and not at runtime. If we ever tried to do an unsafe head, our code wouldn’t even &lt;em&gt;compile&lt;/em&gt;! The error message comes from the fact that we need &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n%20%3E%200&quot; alt=&quot;n &amp;gt; 0&quot; title=&quot;n &amp;gt; 0&quot; /&gt;, but we have &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n%20%3D%200&quot; alt=&quot;n = 0&quot; title=&quot;n = 0&quot; /&gt; instead. We have &lt;code&gt;EQ&lt;/code&gt;, but we need &lt;code&gt;GT&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There is one problem here, though — GHC gives us a warning for not pattern matching on &lt;code&gt;Nil&lt;/code&gt;. But, if we do try to pattern match on &lt;code&gt;Nil&lt;/code&gt;, we get a type error, like the same one we got when using our custom type nats. I think this is probably something that a plugin or sufficiently smart &lt;code&gt;CmpNat&lt;/code&gt; might be able to handle…but I’m not totally sure. Right now, the best thing I can think of is just to do a wildcard match, &lt;code&gt;headV _ = error &amp;quot;What?&amp;quot;&lt;/code&gt;, knowing that that case will never be reached if your program compiles successfully.&lt;/p&gt;
&lt;p&gt;Moving on, we see that we don’t even have to do any extra work to define our own type family &lt;code&gt;x + y&lt;/code&gt;…because &lt;code&gt;GHC.TypeLits&lt;/code&gt; already defines it for us! So, we can instantly write….&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L95-97&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;appendV ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; m) a
appendV &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;       ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ys
appendV (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; appendV xs ys&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v1 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; iterateU succ &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; v1 &lt;span class=&quot;ot&quot;&gt;`appendV`&lt;/span&gt; v2
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t v1 &lt;span class=&quot;ot&quot;&gt;`appendV` v2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
v1 &lt;span class=&quot;ot&quot;&gt;`appendV` v2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And our list generating typeclasses —&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L42-47&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    unfold _ _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)), n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    unfold f x0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, x1) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x0
                  &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  y &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; unfold f x1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The translation is pretty mechanical, but I think that this new formulation looks…really nice, and really powerful. “If you can build a list from &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n%20-%201&quot; alt=&quot;n - 1&quot; title=&quot;n - 1&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n%20%3E%200&quot; alt=&quot;n &amp;gt; 0&quot; title=&quot;n &amp;gt; 0&quot; /&gt;, then you can build a list for &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n&quot; alt=&quot;n&quot; title=&quot;n&quot; /&gt;!&lt;/p&gt;
&lt;p&gt;Note that because our definitions of &lt;code&gt;replicateU&lt;/code&gt;, &lt;code&gt;iterateU&lt;/code&gt;, and &lt;code&gt;fromListMaybes&lt;/code&gt; was polymorphic over all &lt;code&gt;Unfoldable&lt;/code&gt;, we can actually re-use them from before:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; iterateU succ &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; int
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; iterateU succ &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; replicateU &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The actual types are much nicer, too — we can write &lt;code&gt;Vec 10 Int&lt;/code&gt; instead of &lt;code&gt;Vec (S (S (S (S (S (S (S (S (S (S Z)))))))))) Int&lt;/code&gt; without resorting to template haskell.&lt;/p&gt;
&lt;p&gt;Going through all of our other typeclasses/functions and making the adjustments… (remembering that we can also derive &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt;, and &lt;code&gt;Foldable&lt;/code&gt; using GHC)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L49-87&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fmap _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
    fmap f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; fmap f xs

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    pure _    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)), n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    pure x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; pure x
    (f &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; fs) &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; (fs &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; xs)

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    foldMap _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mempty

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)), n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    foldMap f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; foldMap f xs

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    traverse _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; pure &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)), n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    traverse f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftA2 (&lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt;) (f x) (traverse f xs)

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;n ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;) v &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    index ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (m &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    index _ (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; _) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; forall n m&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (m &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)), n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, m &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; n (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    index _ (_ &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)) xs

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n), &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n)) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;L.IsList&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Item&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; a
    fromList xs &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; fromListU xs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; error &lt;span class=&quot;st&quot;&gt;&amp;quot;Demanded vector from a list that was too short.&amp;quot;&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; ys &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; ys
    toList      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; Data.Foldable.toList&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Remember, we use the &lt;code&gt;forall&lt;/code&gt; here with &lt;em&gt;ScopedTypeVariables&lt;/em&gt; to be able to say that the &lt;code&gt;n&lt;/code&gt; in the type signature is the same &lt;code&gt;n&lt;/code&gt; that is in the type of &lt;code&gt;Proxy&lt;/code&gt;)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListU [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListU [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Couldn&amp;#39;t&lt;/span&gt; match &lt;span class=&quot;ch&quot;&gt;&amp;#39;EQ with &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;GT&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;set &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XOverloadedLists&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demanded&lt;/span&gt; vector from a list that was too short&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I think, overall, this formulation gives a much nicer interface. Being able to just write &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?10&quot; alt=&quot;10&quot; title=&quot;10&quot; /&gt; is pretty powerful. The usage with &lt;em&gt;OverloadedLists&lt;/em&gt; is pretty clean, too, especially when you can do things like &lt;code&gt;[1,3..] :: Vec 10 Int&lt;/code&gt; and take full advantage of list syntax and succinct vector types. (Minding your runtime errors, of course)&lt;/p&gt;
&lt;p&gt;However, you do again get the problem that GHC is not able to do real completeness checking and asks for the &lt;code&gt;Nil&lt;/code&gt; cases still of everything…but adding a &lt;code&gt;Nil&lt;/code&gt; case will cause a type error. The only solution is to add a &lt;code&gt;_&lt;/code&gt; wildcard chase, but…again, this isn’t quite satisfactory.&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; If anybody has a way to get around this, I’d love to know :)&lt;/p&gt;
&lt;h2 id=&quot;alternative-underlying-representations&quot;&gt;Alternative Underlying Representations&lt;/h2&gt;
&lt;p&gt;Recall that our &lt;code&gt;Vec&lt;/code&gt; was basically identically the normal list type, with an extra field in the type. Due to type erasure, the two are represented exactly the same in memory. So we have &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?O%28n%29&quot; alt=&quot;O(n)&quot; title=&quot;O(n)&quot; /&gt; appends, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?O%28n%29&quot; alt=&quot;O(n)&quot; title=&quot;O(n)&quot; /&gt; indexing, etc. Our type is essentially equal to&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;VecList&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For this type, though, we’d need to use “smart constructors” and extractors instead of &lt;code&gt;1 :# 2 :# Nil&lt;/code&gt; etc.&lt;/p&gt;
&lt;p&gt;We could, however, chose a more efficient type, like &lt;code&gt;Vector&lt;/code&gt; from the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/vector-0.10.12.2/docs/Data-Vector.html#t:Vector&quot;&gt;vector&lt;/a&gt;&lt;/em&gt; package:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;VecVector&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And, if you made sure to wrap everything with smart constructors, you now have &lt;em&gt;type safe&lt;/em&gt; &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?O%281%29&quot; alt=&quot;O(1)&quot; title=&quot;O(1)&quot; /&gt; random indexing!&lt;/p&gt;
&lt;p&gt;(This is representation is similar to the one used by the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/linear-1.18.0.1/docs/Linear-V.html&quot;&gt;linear&lt;/a&gt;&lt;/em&gt; package.)&lt;/p&gt;
&lt;h2 id=&quot;more-operations&quot;&gt;More Operations&lt;/h2&gt;
&lt;p&gt;One really weird quirk with this is that many functions you’d normally write using pattern matching you’d now might start writing using typeclasses. One example would be our implementation of indexing, using an &lt;code&gt;IndexV&lt;/code&gt; typeclass.&lt;/p&gt;
&lt;p&gt;A bunch of one-shot typeclasses is sort of unideal, as typeclasses are sort of ugly and non-first-class. Ideally you’d only have a few typeclasses for as generic an interface as possible, and then be able to do everything from those. Sometimes this just isn’t practical. I did mention one way around it, which was to make a typeclass to “reify” or turn your type into actual data, and then manipulate your data in an “unsafe” way knowing that the type checker checked that the data matched.&lt;/p&gt;
&lt;p&gt;We’ll demonstrate with &lt;code&gt;SomeNat&lt;/code&gt; from &lt;code&gt;GHC.TypeLits&lt;/code&gt;, but you can also make our own for our inductive &lt;code&gt;Nat&lt;/code&gt; type we used in the first half, too.&lt;/p&gt;
&lt;p&gt;If we use our “wrapped &lt;code&gt;Vector&lt;/code&gt; approach”, we can just do:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a

index&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n, m &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
index p (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; v) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; v &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt; fromInteger (natVal p)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That is, &lt;code&gt;index&lt;/code&gt; internally uses &lt;code&gt;(!)&lt;/code&gt;, an unsafe operator…but only after we assure properly that it’s safe to use by stating &lt;code&gt;m &amp;gt; n&lt;/code&gt; in the constraint. We can be sure that GHC will catch any instance where someone tries to index into a &lt;code&gt;Vec m a&lt;/code&gt; whose &lt;code&gt;m&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; greater than the index desired.&lt;/p&gt;
&lt;p&gt;The rest is up to you, though — to prove that indexing into a number smaller than &lt;code&gt;m&lt;/code&gt; will always provide an answer. We have to make sure our smart constructors are okay and that &lt;code&gt;(!)&lt;/code&gt; behaves like we think it does.&lt;/p&gt;
&lt;h2 id=&quot;singletons&quot;&gt;Singletons&lt;/h2&gt;
&lt;p&gt;Another answer to these sort of ad-hoc typeclasses is to use techniques involving singletons. Going all into how to use singletons to work with these is an article on its own…luckily, this article has already been written as &lt;a href=&quot;https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell&quot;&gt;Part 1: Dependent Types in Haskell&lt;/a&gt; by Hiromi ISHII. A major advantage is that you replace typeclasses with type families and more parameterized types. You’ll have to work with an understanding of how singletons work, and accept using some template haskell to generate singleton types for your data types (or write them yourself!). But it’s a powerful way to bring something like dependent types into Haskell, and there’s already a lot of infrastructure of support on it on hackage and in the haskell dev ecosystem in general. I recommend looking at the linked article!&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Hopefully you’ll see that we are able to apply the full type-safety of the Haskell compiler to our programs regarding lists by encoding the length of the list in its type and limiting its operations by specifically typed functions and choice of instances. I also hope that you’ve been able to become familiar with seeing a lot of GHC’s basic type extensions in real applications :)&lt;/p&gt;
&lt;p&gt;Feel free to &lt;a href=&quot;https://github.com/mstksg/inCode/blob/master/code-samples/fixvec&quot;&gt;download and run&lt;/a&gt; any of the samples&lt;/p&gt;
&lt;p&gt;Please let me know if I got anything wrong, or if there are any techniques that I should mention here that are out and in the wild today :)&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Can we get them out of Prelude? Please? :)&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;By the way, the GHC wiki seems to claim that &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists#Length-indexedobservedVectors&quot;&gt;using &lt;em&gt;OverloadedLists&lt;/em&gt; this way is impossible&lt;/a&gt;. Anyone know what’s going on here? Did we move fast and break everything?&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;Interestingly enough, I think this is something where you could have the best of both situations with the Template Haskell method. But I’d hope for something that works on the beautiful TypeLits :’(&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Tutorials</category><category>Reference</category><guid isPermaLink="true">https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html</guid><pubDate>Tue,  5 May 2015 19:16:07 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Tutorials, Reference</dc:subject><dc:date>2015-05-05</dc:date></item><item><title>mtl is Not a Monad Transformer Library</title><link>https://blog.jle.im/entry/mtl-is-not-a-monad-transformer-library.html</link><description>&lt;p&gt;&lt;em&gt;mtl&lt;/em&gt; is not a monad transformer library — contrary to popular conception. I believe that this commonly spread myth is due in part to some rather peculiar branding choices (the name of the library) and in part to some historical accidents (&lt;em&gt;mtl&lt;/em&gt; was, in the distant and pre-historic past, indeed a monad transformer library).&lt;/p&gt;
&lt;p&gt;What is &lt;em&gt;mtl&lt;/em&gt;? It is a library of &lt;em&gt;interfaces&lt;/em&gt; you can provide to your own types, in the form of typeclasses. It abstracts over &lt;em&gt;different design patterns&lt;/em&gt; for different types, in the form of typeclasses. Just like Functor abstracts over “things that can be fmapped”. &lt;em&gt;mtl&lt;/em&gt; provides typeclasses abstracting over many useful patterns that many types satisfy — patterns involving different sorts of “effects”.&lt;/p&gt;
&lt;h2 id=&quot;the-patterns&quot;&gt;The Patterns&lt;/h2&gt;
&lt;h3 id=&quot;monaderror&quot;&gt;MonadError&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MonadError&lt;/code&gt; is a generic interface over things where you can throw “errors” of a specific type &lt;code&gt;e&lt;/code&gt;, and “catch” them. It offers two methods: &lt;code&gt;throwError :: e -&amp;gt; m a&lt;/code&gt;, and &lt;code&gt;catchError :: m a -&amp;gt; (e -&amp;gt; m a) -&amp;gt; m a&lt;/code&gt;, which does what you’d expect from an error monad.&lt;/p&gt;
&lt;p&gt;Now, we have a generic interface to work on &lt;em&gt;all specfic type error-throwing Monads&lt;/em&gt;. The &lt;code&gt;Either&lt;/code&gt; type comes to mind as an obvious candidate:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadError&lt;/span&gt; e (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; e) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    throwError &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt;
    catchError s f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; s &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                       &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; s
                       &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; e  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f e&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But there are definitely other instances possible. How about for &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;IOException&lt;/code&gt;s, in specific?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    throwError  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ioError
    catchErrror &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; catch     &lt;span class=&quot;co&quot;&gt;-- will not catch non-IOExceptions&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is great, because we can now write code &lt;em&gt;generic&lt;/em&gt; over &lt;em&gt;all&lt;/em&gt; specific-type error things!&lt;/p&gt;
&lt;h4 id=&quot;error-behaviorfor-free&quot;&gt;Error behavior…for free!&lt;/h4&gt;
&lt;p&gt;If we’re clever enough, we can actually imbue any arbitrary Monad &lt;code&gt;m&lt;/code&gt; with rudimentary, basic, “dumb” error handling by using the &lt;code&gt;ExceptT&lt;/code&gt; type. An &lt;code&gt;ExceptT e m&lt;/code&gt; behaves &lt;em&gt;just&lt;/em&gt; like our original Monad &lt;code&gt;m&lt;/code&gt; in every way…except now, we have access to rudmentary implementations of side-channels of &lt;code&gt;throwError&lt;/code&gt; and &lt;code&gt;catchError&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is pretty useful…to be able to add short-circuiting error behavior to any Monad we wanted. But remember, &lt;code&gt;ExceptT&lt;/code&gt; is not the “point” of &lt;code&gt;MonadError&lt;/code&gt;. It’s just one way to generate instances for free given a Monad. The real power of &lt;code&gt;MonadError&lt;/code&gt; is in the ability to write generically over many Monads with some sort of “error” behavior, like &lt;code&gt;Either&lt;/code&gt; or &lt;code&gt;IO&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;monadstate&quot;&gt;MonadState&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;MonadState s m&lt;/code&gt; is a Monad &lt;code&gt;m&lt;/code&gt; where, during in the context of &lt;code&gt;m&lt;/code&gt;, you have access to a global state of type &lt;code&gt;s&lt;/code&gt; that you can modify.&lt;/p&gt;
&lt;p&gt;You can “get” it with &lt;code&gt;get :: m s&lt;/code&gt;. You can modify it with &lt;code&gt;modify :: (s -&amp;gt; s) -&amp;gt; m ()&lt;/code&gt;. You can replace it with &lt;code&gt;put :: s -&amp;gt; m ()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are a lot of types that can offer this type of interface. You might have, for example, a type where “getting” the state comes from reading an &lt;code&gt;IORef&lt;/code&gt;, and “putting” it comes from writing to the &lt;code&gt;IORef&lt;/code&gt;. Or maybe the state can come from a a query to a database…where &lt;code&gt;get&lt;/code&gt; queries a database in IO, and &lt;code&gt;put&lt;/code&gt; writes to the database.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MonadState&lt;/code&gt;, as a typeclass, gives you the ability to &lt;em&gt;write generically over all Monads with state&lt;/em&gt;. You can now write generically over those database state things…or those IORef state things…or those web query things…or anything that cares to implement the interface!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MonadState&lt;/code&gt; says, “the functions and actions I write can work for &lt;em&gt;all&lt;/em&gt; Monads offering state I can modify!” An action of type &lt;code&gt;MonadState String m =&amp;gt; m Double&lt;/code&gt; can create a &lt;code&gt;Double&lt;/code&gt; from &lt;em&gt;any&lt;/em&gt; monad offering some sort of &lt;code&gt;String&lt;/code&gt; state.&lt;/p&gt;
&lt;h4 id=&quot;statefor-free&quot;&gt;State…for free!&lt;/h4&gt;
&lt;p&gt;Again, we can actually imbue any Monad &lt;code&gt;m&lt;/code&gt; with some very rudimentary, “dumb” stateful interface, using a type called &lt;code&gt;StateT&lt;/code&gt;. A &lt;code&gt;StateT s m&lt;/code&gt; behaves just like our monad &lt;code&gt;m&lt;/code&gt; (be it &lt;code&gt;IO&lt;/code&gt;, &lt;code&gt;Reader&lt;/code&gt;, &lt;code&gt;ST&lt;/code&gt;, &lt;code&gt;STM&lt;/code&gt;…), except now we have access to a rudimentary state getting-and-putting mechanism on a state of type &lt;code&gt;s&lt;/code&gt;, using a form of function composition. The implementation of the &lt;code&gt;StateT&lt;/code&gt; handles it under the hood.&lt;/p&gt;
&lt;p&gt;Obviously, being able to add a rudimentary stateful interface on top of any Monad is pretty useful. Very useful, in fact!&lt;/p&gt;
&lt;p&gt;But remember, this isn’t the &lt;em&gt;point&lt;/em&gt; of &lt;code&gt;MonadState&lt;/code&gt;. &lt;code&gt;MonadState&lt;/code&gt; doesn’t exist for &lt;code&gt;StateT&lt;/code&gt;. &lt;code&gt;StateT&lt;/code&gt; is just a way to generate a free instance of &lt;code&gt;MonadState&lt;/code&gt; if you just want to add rudimentary statefulness to an existing Monad. But there are many instances of &lt;code&gt;MonadState&lt;/code&gt;…really, &lt;code&gt;MonadState&lt;/code&gt; has nothing to do with &lt;code&gt;StateT&lt;/code&gt; fundamentally, any more than &lt;code&gt;Monad&lt;/code&gt; has to do with &lt;code&gt;Maybe&lt;/code&gt; fundamentally. And &lt;code&gt;MonadState&lt;/code&gt; and &lt;code&gt;StateT&lt;/code&gt; don’t even come from the same library!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;mtl&lt;/em&gt; offers a generic interface for working with all monads offering a statey API.&lt;/p&gt;
&lt;h3 id=&quot;monadreader&quot;&gt;MonadReader&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MonadReader&lt;/code&gt; is more or less the same thing…it offers a generic interface to work on monads that have access to some sort of global, unchanging “environment”. An example might be a Monad where you could work with command line arguments, or environment variables, assuming they are read once and fixed when things start up. You could access the command line arguments with &lt;code&gt;ask&lt;/code&gt;, and use them in your program.&lt;/p&gt;
&lt;h3 id=&quot;monadio&quot;&gt;MonadIO&lt;/h3&gt;
&lt;p&gt;This one is actaully from &lt;em&gt;transformers&lt;/em&gt;, but it gives a nice picture. Any &lt;code&gt;MonadIO m&lt;/code&gt; is a &lt;code&gt;Monad&lt;/code&gt; that allows you to embed and sequence in any arbitrary IO action. This is pretty useful! In the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/persistent&quot;&gt;persistent&lt;/a&gt;&lt;/em&gt; database library, for example — the main “database access type monad” can sequence actions that access databases &lt;em&gt;and&lt;/em&gt; arbitrary IO actions, as well. A lot of resource managers and DSL’s offer the ability to sequence IO in the middle of all the other actions.&lt;/p&gt;
&lt;p&gt;That’s what &lt;code&gt;MonadIO&lt;/code&gt; is for — it allows you to write functions and say, “hey, my function is generic over &lt;em&gt;all&lt;/em&gt; things that can embed IO…anything that can embed IO can sequence my function/type”. The generic “embedding” action is &lt;code&gt;liftIO :: MonadIO m =&amp;gt; IO a -&amp;gt; m a&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You know…ideally, all of these typeclasses would have laws, so we could make conclusions and apply equational reasoning to generically written functions.&lt;/p&gt;
&lt;p&gt;Some of the laws are simple…&lt;code&gt;liftIO&lt;/code&gt; from &lt;code&gt;MonadIO&lt;/code&gt; should be a &lt;a href=&quot;http://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html&quot;&gt;monad morphism&lt;/a&gt;. But the rest of them don’t really have any well-established laws. This is a bit of a shame, because we’d really like to be able to apply reasoning to generic functions.&lt;/p&gt;
&lt;p&gt;People have suggested &lt;code&gt;MonadState&lt;/code&gt; have laws similar to how view/set/over interact in the &lt;em&gt;lens&lt;/em&gt; laws. But as of now, most of we have in terms of our capability of analyzing generic programs is rough heuristins/feelings about what “should” be right.&lt;/p&gt;
&lt;p&gt;A bit un-ideal, but…in practice, this ends up working not-so-badly :)&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;not-a-monad-transformer-library&quot;&gt;Not a Monad Transformer Library&lt;/h2&gt;
&lt;p&gt;So, let’s work together to dispel the myth that &lt;em&gt;mtl&lt;/em&gt; is a monad transformer library. It really has nothing to do with monad transformers at all…any more than &lt;code&gt;Control.Monad&lt;/code&gt; is an “IO module”, or &lt;code&gt;Control.Monoid&lt;/code&gt; is a “list module”. Transformers don’t even come from the &lt;em&gt;mtl&lt;/em&gt; library!&lt;/p&gt;
&lt;p&gt;Together, we can overcome this myth. We can show people that we can live in a world where we can combine effects, work generically in Monads with &lt;em&gt;multiple types of effects&lt;/em&gt; by writing functions generic over many different &lt;em&gt;mtl&lt;/em&gt; typeclasses at once! (&lt;code&gt;MonadState&lt;/code&gt; + &lt;code&gt;MonadIO&lt;/code&gt;, maybe?)&lt;/p&gt;
&lt;p&gt;We don’t &lt;em&gt;have to&lt;/em&gt; reach for Monad transformers to work with combined effects. We can write our own combined effects monads and just write the instances…or we can write generically and not even care about what Monad we actually use in the end. We don’t have to teach people to be afraid of monad transformers as if they were the only way to get things done, and &lt;em&gt;mtl&lt;/em&gt; is tied to them like a ball and chain.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;mtl&lt;/em&gt; is not a Monad transformer library. How liberating!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">https://blog.jle.im/entry/mtl-is-not-a-monad-transformer-library.html</guid><pubDate>Mon, 18 May 2015 18:07:36 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings</dc:subject><dc:date>2015-05-18</dc:date></item><item><title>Auto: A Todo GUI application with Auto (on GHCJS, etc.)</title><link>https://blog.jle.im/entry/auto-a-todo-gui-application-with-auto-on.html</link><description>&lt;p&gt;Continuing along with &lt;a href=&quot;http://blog.jle.im/entries/series/+all-about-auto&quot;&gt;All About Auto&lt;/a&gt;, let’s look at another exciting and useful application of the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/auto&quot;&gt;auto&lt;/a&gt;&lt;/em&gt; library: GUI’s. We’re going to look at the canonical “hello world” of GUI apps these days — the todo app. We’re going to be using the specs of &lt;a href=&quot;http://todomvc.com/&quot;&gt;todoMVC&lt;/a&gt; to build a todoMVC “candidate” that follows the specs…and along the way see what &lt;em&gt;auto&lt;/em&gt; offers in its tools of managing isolated state components and modeling GUI logic. We’re really going to be focusing on application logic — “control” and “model” — and not looking too close on “views”, which &lt;em&gt;auto&lt;/em&gt; doesn’t quite try to offer and where you can really pick your own view rendering system, making this adaptable to really any platform — javascript/web, desktop, command line, etc.&lt;/p&gt;
&lt;p&gt;A live version of our end-product &lt;a href=&quot;https://mstksg.github.com/auto-examples/todo&quot;&gt;is hosted and online&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This post does assume &lt;em&gt;some&lt;/em&gt; concepts from the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;tutorial&lt;/a&gt;…if not all, then at least those in the &lt;a href=&quot;http://blog.jle.im/entry/introducing-the-auto-library&quot;&gt;introductory post&lt;/a&gt; or the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/README.md&quot;&gt;README&lt;/a&gt;. If you ever find yourself thinking that these concepts are completely new and crazy, you might want to try looking through the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;tutorial&lt;/a&gt; or &lt;a href=&quot;http://hackage.haskell.org/package/auto&quot;&gt;docs&lt;/a&gt; to refresh your mind. As always, comments are welcome, and I’m also usually on &lt;em&gt;#haskell-auto&lt;/em&gt; as &lt;em&gt;jle`&lt;/em&gt;, and also on &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;twitter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(Fair warning…this is not quite a “ghcjs tutorial”, if that’s what you’re looking for; it’s an auto tutorial that uses some rudimentary ghcjs. Hopefully you can learn from that too!)&lt;/p&gt;
&lt;h2 id=&quot;overall-layout&quot;&gt;Overall Layout&lt;/h2&gt;
&lt;p&gt;At the highest level, &lt;em&gt;auto&lt;/em&gt; is a library that provides us tools to build and work with stream transformers on streams of values. Transform a stream of input values to a stream of output values. So, let’s try to phrase our Todo app problem in that perspective. What are our inputs, and what are our outputs?&lt;/p&gt;
&lt;p&gt;For a Todo app, the outputs are probably going to be a &lt;em&gt;todo list&lt;/em&gt; itself. If we’re building a GUI, then having the todo list itself is going to be enough to build our front-end display. The stream of &lt;em&gt;inputs&lt;/em&gt; is a little less obvious, but, well, what does an app really take as inputs? Commands! Our stream of inputs will be commands sent by a GUI or by whatever front-end we choose. Our todo app then is a transformer of a stream of commands to a stream of todo lists…where the todo list we get changes as we process more commands.&lt;/p&gt;
&lt;p&gt;So the “overall loop” will be:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;A front-end rendered by &lt;em&gt;ghcjs-dom&lt;/em&gt; (or whatever) with event handlers that drop commands into a concurrent &lt;code&gt;Chan&lt;/code&gt; queue. This just handles rendering.&lt;/li&gt;
&lt;li&gt;Our &lt;code&gt;Auto&lt;/code&gt; launched with &lt;code&gt;runOnChan&lt;/code&gt;, which waits on the &lt;code&gt;Chan&lt;/code&gt; queue, runs the inputs through the &lt;code&gt;Auto&lt;/code&gt;, and renders the result. This handles all of the logic.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We like types in Haskell, so let’s begin by laying out our types!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs#L19-46&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto.Collection&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad.Fix&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.IntMap&lt;/span&gt;             (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Serialize&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;GHC.Generics&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Prelude&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;hiding&lt;/span&gt;          ((.), id)
&lt;span class=&quot;kw&quot;&gt;import qualified&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Data.IntMap&lt;/span&gt;   &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IM&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IAdd&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- new task with description&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ITask&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskID&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- send command to task by ID&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IAll&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- send command to all tasks&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CDelete&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;-- delete&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CPrune&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- delete if completed&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CComplete&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- set completed status&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CModify&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- modify description&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CNop&lt;/span&gt;             &lt;span class=&quot;co&quot;&gt;-- do nothing&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; taskDescr     ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
                 ,&lt;span class=&quot;ot&quot;&gt; taskCompleted ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
                 } &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Generic&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Serialize&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- from Data.Serialize, from the cereal library&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We have a type to represent our inputs, &lt;code&gt;TodoInp&lt;/code&gt;, which can be an “add” command with a &lt;code&gt;String&lt;/code&gt;, a “task” command with a &lt;code&gt;TaskId&lt;/code&gt; (&lt;code&gt;Int&lt;/code&gt;) and a &lt;code&gt;TaskCmd&lt;/code&gt;, and an “all” command with a &lt;code&gt;TaskCmd&lt;/code&gt; that is supposed to represent sending that command to all tasks.&lt;/p&gt;
&lt;p&gt;Our &lt;code&gt;TaskCmd&lt;/code&gt; represents commands we can send to individual tasks – we can delete, prune (delete if completed), set the “completed” flag, or modify the description.&lt;/p&gt;
&lt;p&gt;We’re going to represent our task list, &lt;code&gt;TaskMap&lt;/code&gt;, as not a &lt;code&gt;[]&lt;/code&gt; list, but as an &lt;code&gt;IntMap&lt;/code&gt; from &lt;em&gt;containers&lt;/em&gt;, which associates an &lt;code&gt;Int&lt;/code&gt; to a &lt;code&gt;Task&lt;/code&gt; that we can look up with the &lt;code&gt;IntMap&lt;/code&gt; API. What would a &lt;code&gt;TaskMap&lt;/code&gt; store other than a bunch of &lt;code&gt;Task&lt;/code&gt;s, which we are defining as jus a tupling of a &lt;code&gt;String&lt;/code&gt; description and a &lt;code&gt;Bool&lt;/code&gt; completed/uncompleted status.&lt;/p&gt;
&lt;h2 id=&quot;the-todo-auto&quot;&gt;The Todo Auto&lt;/h2&gt;
&lt;p&gt;Time to go over the logic portion! The part that &lt;em&gt;auto&lt;/em&gt; is meant for! We’re going to structure the logic of our app (also known as the “model”) by using principles of local statefulness to avoid ever working with a “global state”, and working in a declarative, high-level manner.&lt;/p&gt;
&lt;h3 id=&quot;tasks&quot;&gt;Tasks&lt;/h3&gt;
&lt;p&gt;It’s clear that the core of our entire thing is going to be the “task list” construct itself…something that can dynamically add or remove tasks.&lt;/p&gt;
&lt;p&gt;In &lt;em&gt;auto&lt;/em&gt;, there is a construct created just for this kind of situation: dynamic collections indexed by a key (a “task id”), where you can add or subtract &lt;code&gt;Auto&lt;/code&gt;s from dynamically — they are &lt;code&gt;dynMap&lt;/code&gt; and &lt;code&gt;dynMapF&lt;/code&gt; from &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/auto/docs/Control-Auto-Collection.html&quot;&gt;Control.Auto.Collection&lt;/a&gt;&lt;/em&gt;. We’ll be using &lt;code&gt;dynMapF&lt;/code&gt; because it’s serializable, and we don’t need the extra power that &lt;code&gt;dynMap&lt;/code&gt; offers.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;dynMapF ::&lt;/span&gt; (k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Interval&lt;/span&gt; m a b)    &lt;span class=&quot;co&quot;&gt;-- ^ function to initialize new `Auto`s&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a                        &lt;span class=&quot;co&quot;&gt;-- ^ default inputs&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m ( &lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; a        &lt;span class=&quot;co&quot;&gt;-- ^ input for each internal `Auto`, indexed by key&lt;/span&gt;
                  , &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [k]        &lt;span class=&quot;co&quot;&gt;-- ^ blip stream to initialize new `Auto`s&lt;/span&gt;
                  )
                  (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; b)        &lt;span class=&quot;co&quot;&gt;-- ^ `Auto` outputs, by key&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;dynMapF&lt;/code&gt; keeps a “dynamic collection” of &lt;code&gt;Interval m a b&lt;/code&gt;s, indexed by an &lt;code&gt;Int&lt;/code&gt; key, or an “ID”. It takes as input a stream of &lt;code&gt;IntMap a&lt;/code&gt;…basically a bunch of &lt;code&gt;(Int, a)&lt;/code&gt; pairs. &lt;code&gt;dynMapF&lt;/code&gt; routes each input to the &lt;code&gt;Interval&lt;/code&gt; at that ID/address (with a suitable “default” &lt;code&gt;a&lt;/code&gt; if none was sent in), and then outputs all of the results as an &lt;code&gt;IntMap b&lt;/code&gt; — a bunch of &lt;code&gt;(Int, b)&lt;/code&gt; pairs, each output with the address of the &lt;code&gt;Auto&lt;/code&gt; that made it.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;IM.singleton 5 True&lt;/code&gt; would send &lt;code&gt;True&lt;/code&gt; to the &lt;code&gt;Auto&lt;/code&gt; stored at &lt;code&gt;5&lt;/code&gt;. It’ll then output something that includes &lt;code&gt;(5, &amp;quot;received True!&amp;quot;)&lt;/code&gt; — the output of the &lt;code&gt;Auto&lt;/code&gt; at slot 5.&lt;/p&gt;
&lt;p&gt;Whenever an &lt;code&gt;Interval&lt;/code&gt; turns “off” (is &lt;code&gt;Nothing&lt;/code&gt;), it is removed from the collection. In this way we can have &lt;code&gt;Auto&lt;/code&gt;s “remove themselves”.&lt;/p&gt;
&lt;p&gt;It also takes as input a blip stream of &lt;code&gt;[k]&lt;/code&gt;s. We use each emitted &lt;code&gt;k&lt;/code&gt; to “initialize a new &lt;code&gt;Interval&lt;/code&gt;” and throw it into the collection, creating a new unique key for it. Every time a new &lt;code&gt;Auto&lt;/code&gt; is initialized, &lt;code&gt;dynMapF&lt;/code&gt; creates a new key for it.&lt;/p&gt;
&lt;p&gt;Read over the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md#semantic-tools&quot;&gt;tutorial section on blip streams and &lt;code&gt;Interval&lt;/code&gt;s&lt;/a&gt; if you are still unfamiliar with them.&lt;/p&gt;
&lt;p&gt;This pretty much fits exactly what we want for our task collection. If we imagined that we had our &lt;code&gt;Task&lt;/code&gt; as an &lt;code&gt;Auto&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;initTask ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Interval&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;initTask&lt;/code&gt; takes a string (a starting description) and initializes an &lt;code&gt;Interval&lt;/code&gt; that takes in a stream of task commands, and has a stream of new, updated &lt;code&gt;Task&lt;/code&gt;s as its output stream. At every step, it processes the command and outputs the new appropriate &lt;code&gt;Task&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can then use this as our “initializer” for &lt;code&gt;dynMapF&lt;/code&gt;…and now we have a dynamic collection of tasks!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs#L48-50&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;taskCollection ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m
               &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;]) (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;)
taskCollection &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dynMapF initTask &lt;span class=&quot;dt&quot;&gt;CNop&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we wanted to send in the command &lt;code&gt;CModify &amp;quot;hey!&amp;quot;&lt;/code&gt; to the task whose id/key/address is &lt;code&gt;12&lt;/code&gt;, I’d feed in &lt;code&gt;IM.singleton 12 (CModify &amp;quot;hey!&amp;quot;)&lt;/code&gt;. The output would then contain the output of feeding that &lt;code&gt;CModify&lt;/code&gt; to the &lt;code&gt;Auto&lt;/code&gt; at that slot 12, associated with slot 12 on the output &lt;code&gt;IntMap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Writing &lt;code&gt;initTask&lt;/code&gt; and the task &lt;code&gt;Auto&lt;/code&gt; is straightforward with &lt;code&gt;accum&lt;/code&gt;, which is basically like &lt;code&gt;foldl&lt;/code&gt; on the inputs and a “current state”. (The current state is of course the &lt;code&gt;Task&lt;/code&gt;).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs#L52-62&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;initTask ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Interval&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;
initTask descr &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; accum f (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; descr &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;))
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    f (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t) tc &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; tc &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                      &lt;span class=&quot;dt&quot;&gt;CDelete&lt;/span&gt;                  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
                      &lt;span class=&quot;dt&quot;&gt;CPrune&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; taskCompleted t &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
                             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t
                      &lt;span class=&quot;dt&quot;&gt;CComplete&lt;/span&gt; s              &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t { taskCompleted &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; s }
                      &lt;span class=&quot;dt&quot;&gt;CModify&lt;/span&gt; descr            &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t { taskDescr &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; descr }
                      &lt;span class=&quot;dt&quot;&gt;CNop&lt;/span&gt;                     &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t
    f &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; _   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;See that our &lt;code&gt;Auto&lt;/code&gt; “turns off” by outputting &lt;code&gt;Nothing&lt;/code&gt;. That’s interval semantics, and it’s what &lt;code&gt;dynMapF&lt;/code&gt; relies on for its internal &lt;code&gt;Auto&lt;/code&gt;s!&lt;/p&gt;
&lt;h3 id=&quot;routing-the-inputs&quot;&gt;Routing the inputs&lt;/h3&gt;
&lt;p&gt;The only thing left, then, is just to route our input stream to send everything to the correct &lt;code&gt;Auto&lt;/code&gt; in &lt;code&gt;taskCollection&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Our input stream is going to be a stream of &lt;code&gt;TodoInp&lt;/code&gt;, which can be “add”, “send command to a single task”, or “send command to all tasks”. Really, though, you can think of it three separate streams all “jammed” into one stream.&lt;/p&gt;
&lt;p&gt;This is a common pattern that we can use &lt;em&gt;blip streams&lt;/em&gt; for. Instead of working with one big fatty stream, we can work with several blip streams that only emit when the input that we care about comes in.&lt;/p&gt;
&lt;p&gt;Typically, we’d do this with &lt;code&gt;emitJusts&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;emitJusts ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can imagine &lt;code&gt;emitJusts&lt;/code&gt; is a “siphon” off of the input stream of &lt;code&gt;a&lt;/code&gt;s…and pulling out only the values that we care about, as a blip stream of &lt;code&gt;b&lt;/code&gt;’s.&lt;/p&gt;
&lt;p&gt;We can build our “siphoners”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs#L95-105&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;getAddEvts ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;]
getAddEvts (&lt;span class=&quot;dt&quot;&gt;IAdd&lt;/span&gt; descr) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; [descr]
getAddEvts _            &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;getModEvts ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;)
getModEvts (&lt;span class=&quot;dt&quot;&gt;ITask&lt;/span&gt; n te) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; IM.singleton n te
getModEvts _            &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;getMassEvts ::&lt;/span&gt; ([&lt;span class=&quot;dt&quot;&gt;TaskID&lt;/span&gt;], &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;)
getMassEvts (allIds, &lt;span class=&quot;dt&quot;&gt;IAll&lt;/span&gt; te) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; IM.fromList (map (,te) allIds)
getMassEvts _                 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;getAddEvts&lt;/code&gt;, when used with &lt;code&gt;emitJusts&lt;/code&gt;, will siphon off all &lt;code&gt;IAdd&lt;/code&gt; commands as a blip stream of &lt;code&gt;[String]&lt;/code&gt;s, emitting descriptions of new tasks to add.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getModEvts&lt;/code&gt;, when used with &lt;code&gt;emitJusts&lt;/code&gt;, will siphon off all &lt;code&gt;ITask&lt;/code&gt; commands as a blip stream of &lt;code&gt;IntMap TaskCmd&lt;/code&gt;, which will be fed into &lt;code&gt;taskCollection&lt;/code&gt; and &lt;code&gt;dynMapF&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getMassEvts&lt;/code&gt; is pretty much the same thing…siphoning off all &lt;code&gt;IAll&lt;/code&gt; commands as a blip stream of &lt;code&gt;IntMap TaskCmd&lt;/code&gt;. It needs a list of all &lt;code&gt;TaskID&lt;/code&gt;s though, to do its job…because it needs to make an &lt;code&gt;IntMap&lt;/code&gt; targeting all of the current tasks.&lt;/p&gt;
&lt;p&gt;Remember, we interace with tasks through an &lt;code&gt;IntMap TaskCmd&lt;/code&gt;…which is a map of task id-task command pairs. The &lt;code&gt;TaskCmd&lt;/code&gt; stored at key &lt;code&gt;1&lt;/code&gt; will be the command we want to send to task id 1.&lt;/p&gt;
&lt;p&gt;Let’s see it all work together!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs#L64-93&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;todoApp ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadFix&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;)
todoApp &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc inpEvt &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;

    rec &lt;span class=&quot;co&quot;&gt;-- all id&amp;#39;s currently alive&lt;/span&gt;
        allIds &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; arrD IM.keys [] &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; taskMap

        &lt;span class=&quot;co&quot;&gt;-- &amp;quot;forking&amp;quot; `inpEvt` into three blip streams:&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- newTaskB :: Blip [String]&lt;/span&gt;
        newTaskB  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; emitJusts getAddEvts  &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inpEvt
        &lt;span class=&quot;co&quot;&gt;-- modTaskB :: Blip (IntMap TaskCmd)&lt;/span&gt;
        modTaskB  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; emitJusts getModEvts  &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inpEvt
        &lt;span class=&quot;co&quot;&gt;-- massTaskB :: Blip (IntMap TaskCmd)&lt;/span&gt;
        massTaskB &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; emitJusts getMassEvts &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (allIds, inpEvt)

        &lt;span class=&quot;co&quot;&gt;-- merge the two streams together to get &amp;quot;all&amp;quot; inputs, single and&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- mass.&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; allInpB ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;)
            allInpB &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; modTaskB &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; massTaskB

        &lt;span class=&quot;co&quot;&gt;-- from a blip stream to an `IntMap` stream that is empty when the&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- stream doesn&amp;#39;t emit&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- taskCommands :: IntMap TaskCmd&lt;/span&gt;
        taskCommands &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; fromBlips IM.empty &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; allInpB

        &lt;span class=&quot;co&quot;&gt;-- feed the commands and the new tasks to `taskMap`...the result is&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- the `IntMap` of tasks.&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- taskMap :: IntMap Task&lt;/span&gt;
        taskMap &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; taskCollection &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (taskCommands, newTaskB)

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; taskMap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To read the proc block, it does help to sort of see all of the lines as english statements of what things “are”.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;allIds&lt;/code&gt; is a list of keys (id’s) currently in the task map &lt;code&gt;taskMap&lt;/code&gt;. All of the id’s of the tasks currently alive.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now, we fork into blip streams:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;newTaskB&lt;/code&gt; is a blip stream that emits with task descriptions whenever &lt;code&gt;inpEvt&lt;/code&gt; calls for one.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modTaskB&lt;/code&gt; is a blip stream that emits with a command to a specific task whenever &lt;code&gt;inpEvt&lt;/code&gt; calls for one.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;massTaskB&lt;/code&gt; is a blip stream that emits commands to every single task in &lt;code&gt;allIds&lt;/code&gt; whenever &lt;code&gt;inpEvt&lt;/code&gt; calls for it.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;allInpB&lt;/code&gt; is a blip stream with addressed commands whenever either &lt;code&gt;modTaskB&lt;/code&gt; or &lt;code&gt;massTaskB&lt;/code&gt; emits.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;taskCommands&lt;/code&gt; is a map of addressed commands for each task. It’s whatever &lt;code&gt;allInpB&lt;/code&gt; emits, when it does emit…or just &lt;code&gt;IM.empty&lt;/code&gt; (an empty map) when it doesn’t.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;taskMap&lt;/code&gt; is the map of tasks that we get from our &lt;code&gt;taskCollection&lt;/code&gt; updater, which manages a collection of tasks. &lt;code&gt;taskCollection&lt;/code&gt; needs the commands for each task and the new tasks we want to do its job.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We state things as an interplay of streams. And in the end, the result is what we want — an indexed list of tasks.&lt;/p&gt;
&lt;p&gt;Note that we needed the &lt;code&gt;rec&lt;/code&gt; block because we referred to &lt;code&gt;taskMap&lt;/code&gt; at the beginning (to get &lt;code&gt;allIds&lt;/code&gt;), but we don’t define &lt;code&gt;taskMap&lt;/code&gt; until the end.&lt;/p&gt;
&lt;p&gt;Note that we use &lt;code&gt;arrD&lt;/code&gt; for &lt;code&gt;allIds&lt;/code&gt;. What we really “meant” was something like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;allIds &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; arr IM.keys &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; taskMap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But…this doesn’t really work out, because when the whole thing “starts”, we don’t know what &lt;code&gt;taskMap&lt;/code&gt; is. We need to know &lt;code&gt;massTaskB&lt;/code&gt; to know &lt;code&gt;taskMap&lt;/code&gt;, and we need to know &lt;code&gt;allIds&lt;/code&gt; to know &lt;code&gt;massTaskB&lt;/code&gt;, and…recursive dependency!&lt;/p&gt;
&lt;p&gt;We can use &lt;code&gt;arrD&lt;/code&gt; to specify an “initial output” to “close the loop” (in technical terms). We want &lt;code&gt;allIds&lt;/code&gt; to initially be &lt;code&gt;[]&lt;/code&gt; (we can assume we start with no task id’s), so instead of&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;allIds &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; arr IM.keys &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; taskMap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we have&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;allIds &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; arrD IM.keys [] &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; taskMap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where &lt;code&gt;[]&lt;/code&gt; is the “initial output”, so when we first try to do anything, we don’t need &lt;code&gt;taskMap&lt;/code&gt; — we just pop out &lt;code&gt;[]&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;This is just a small thing to worry about whenever you have recursive bindings. There is a small cognitive price to pay, but in return, you have something that really just looks like laying out relationships between different quantities :)&lt;/p&gt;
&lt;h2 id=&quot;interfacing-with-the-world&quot;&gt;Interfacing with the world&lt;/h2&gt;
&lt;p&gt;Our application logic is done; let’s explore ways to interface with it!&lt;/p&gt;
&lt;h3 id=&quot;testingcommand-line&quot;&gt;Testing/command line&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/todo-cmd.hs#L25-62&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;parseInp ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt;
parseInp &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; p &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs)   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IAdd&lt;/span&gt; (unwords xs))
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;D&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onId n &lt;span class=&quot;dt&quot;&gt;CDelete&lt;/span&gt;
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onId n (&lt;span class=&quot;dt&quot;&gt;CComplete&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;)
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;U&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onId n (&lt;span class=&quot;dt&quot;&gt;CComplete&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;)
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;P&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onId n &lt;span class=&quot;dt&quot;&gt;CPrune&lt;/span&gt;
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;M&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onId n (&lt;span class=&quot;dt&quot;&gt;CModify&lt;/span&gt; (unwords xs))
    p _          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;    onId ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt;
    onId &lt;span class=&quot;st&quot;&gt;&amp;quot;*&amp;quot;&lt;/span&gt; te &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IAll&lt;/span&gt; te)
    onId n   te &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;`ITask`&lt;/span&gt; te) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; readMaybe n

&lt;span class=&quot;ot&quot;&gt;formatTodo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
formatTodo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; unlines &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; map format &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; IM.toList
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    format (n, &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; desc compl) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; concat [ show n
                                         , &lt;span class=&quot;st&quot;&gt;&amp;quot;. [&amp;quot;&lt;/span&gt;
                                         , &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; compl &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;X&amp;quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt;
                                         , &lt;span class=&quot;st&quot;&gt;&amp;quot;] &amp;quot;&lt;/span&gt;
                                         , desc
                                         ]

&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;Enter command! &amp;#39;A descr&amp;#39; or &amp;#39;[D/C/U/P/M] [id/*]&amp;#39;&amp;quot;&lt;/span&gt;
    void &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; interactAuto &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- interactAuto takes an Interval; `toOn` gives&lt;/span&gt;
                          &lt;span class=&quot;co&quot;&gt;--   one that runs forever&lt;/span&gt;
                          toOn
                          &lt;span class=&quot;co&quot;&gt;-- default output value on bad command&lt;/span&gt;
                        &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromBlips &lt;span class=&quot;st&quot;&gt;&amp;quot;Bad command!&amp;quot;&lt;/span&gt;
                          &lt;span class=&quot;co&quot;&gt;-- run `formatTodo &amp;lt;$&amp;gt; todoApp` on emitted commands&lt;/span&gt;
                        &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; perBlip (formatTodo &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; todoApp)
                          &lt;span class=&quot;co&quot;&gt;-- emit when input is parseable&lt;/span&gt;
                        &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts parseInp&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;interactAuto&lt;/code&gt; runs an &lt;code&gt;Interval&lt;/code&gt; by feeding it in strings from stdin printing the output to stdout, until the output is “off”/&lt;code&gt;Nothing&lt;/code&gt; — then stops. Here we use &lt;code&gt;parseInp&lt;/code&gt; to emit input events whenever there is a parse, run &lt;code&gt;todoApp&lt;/code&gt; (formatted) on the emitted events, and then condense it all with &lt;code&gt;fromBlips&lt;/code&gt; and wrap it in an “always on” &lt;code&gt;toOn&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cabal sandbox init
$ cabal install auto
$ cabal exec runghc todo-cmd.hs
Enter command! &amp;#39;A descr&amp;#39; or &amp;#39;[D/C/U/P/M] [id/*]&amp;#39;
&amp;gt; A take out the trash
0. [ ] take out the trash

&amp;gt; A do the dishes
0. [ ] take out the trash
1. [ ] do the dishes

&amp;gt; C 1
0. [ ] take out the trash
1. [X] do the dishes

&amp;gt; U 1
0. [ ] take out the trash
1. [ ] do the dishes

&amp;gt; C 0
0. [X] take out the trash
1. [ ] do the dishes

&amp;gt; P *
1. [ ] do the dishes&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/auto/todo-cmd.hs&quot;&gt;download and run this yourself&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;Looks like the logic works! Time to take it to GUI!&lt;/p&gt;
&lt;h3 id=&quot;as-a-gui&quot;&gt;As a GUI&lt;/h3&gt;
&lt;p&gt;To build a GUI, we must build an &lt;code&gt;Auto&lt;/code&gt; that takes in inputs from events and output everything the front-end renderer needs to render the interface.&lt;/p&gt;
&lt;p&gt;For a typical todomvc gui, we need to be able to filter and select things. So that means we need to be extend our input type with filtering and selecting events. And our output has to also indicate the current filter selected, and the current task selected, as well.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIOpts&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUI&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; _currFilter   ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Filter&lt;/span&gt;        &lt;span class=&quot;co&quot;&gt;-- currently applied filter&lt;/span&gt;
                   ,&lt;span class=&quot;ot&quot;&gt; _currSelected ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskID&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;-- currently selected task&lt;/span&gt;
                   }

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GIFilter&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Filter&lt;/span&gt;
            &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GISelect&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskID&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Filter&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;All&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Active&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Completed&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Generic&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Enum&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Serialize&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Filter&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Instead of defining a new input mega-type with all input events and the todo map with the options, we can use good ol’ fashioned &lt;code&gt;Either&lt;/code&gt; and &lt;code&gt;(,)&lt;/code&gt;. So now, instead of:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;todoApp ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We have:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;todoAppGUI ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;GUIOpts&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we take &lt;em&gt;either&lt;/em&gt; &lt;code&gt;TodoInp&lt;/code&gt; or &lt;code&gt;GUIInp&lt;/code&gt; and then return &lt;em&gt;both&lt;/em&gt; &lt;code&gt;IntMap Task&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;GUIOpts&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;todoAppGUI ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&amp;#39;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;GUIOpts&lt;/span&gt;)
todoAppGUI &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc inp &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    filt  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith &lt;span class=&quot;dt&quot;&gt;All&lt;/span&gt;                      &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts filtInps &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp
    selc  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;                  &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts selcInps &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp
    tasks &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith mempty &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; perBlip todoApp &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts todoInps &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (tasks, &lt;span class=&quot;dt&quot;&gt;GUI&lt;/span&gt; filt selc)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    todoInps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt;
    todoInps (&lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; ti) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; ti
    todoInps _         &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    filtInps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Filter&lt;/span&gt;
    filtInps (&lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;GIFilter&lt;/span&gt; filt)) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; filt
    filtInps _                       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    selcInps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskID&lt;/span&gt;)
    selcInps (&lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;GISelect&lt;/span&gt; sec))  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; selc
    selcInps _                       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we have the same idea as before. One input stream of &lt;code&gt;Either TodoInp GUIInp&lt;/code&gt; comes through, and we fork it into three blip streams that each do what we want. &lt;code&gt;holdWith x :: Auto m (Blip b) b&lt;/code&gt; is always the value of the last emitted item…but starts off as &lt;code&gt;x&lt;/code&gt; first.&lt;/p&gt;
&lt;p&gt;By the way, the above code is much more succinct if you are willing to use &lt;em&gt;&lt;a href=&quot;http://lens.github.com&quot;&gt;lens&lt;/a&gt;&lt;/em&gt;…&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;todoAppGUI ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&amp;#39;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;GUIOpts&lt;/span&gt;)
todoAppGUI &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc inp &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    filt  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith &lt;span class=&quot;dt&quot;&gt;All&lt;/span&gt;
           &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts (preview (_Right &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; _GIFilter)) &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp
    selc  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
           &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts (preview (_Right &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; _GISelect)) &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp
    tasks &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith mempty &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; perBlip todoApp
           &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts (preview _Left)                &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (tasks, &lt;span class=&quot;dt&quot;&gt;GUI&lt;/span&gt; filt selc)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(assuming we defined the prisms for &lt;code&gt;GUIInp&lt;/code&gt; or used &lt;code&gt;&#39;&#39;mkPrisms&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;Neat, right? In a way, you can say that &lt;code&gt;emitJusts&lt;/code&gt; and &lt;code&gt;Prisms&lt;/code&gt;/lens was a match made in heaven :)&lt;/p&gt;
&lt;h3 id=&quot;giving-it-life&quot;&gt;Giving it life&lt;/h3&gt;
&lt;p&gt;The last step is to hook everything up together —&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Setting up events in our GUI to feed inputs to a queue&lt;/li&gt;
&lt;li&gt;Setting up the queue to wait on inputs, and output the task map/gui status on every one using &lt;code&gt;todoAppGUI&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Rendering the output into the GUI framework of your choice&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The second step in particular can be handled with good ol’ &lt;code&gt;[runOnChan][]&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;runOnChan ::&lt;/span&gt; (b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&amp;#39;&lt;/span&gt; a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Auto&amp;#39;&lt;/span&gt; a b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We know and love &lt;code&gt;runOnChan&lt;/code&gt; from when we used it to make our &lt;a href=&quot;http://blog.jle.im/entry/auto-building-a-declarative-chatbot-with-implicit-serialization#irc-backend-the-ugly-part&quot;&gt;chatbot&lt;/a&gt;. It runs an &lt;code&gt;Auto&#39; a b&lt;/code&gt; “on a &lt;code&gt;Chan&lt;/code&gt;” (concurrent queue). The first argument is an “output hander” — it handles the &lt;code&gt;b&lt;/code&gt;s that the &lt;code&gt;Auto&#39;&lt;/code&gt; pops out. It decides whether to stop the whole thing or keep on listening based on the &lt;code&gt;Bool&lt;/code&gt; result of the handler. The second argument is the &lt;code&gt;Chan a&lt;/code&gt; to listen for inputs on. Whenever something is dropped into that &lt;code&gt;Chan&lt;/code&gt;, it runs the &lt;code&gt;Auto&#39;&lt;/code&gt; with the &lt;code&gt;a&lt;/code&gt; and processes the output &lt;code&gt;b&lt;/code&gt; with the handler.&lt;/p&gt;
&lt;p&gt;Our final runner is then just:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;runOnChan renderGUI inputChan todoAppGUI&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;renderGUI ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;GUIOpts&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;inputChan ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The rendering is done with &lt;code&gt;renderGUI&lt;/code&gt;…and it really depends on your framework here. That’s #3 from the list above.&lt;/p&gt;
&lt;p&gt;All you need after that is just to have your GUI hook up event handlers to drop the appropriate &lt;code&gt;Either TodoInp GUIInp&lt;/code&gt; into &lt;code&gt;inputChan&lt;/code&gt;…and you’re golden!&lt;/p&gt;
&lt;h2 id=&quot;seeing-it-in-action&quot;&gt;Seeing it in action&lt;/h2&gt;
&lt;p&gt;We’ve reached the end of our tutorial — the parts about &lt;code&gt;auto&lt;/code&gt;. It is my hope that whatever GUI front-end you want to work with, it’ll be simple enough to “plug in” our &lt;code&gt;Auto&lt;/code&gt; logic.&lt;/p&gt;
&lt;p&gt;A &lt;a href=&quot;https://mstksg.github.com/auto-examples/todo&quot;&gt;live demo&lt;/a&gt; is online too; you can see &lt;a href=&quot;https://github.com/mstksg/auto-examples/blob/master/src/TodoJS.hs&quot;&gt;the source of the front-end bindings&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is a bare-bons &lt;em&gt;ghcjs&lt;/em&gt; implementation using &lt;em&gt;ghcjs-dom&lt;/em&gt;, which uses direct dom manipulation.&lt;/p&gt;
&lt;p&gt;User &lt;a href=&quot;https://github.com/eryx67&quot;&gt;eryx67&lt;/a&gt; has been kind enough to provide &lt;a href=&quot;https://github.com/eryx67/auto-examples/blob/master/src/TodoJS.hs&quot;&gt;an implementation in &lt;em&gt;ghcjs&lt;/em&gt;&lt;/a&gt; with the &lt;em&gt;&lt;a href=&quot;https://github.com/ocharles/virtual-dom&quot;&gt;virtual-dom&lt;/a&gt;&lt;/em&gt; library (&lt;a href=&quot;https://github.com/mstksg/auto-examples/commit/246133a89fbca6a2ec7ea276d8536701f6ab8d2c?diff=split&quot;&gt;side-by-side comparison&lt;/a&gt;), so there is a slightly less uglier implementation with abstraction :)&lt;/p&gt;
&lt;p&gt;As always, feel free to ask questions in the comments, hop over to &lt;em&gt;#haskell-game&lt;/em&gt; or &lt;em&gt;#haskell-auto&lt;/em&gt; on freenode, or send me a &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;tweet&lt;/a&gt;! And look forward to more tutorials as the &lt;a href=&quot;http://blog.jle.im/entries/series/+all-about-auto&quot;&gt;All About Auto&lt;/a&gt; series progresses!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Auto</category><category>Tutorials</category><guid isPermaLink="true">https://blog.jle.im/entry/auto-a-todo-gui-application-with-auto-on.html</guid><pubDate>Thu, 23 Apr 2015 18:04:10 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Auto, Tutorials</dc:subject><dc:date>2015-04-23</dc:date></item><item><title>Unique sample drawing &amp; searches with List and StateT — “Send more money”</title><link>https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.html</link><description>&lt;p&gt;Nothing too crazy today, just a cute (basic/intermediate) haskell trick as a response to Mark Dominus’s excellent &lt;a href=&quot;http://blog.plover.com&quot;&gt;Universe of Discourse&lt;/a&gt; post on &lt;a href=&quot;http://blog.plover.com/prog/haskell/monad-search.html&quot;&gt;Easy exhaustive search with the list monad&lt;/a&gt; intended for people new or unfamiliar with haskell demonstrating the common “list monad as a constraint solver” approach that is standard fare for learning Haskell. I myself have literally done &lt;a href=&quot;http://blog.jle.im/entries/series/+monadplus-success-failure-monads&quot;&gt;an entire series of blog posts&lt;/a&gt; on this usage.&lt;/p&gt;
&lt;p&gt;Mark’s use case however incorporates a bit of an extra pattern not typically discussed. The list monad is good for taking “independent samples” of things (looking at different samples from a list):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         z &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         return [x,y,z]
[&lt;span class=&quot;st&quot;&gt;&amp;quot;aaa&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;aab&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;aac&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;aba&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;abb&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt; ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, what if you wanted to instead “draw” from a pool, and represent different drawings? Traditionally, the answer was something like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; filter (&lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; x) &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         z &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; filter (&lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; y) &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; filter (&lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; x) &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         return [x,y,z]
&lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;acb&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;bac&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;bca&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;cab&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;cba&amp;quot;&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a little bit awkward…and it definitely gets a lot worse (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?O%28n%5E2%29&quot; alt=&quot;O(n^2)&quot; title=&quot;O(n^2)&quot; /&gt;) when you have more items. Also, it relies on an &lt;code&gt;Eq&lt;/code&gt; constraint — what if our thing doesn’t have an &lt;code&gt;Eq&lt;/code&gt; instance? And this also falls apart when our list contains duplicate items. If we had used &lt;code&gt;&amp;quot;aabc&amp;quot;&lt;/code&gt; instead of &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;, the result would be the same — despite having more &lt;code&gt;&#39;a&#39;&lt;/code&gt;s to pick from!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important note:&lt;/strong&gt; After writing this article, I found out that Douglas Auclair in &lt;a href=&quot;https://wiki.haskell.org/wikiupload/6/6a/TMR-Issue11.pdf&quot;&gt;11th issue of the Monad Reader&lt;/a&gt; solved this exact same problem with pretty much the exact same approach. (Oops!) If you want to do further reading, check it out! :D&lt;/p&gt;
&lt;h2 id=&quot;statet&quot;&gt;StateT&lt;/h2&gt;
&lt;p&gt;There’s a type in the &lt;em&gt;transformers&lt;/em&gt; library that provides a very useful monad instance:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; s m a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; (s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (a, s))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;StateT s m a&lt;/code&gt; is a function that takes an initial state &lt;code&gt;s&lt;/code&gt; and returns a result &lt;code&gt;a&lt;/code&gt; with a modified state…in the context of &lt;code&gt;m&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Specialize for &lt;code&gt;m ~ []&lt;/code&gt; and we get&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; s [] a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; (s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [(a, s)])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is basically describing a function from a initial state to a list of &lt;em&gt;ways you can modify the state&lt;/em&gt;, and different results from each one. It returns a list of “all ways you can mutate this state”.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;foo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; [] &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
foo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [(even x, x&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), (odd x, x&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), (x &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, negate x)]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;foo&lt;/code&gt; takes a number, &lt;code&gt;x&lt;/code&gt;, and says, “here are three ways we might proceed from having this number. We can return whether or not it’s even, in which case the new state is &lt;code&gt;x+1&lt;/code&gt;…we can return whether or not it’s odd, in which case the new state is &lt;code&gt;x-1&lt;/code&gt;….or we can return whether or not it’s positive, in which case the new state is &lt;code&gt;negate x&lt;/code&gt;”&lt;/p&gt;
&lt;p&gt;What the monad instance does is that it allows you to “chain” forks, and go along different forks, and gather together “all possible forks” you could have taken. At the end, it outputs all possible forks. So if you did &lt;code&gt;foo &amp;gt;&amp;gt; foo&lt;/code&gt;, there’d be nine results — one result for when you took the first route (the &lt;code&gt;x+1&lt;/code&gt;) twice, one for when you took the first and then the second (&lt;code&gt;x-1&lt;/code&gt;), one for when you took the first and the third….and the second and the first…etc., etc.&lt;/p&gt;
&lt;h3 id=&quot;monadplus&quot;&gt;MonadPlus&lt;/h3&gt;
&lt;p&gt;One other tool we have at our disposal is &lt;code&gt;guard&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;guard ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; [] ()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is a &lt;code&gt;StateT&lt;/code&gt; action that says “kill this current branch if given &lt;code&gt;False&lt;/code&gt;, or go on if given &lt;code&gt;True&lt;/code&gt;”&lt;/p&gt;
&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;
&lt;p&gt;The problem, as stated, was to find distinct digits for each letter to solve:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    S E N D
+   M O R E
-----------
  M O N E Y&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So &lt;code&gt;SEND&lt;/code&gt; is a four-digit number, &lt;code&gt;MORE&lt;/code&gt; is a four-digit number, and &lt;code&gt;MONEY&lt;/code&gt; is a five-digit number that is the sum of the two. The first digit of &lt;code&gt;MONEY&lt;/code&gt; has to be the first digit of &lt;code&gt;MORE&lt;/code&gt;, the last digit of &lt;code&gt;MORE&lt;/code&gt; has to be the second digit of &lt;code&gt;SEND&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;The previous approach was done using the entire “pick from all possibilities…except for the ones already chosen”, using &lt;code&gt;(/=)&lt;/code&gt; and filtering over all of the things seen vs all of the things to pick from.&lt;/p&gt;
&lt;p&gt;However, we can abstract over “picking dependently from a sample” by defining a function called &lt;code&gt;select&lt;/code&gt;, which really should be in the base libraries but isn’t for some reason:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/send-more-money.hs#L7-9&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;select ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [(a, [a])]
select []     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; []
select (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (x,xs) &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; [(y,x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ys) &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; (y,ys) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; select xs]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Implementation thanks to Cale, who has fought valiantly yet fruitlessly to get this into base for many years.)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;select&lt;/code&gt; will take a list &lt;code&gt;[a]&lt;/code&gt; and return a list of different “selected” &lt;code&gt;a&lt;/code&gt;s, with the rest of the list, too:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; select &lt;span class=&quot;st&quot;&gt;&amp;quot;abcd&amp;quot;&lt;/span&gt;
[(&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;bcd&amp;quot;&lt;/span&gt;),(&lt;span class=&quot;ch&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;acd&amp;quot;&lt;/span&gt;),(&lt;span class=&quot;ch&quot;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;abd&amp;quot;&lt;/span&gt;),(&lt;span class=&quot;ch&quot;&gt;&amp;#39;d&amp;#39;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;)]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But, hey…does the type signature of &lt;code&gt;select&lt;/code&gt; look like anything familiar?&lt;/p&gt;
&lt;p&gt;It looks &lt;em&gt;exactly&lt;/em&gt; like something that &lt;code&gt;StateT&lt;/code&gt; is supposed to describe! Give an initial state (&lt;code&gt;[a]&lt;/code&gt;), and returns a list of all possible ways to “mutate” that state (by removing one element from the state), and a result from each mutation (the removed element).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; select ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; [a] [] a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And armed with this…we have all we need&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/send-more-money.hs#L3-35&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad&lt;/span&gt;             (guard, mfilter)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad.Trans.State&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.List&lt;/span&gt;                 (foldl&amp;#39;)

&lt;span class=&quot;ot&quot;&gt;asNumber ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
asNumber &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; foldl&amp;#39; (\t o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; t&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; o) &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; print &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; flip evalStateT [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    s &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    e &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    n &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    d &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    m &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    o &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    r &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; s &lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; m &lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; send  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [s,e,n,d]
        more  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [m,o,r,e]
        money &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [m,o,n,e,y]
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; send &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; more &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; money
    return (send, more, money)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember, &lt;code&gt;StateT&lt;/code&gt; here operates with an underlying state of &lt;code&gt;[Int]&lt;/code&gt;, a list of numbers not yet picked. &lt;code&gt;StateT select&lt;/code&gt; picks one of these numbers, and modifies the state to now only include the items that were not picked. So every time you sequence &lt;code&gt;StateT select&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt; draws from a smaller and smaller pool of numbers, and makes the state list smaller and smaller. What sequencing &lt;code&gt;StateT&lt;/code&gt; does is allow us to explore &lt;em&gt;all&lt;/em&gt; of the possible ways we could pick and modify state, all at once. Using &lt;code&gt;guard&lt;/code&gt;, we then “close off” and kill off the paths that don’t end up how we’d like.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;asNumber&lt;/code&gt; takes a list like &lt;code&gt;[1,2,3]&lt;/code&gt; and turns it into the number &lt;code&gt;123&lt;/code&gt;; credit to the source blog.&lt;/p&gt;
&lt;p&gt;And, to test it out…&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;ghc&lt;/span&gt; -O2 send-more-money.hs
$ &lt;span class=&quot;ex&quot;&gt;./send-more-money&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# [(9567,1085,10652)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It returns the one and only solution, &lt;code&gt;SEND = 9567&lt;/code&gt;, &lt;code&gt;MORE = 1085&lt;/code&gt;, and &lt;code&gt;MONEY = 10652&lt;/code&gt;.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We can make things a little bit more efficient with minimal cost in expressiveness. But not that it matters…the original version runs fast already.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/send-more-money.hs#L38-59&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;select&amp;#39; ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [(a,[a])]
select&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go []
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
   go xs [] &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; []
   go xs (y&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ys) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (y,xs&lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt;ys) &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; go (y&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) ys

&lt;span class=&quot;ot&quot;&gt;main&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; print &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; flip evalStateT [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    s &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; mfilter (&lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    m &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; mfilter (&lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    e &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    n &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    d &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    o &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    r &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; send  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [s,e,n,d]
        more  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [m,o,r,e]
        money &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [m,o,n,e,y]
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; send &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; more &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; money
    return (send, more, money)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a more performant version of &lt;code&gt;select&lt;/code&gt; &lt;a href=&quot;http://chimera.labs.oreilly.com/books/1230000000929/pr01.html&quot;&gt;courtesy of Simon Marlow&lt;/a&gt; that doesn’t preserve the order of the “rest of the elements”.&lt;/p&gt;
&lt;p&gt;Also, we use &lt;code&gt;mfilter&lt;/code&gt; to “eliminate bad &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt;s” right off the bat, before having to pick any more things. &lt;code&gt;mfilter&lt;/code&gt; can be thought of as “killing the fork immediately” if the action doesn’t satisfy the predicate. If the &lt;code&gt;s&lt;/code&gt; picked doesn’t match &lt;code&gt;(/= 0)&lt;/code&gt;, then the entire branch/fork is immediately ruled invalid.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;By the way, isn’t it neat that it does all of this in “constant space”? It just keeps track of the output list, but the actual search processes is in constant space. You don’t need to keep track of all &lt;code&gt;10!&lt;/code&gt; combinations in memory at once. Hooray laziness!&lt;/p&gt;
&lt;h2 id=&quot;other-applications&quot;&gt;Other Applications&lt;/h2&gt;
&lt;p&gt;Using &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;StateT&lt;/code&gt;, we can do a lot of things involving picking from a sample, or permutations. Anything that you used to awkwardly do by using filter not-equal-to’s can work now. You can do things like drawing from a deck:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;pokerGame ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Ordering&lt;/span&gt;]
pokerGame &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; flip evalStateT [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;51&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    p2Hand &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; replicateM &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select)
    p1Hand &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; replicateM &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select)
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; pokerCompare p1Hand p2Hand&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which would draw five distinct cards from a deck of &lt;code&gt;[0..51]&lt;/code&gt;, and return who won for each draw (assuming you had a suitable &lt;code&gt;pokerCompare :: [Card] -&amp;gt; [Card] -&amp;gt; Ordering&lt;/code&gt;). Note that if you use &lt;code&gt;runStateT&lt;/code&gt;, you’d get the results (the winner), &lt;em&gt;as well as&lt;/em&gt; the leftover cards in the deck for each path!&lt;/p&gt;
&lt;!-- I used to have an example here about simulating russian roulette --&gt;
&lt;!-- But this doesn&#39;t really work in a useful way...because the paths all &quot;stop&quot; --&gt;
&lt;!-- after the first shot.  In reality, you are just as likely to be shot on the --&gt;
&lt;!-- first pull as you are on the second.  But as this simulation runs, it &quot;stops&quot; --&gt;
&lt;!-- after the first shot...so `1` will only show up once. --&gt;
&lt;p&gt;You can even combine the two sorts of drawings — sampling independently (like rolling dice) using &lt;code&gt;lift&lt;/code&gt;, and drawing from an underlying deck. For example, you might encode some game logic from a board game like monopoly:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;combo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; flip evalStateT initialDeck &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    roll &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; lift [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;]
    draw &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Whenever you want a dice roll, use &lt;code&gt;lift [1..6]&lt;/code&gt;…and whenever you want to draw from the deck, use &lt;code&gt;StateT select&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What you get in the end, remember, is a list of “all possible paths”. You’ll get a list of every possible result from all of your different rolling and drawing choices.&lt;/p&gt;
&lt;p&gt;Happy Haskelling!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;For some reason this runs pretty slowly if you use &lt;code&gt;runghc&lt;/code&gt;/&lt;code&gt;runHaskell&lt;/code&gt;, but it runs in the blink of an eye when you actually compile it (and especially with optimizations on). The difference is pretty striking…and I don’t really know what’s going on here, to be honest. If anyone does know a good explanation, I’d love to hear it :)&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Tutorials</category><guid isPermaLink="true">https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.html</guid><pubDate>Fri, 24 Apr 2015 19:05:56 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Tutorials</dc:subject><dc:date>2015-04-24</dc:date></item><language>en</language><copyright>Copyright 2016 Justin Le</copyright><managingEditor>justin@jle.im (Justin Le)</managingEditor><webMaster>justin@jle.im (Justin Le)</webMaster><lastBuildDate>Thu, 15 Dec 2016 11:31:54 UTC</lastBuildDate><generator>feed-0.3.11.1 (Sigbjorn Finne)</generator><image><url>https://blog.jle.im/img/site_logo.jpg</url><title>in Code</title><link>https://blog.jle.im/</link></image><dc:creator>Justin Le</dc:creator><dc:language>en</dc:language><dc:rights>Copyright 2016 Justin Le</dc:rights><dc:date>2016-12-15</dc:date><dc:description>Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge.</dc:description></channel></rss>