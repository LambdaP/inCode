<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>in Code — Entries</title><link>https://blog.jle.im/</link><description>Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge.</description><item><title>Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 1)</title><link>https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html</link><description>&lt;p&gt;It seems these days like programming with dependent types in Haskell (and its advantages) is moving slowly but steadily to the mainstream of Haskell programming. In the current state of Haskell education, dependent types are often considered topics for “advanced” Haskell users. However, I can foresee a day where the ease of use of modern Haskell libraries relying on dependent types forces programming with dependent types to be an integral part of normal intermediate (or even beginner) Haskell education.&lt;/p&gt;
&lt;p&gt;There are &lt;a href=&quot;https://www.youtube.com/watch?v=rhWMhTjQzsU&quot;&gt;more&lt;/a&gt; and &lt;a href=&quot;http://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/&quot;&gt;more&lt;/a&gt; and &lt;a href=&quot;https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety&quot;&gt;more&lt;/a&gt; and &lt;a href=&quot;http://jozefg.bitbucket.org/posts/2014-08-25-dep-types-part-1.html&quot;&gt;more&lt;/a&gt; great resources and tutorials and introductions to integrating dependent types into your Haskell every day. The point of this series is to show more some practical examples of using dependent types in guiding your programming, and to also walk through the “why” and high-level philosophy of the way you structure your Haskell programs. It’ll also hopefully instill an intuition of a dependently typed work flow of “exploring” how dependent types can help your current programs. The intended audience of this post is for intermediate Haskell programmers in general, with no required knowledge of dependently typed programming. I should also point out that I’m no expert — I’m still in the process of learning this all, myself :)&lt;/p&gt;
&lt;p&gt;The first project in this series will build up to a type-safe &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_neural_network&quot;&gt;artificial neural network&lt;/a&gt;&lt;/strong&gt; implementation with back-propagation training.&lt;/p&gt;
&lt;h4 id=&quot;setup&quot;&gt;Setup&lt;/h4&gt;
&lt;p&gt;This post is written on &lt;em&gt;&lt;a href=&quot;http://www.haskellstack.org&quot;&gt;stack&lt;/a&gt;&lt;/em&gt; snapshot &lt;em&gt;&lt;a href=&quot;https://www.stackage.org/lts-5.17&quot;&gt;lts-5.17&lt;/a&gt;&lt;/em&gt;, but uses an unreleased version of &lt;em&gt;hmatrix&lt;/em&gt;, &lt;em&gt;&lt;a href=&quot;https://github.com/albertoruiz/hmatrix/tree/42a88fbcb6bd1d2c4dc18fae5e962bd34fb316a1&quot;&gt;hmatrix-0.18 (commit 42a88fb)&lt;/a&gt;&lt;/em&gt;. I &lt;a href=&quot;http://mstksg.github.io/hmatrix/&quot;&gt;maintain my own documentation&lt;/a&gt; for reference.&lt;/p&gt;
&lt;p&gt;There is also a bug in &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/singletons-2.0.1&quot;&gt;singletons-2.0.1&lt;/a&gt;&lt;/em&gt; package that’s fixed in &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/singletons-2.1&quot;&gt;singletons-2.1&lt;/a&gt;&lt;/em&gt;, but &lt;em&gt;2.1&lt;/em&gt; is not available with GHC 7.10 – I have a &lt;a href=&quot;https://github.com/mstksg/singletons/releases/tag/v2.0.2&quot;&gt;github fork&lt;/a&gt; that fixes the bug if you want to stay on GHC 7.10.&lt;/p&gt;
&lt;p&gt;You can add this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;packages:&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;location:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;git:&lt;/span&gt; git@github.com:albertoruiz/hmatrix.git
    &lt;span class=&quot;fu&quot;&gt;commit:&lt;/span&gt; 42a88fbcb6bd1d2c4dc18fae5e962bd34fb316a1
  &lt;span class=&quot;fu&quot;&gt;subdirs:&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; packages/base
&lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;location:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;git:&lt;/span&gt; git@github.com:mstksg/singletons.git
    &lt;span class=&quot;fu&quot;&gt;commit:&lt;/span&gt; v2.0.2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to the &lt;code&gt;packages&lt;/code&gt; field of your directory or global &lt;em&gt;stack.yaml&lt;/em&gt; and &lt;em&gt;stack&lt;/em&gt; will know what version of &lt;em&gt;hmatrix&lt;/em&gt; and &lt;em&gt;singletons&lt;/em&gt; to use when you use &lt;code&gt;stack runghc&lt;/code&gt; or &lt;code&gt;stack ghc&lt;/code&gt;, etc. to build your files.&lt;/p&gt;
&lt;h2 id=&quot;neural-networks&quot;&gt;Neural Networks&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_neural_network&quot;&gt;Artificial neural networks&lt;/a&gt; have been somewhat of a hot topic in computing recently. Implementations of training algorithms (like back-propagation) are tricky to implement correctly — despite being simple, there are many locations where accidental bugs might pop up when multiplying the wrong matrices, for example.&lt;/p&gt;
&lt;p&gt;Though some might recognize that complicated matrix and vector arithmetic is a common application of phantom type-based dependent types, it’s not necessarily always easy to gauge before-the-fact what would or would not be a good candidate for adding dependent types to. Often times, it can even be considered premature to start off with “as powerful types as you can”. So let’s walk through programming things with as “dumb” types as possible, and see where types can help.&lt;/p&gt;
&lt;p&gt;We’ll be following a process called “type-driven development” — start with general and non-descriptive types, write the implementation and recognize partial functions and red flags, and slowly refine and add more and more powerful types to fix the problems.&lt;/p&gt;
&lt;h3 id=&quot;background&quot;&gt;Background&lt;/h3&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/entries/dependent-haskell-1/ffneural.png&quot; title=&quot;Feed-forward ANN architecture&quot; alt=&quot;Feed-forward ANN architecture&quot; /&gt;&lt;figcaption&gt;Feed-forward ANN architecture&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Here’s a quick run through on background for ANN’s — but remember, this isn’t an article on ANN’s, so we are going to be glossing over some of the details.&lt;/p&gt;
&lt;p&gt;We’re going to be implementing a &lt;em&gt;feed-forward neural network&lt;/em&gt; with back-propagation training. These networks are layers of “nodes”, each connected to the each of the nodes of the previous layer. Input goes to the first layer, which feeds information to the next year, which feeds it to the next, etc., until the final layer, where we read it off as the “answer” that the network is giving us. Layers between the input and output layers are called &lt;em&gt;hidden&lt;/em&gt; layers. Every node “outputs” a weighted sum of all of the outputs of the &lt;em&gt;previous&lt;/em&gt; layer, plus an always-on “bias” term (so that its result can be non-zero even when all of its inputs are zero). Symbolically, it looks like:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0Ay_j%20%3D%20b_j%20%2B%20%5Csum_i%5Em%20w_%7Bij%7D%20x_i%0A&quot; alt=&quot;
y_j = b_j + \sum_i^m w_{ij} x_i
&quot; title=&quot;
y_j = b_j + \sum_i^m w_{ij} x_i
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Or, if we treat the output of a layer and the list of list of weights as a matrix, we can write it a little cleaner:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Cmathbf%7By%7D%20%3D%20%5Cmathbf%7Bb%7D%20%2B%20W%20%5Cmathbf%7Bx%7D%0A&quot; alt=&quot;
\mathbf{y} = \mathbf{b} + W \mathbf{x}
&quot; title=&quot;
\mathbf{y} = \mathbf{b} + W \mathbf{x}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;The result, the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n&quot; alt=&quot;n&quot; title=&quot;n&quot; /&gt;-vector of nodes &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cmathbf%7By%7D&quot; alt=&quot;\mathbf{y}&quot; title=&quot;\mathbf{y}&quot; /&gt;, is computed from the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n&quot; alt=&quot;n&quot; title=&quot;n&quot; /&gt;-vector of biases &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cmathbf%7Bb%7D&quot; alt=&quot;\mathbf{b}&quot; title=&quot;\mathbf{b}&quot; /&gt; and the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n%20%5Ctimes%20m&quot; alt=&quot;n \times m&quot; title=&quot;n \times m&quot; /&gt; weight matrix &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?W&quot; alt=&quot;W&quot; title=&quot;W&quot; /&gt; multiplied with the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?m&quot; alt=&quot;m&quot; title=&quot;m&quot; /&gt;-vector input, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cmathbf%7Bx%7D&quot; alt=&quot;\mathbf{x}&quot; title=&quot;\mathbf{x}&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;To “scale” the result (and to give the system the magical powers of nonlinearity), we actually apply an “activation function” to the output before passing it down to the next step. We’ll be using the popular &lt;a href=&quot;https://en.wikipedia.org/wiki/Logistic_function&quot;&gt;logistic function&lt;/a&gt;, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f%28x%29%20%3D%201%20%2F%20%281%20%2B%20e%5E%7B-x%7D%29&quot; alt=&quot;f(x) = 1 / (1 + e^{-x})&quot; title=&quot;f(x) = 1 / (1 + e^{-x})&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Training&lt;/em&gt; a network involves picking the right set of weights to get the network to answer the question you want.&lt;/p&gt;
&lt;h2 id=&quot;vanilla-types&quot;&gt;Vanilla Types&lt;/h2&gt;
&lt;p&gt;We can store a network by storing the matrix of of weights and biases between each layer:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L18-20&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; wBiases ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;-- n&lt;/span&gt;
                 ,&lt;span class=&quot;ot&quot;&gt; wNodes  ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;-- n x m&lt;/span&gt;
                 }                              &lt;span class=&quot;co&quot;&gt;-- &amp;quot;m to n&amp;quot; layer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, a &lt;code&gt;Weights&lt;/code&gt; linking an &lt;em&gt;m&lt;/em&gt;-node layer to an &lt;em&gt;n&lt;/em&gt;-node layer has an &lt;em&gt;n&lt;/em&gt;-dimensional bias vector (one component for each output) and an &lt;em&gt;n&lt;/em&gt;-by-&lt;em&gt;m&lt;/em&gt; node weight matrix (one column for each output, one row for each input).&lt;/p&gt;
&lt;p&gt;(We’re using the &lt;code&gt;Matrix&lt;/code&gt; type from the awesome &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/hmatrix&quot;&gt;hmatrix&lt;/a&gt;&lt;/em&gt; library for performant linear algebra, implemented using blas/lapack under the hood)&lt;/p&gt;
&lt;p&gt;A feed-forward neural network is then just a linked list of these weights:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L22-28&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;     ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    (:&amp;amp;~) ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we’re using &lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/GADT&quot;&gt;GADT&lt;/a&gt; syntax here, which just lets us define &lt;code&gt;Network&lt;/code&gt; (with a kind signature, &lt;code&gt;*&lt;/code&gt;) by providing the type of its &lt;em&gt;constructors&lt;/em&gt;, &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;(:&amp;amp;~)&lt;/code&gt;. It’d be equivalent to the following normal data declaration:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A network with one input layer, two inner layers, and one output layer would look like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ih &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; hh &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; ho&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first component is the weights from the input to first inner layer, the second is the weights between the two hidden layers, and the last is the weights between the last hidden layer and the output layer.&lt;/p&gt;
&lt;!-- TODO: graphs using diagrams? --&gt;
&lt;p&gt;We can write simple procedures, like generating random networks:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L46-56&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomWeights ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;
randomWeights i o &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    seed1 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getRandom
&lt;span class=&quot;ot&quot;&gt;    seed2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getRandom
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; randomVector  seed1 &lt;span class=&quot;dt&quot;&gt;Uniform&lt;/span&gt; o &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
        wN &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; uniformSample seed2 o (replicate i (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN

&lt;span class=&quot;ot&quot;&gt;randomNet ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
randomNet i [] o     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;     &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights i o
randomNet i (h&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;hs) o &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights i h &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; randomNet h hs o&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(We’re using the &lt;code&gt;MonadRandom&lt;/code&gt; typeclass from the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/MonadRandom&quot;&gt;MonadRandom&lt;/a&gt;&lt;/em&gt; library, which uses the mechanisms in &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/random-1.1/docs/System-Random.html&quot;&gt;System.Random&lt;/a&gt;&lt;/em&gt; and gives us a generic way of working with monads where we can get random values with &lt;code&gt;getRandom&lt;/code&gt;, etc.)&lt;/p&gt;
&lt;p&gt;(&lt;a href=&quot;http://hackage.haskell.org/package/hmatrix-0.17.0.1/docs/Numeric-LinearAlgebra.html#v:randomVector&quot;&gt;&lt;code&gt;randomVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://hackage.haskell.org/package/hmatrix-0.17.0.1/docs/Numeric-LinearAlgebra.html#v:uniformSample&quot;&gt;&lt;code&gt;uniformSample&lt;/code&gt;&lt;/a&gt; are from the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/hmatrix&quot;&gt;hmatrix&lt;/a&gt;&lt;/em&gt; library, generating random vectors and matrices from a random &lt;code&gt;Int&lt;/code&gt; seed. We manipulate them here to generate them with numbers between -1 and 1)&lt;/p&gt;
&lt;p&gt;And now we can write a function to “run” our network on a given input vector, following the matrix equation we wrote earlier:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L30-44&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;logistic ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Floating&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
logistic x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; exp (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;x))

&lt;span class=&quot;ot&quot;&gt;runLayer ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;
runLayer (&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN) v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; v

&lt;span class=&quot;ot&quot;&gt;runNet ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;
runNet (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w)      &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic (runLayer w v)
runNet (w &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39;) &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic (runLayer w v)
                       &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  runNet n&amp;#39; v&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;#&amp;gt;&lt;/code&gt; is matrix-vector multiplication)&lt;/p&gt;
&lt;!-- TODO: examples of running --&gt;
&lt;p&gt;If you’re a non-Haskell programmer, this might all seem perfectly fine and normal, and you probably have only a slightly elevated heart rate. If you are a Haskell programmer, you are most likely already having heart attacks. Let’s imagine all of the bad things that could happen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;How do we know that we didn’t accidentally mix up the dimensions for our implementation of &lt;code&gt;randomWeights&lt;/code&gt;? We could have switched parameters and be none the wiser.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How do we even know that each subsequent matrix in the network is “compatible”? We want the outputs of one matrix to line up with the inputs of the next, but there’s no way to know. It’s possible to build a bad network, and things will just explode at runtime.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How do we know the size of vector the network expects? What stops you from sending in a bad vector at run-time? We might do runtime-checks, but the compiler won’t help us.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How do we verify that we have implemented &lt;code&gt;runLayer&lt;/code&gt; and &lt;code&gt;runNet&lt;/code&gt; in a way that they won’t suddenly fail at runtime? We write &lt;code&gt;l #&amp;gt; v&lt;/code&gt;, but how do we know that it’s even correct…what if we forgot to multiply something, or used something in the wrong places? We can it prove ourselves, but the compiler won’t help us.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;back-propagation&quot;&gt;Back-propagation&lt;/h3&gt;
&lt;p&gt;Now, let’s try implementing back-propagation! It’s a textbook gradient descent algorithm. There are &lt;a href=&quot;https://en.wikipedia.org/wiki/Backpropagation&quot;&gt;many explanations&lt;/a&gt; on the internet; the basic idea is that you try to minimize the squared error of what the neural network outputs for a given input vs. the actual expected output. You find the direction of change that minimizes the error (by finding the derivative), and move that direction. The implementation of backpropagation is found in many sources online and in literature, so let’s see the implementation in Haskell:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L58-96&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;train ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- ^ learning rate&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;-- ^ input vector&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;-- ^ target vector&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;-- ^ network to train&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
train rate x0 target &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fst &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; go x0
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    go ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;-- ^ input vector&lt;/span&gt;
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;-- ^ network to train&lt;/span&gt;
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;)
    &lt;span class=&quot;co&quot;&gt;-- handle the output layer&lt;/span&gt;
    go &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;x (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN))
        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runLayer w x
              o    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic y
              &lt;span class=&quot;co&quot;&gt;-- the gradient (how much y affects the error)&lt;/span&gt;
              &lt;span class=&quot;co&quot;&gt;--   (logistic&amp;#39; is the derivative of logistic)&lt;/span&gt;
              dEdy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic&amp;#39; y &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; (o &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; target)
              &lt;span class=&quot;co&quot;&gt;-- new bias weights and node weights&lt;/span&gt;
              wB&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; scale rate dEdy
              wN&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; scale rate (dEdy &lt;span class=&quot;ot&quot;&gt;`outer`&lt;/span&gt; x)
              w&amp;#39;   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB&amp;#39; wN&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- bundle of derivatives for next step&lt;/span&gt;
              dWs  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; tr wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; dEdy
          &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w&amp;#39;, dWs)
    &lt;span class=&quot;co&quot;&gt;-- handle the inner layers&lt;/span&gt;
    go &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;x (w&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN) &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n)
        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runLayer w x
              o          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic y
              &lt;span class=&quot;co&quot;&gt;-- get dWs&amp;#39;, bundle of derivatives from rest of the net&lt;/span&gt;
              (n&amp;#39;, dWs&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go o n
              &lt;span class=&quot;co&quot;&gt;-- the gradient (how much y affects the error)&lt;/span&gt;
              dEdy       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic&amp;#39; y &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; dWs&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- new bias weights and node weights&lt;/span&gt;
              wB&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; scale rate dEdy
              wN&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; scale rate (dEdy &lt;span class=&quot;ot&quot;&gt;`outer`&lt;/span&gt; x)
              w&amp;#39;   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB&amp;#39; wN&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- bundle of derivatives for next step&lt;/span&gt;
              dWs  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; tr wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; dEdy
          &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (w&amp;#39; &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39;, dWs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The algorithm computes the &lt;em&gt;updated&lt;/em&gt; network by recursively updating the layers, backwards up from the output layer. At every step, it returns the updated layer/network, as well as a bundle of derivatives (&lt;code&gt;dWs&lt;/code&gt;) for the next layer up to use to calculate its descent direction.&lt;/p&gt;
&lt;p&gt;At the output layer, all it needs to calculate the direction of descent is just &lt;code&gt;o - targ&lt;/code&gt;, the target. At the inner layers, it has to use the &lt;code&gt;dWs&lt;/code&gt; bundle it receives from the lower layers to figure it out. &lt;code&gt;dWs&lt;/code&gt; essentially “bubbles up” from the output layer up to the input layer calculations.&lt;/p&gt;
&lt;p&gt;Writing this is a bit of a struggle. I actually implemented this incorrectly several times before writing it as you see here. The type system doesn’t help you like it normally does in Haskell, and you can’t really use parametricity to help you write your code like normal Haskell. Everything is monomorphic, and everything multiplies with everything else. You don’t have any hints about what to multiply with what at any point in time. It’s like all of the bad things mentioned before, but amplified.&lt;/p&gt;
&lt;p&gt;In short, you’re leaving yourself open to many potential bugs…and the compiler doesn’t help you write your code at all! This is the nightmare of every Haskell programmer. There must be a better way!&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;putting-it-to-the-test&quot;&gt;Putting it to the test&lt;/h4&gt;
&lt;p&gt;Pretty much the only way you can verify this code is to test it out on example cases. In the &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs&quot;&gt;source file&lt;/a&gt;, I have &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L128-136&quot;&gt;&lt;code&gt;main&lt;/code&gt;&lt;/a&gt; test out the backprop, training a network on a 2D function that was “on” for two small circles and “off” everywhere else (A nice cute non-linearly-separable function to test our network on). We basically train the network to be able to recognize the two-circle pattern. I implemented a simple printing function and tested the trained network on a grid:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;stack&lt;/span&gt; install hmatrix MonadRandom
$ &lt;span class=&quot;kw&quot;&gt;stack&lt;/span&gt; ghc -- -O2 ./NetworkUntyped.hs
$ &lt;span class=&quot;kw&quot;&gt;./NetworkUntyped&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# Training network...&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#            .=########=&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          .##############.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          ################&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          ################&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          .##############-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#            .###########&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                 ...             ...&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                             -##########.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                           -##############.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                           ################&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                           ################&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                            =############=&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                              .#######=.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not too bad! The network learned to recognize the circles. But, I was basically forced to resort to unit testing to ensure my code was correct. Let’s see if we can do better.&lt;/p&gt;
&lt;h3 id=&quot;the-call-of-types&quot;&gt;The Call of Types&lt;/h3&gt;
&lt;p&gt;Before we go on to the “typed” version of our program, let’s take a step back and look at some big checks you might want to ask yourself after you write code in Haskell.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Are any of my functions either partial or implemented using partial functions?&lt;/li&gt;
&lt;li&gt;How could I have written things that are &lt;em&gt;incorrect&lt;/em&gt;, and yet still type check? Where does the compiler &lt;em&gt;not&lt;/em&gt; help me by restricting my choices?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Both of these questions usually yield some truth about the code you write and the things you should worry about. As a Haskeller, they should always be at the back of your mind!&lt;/p&gt;
&lt;p&gt;Looking back at our untyped implementation, we notice some things:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Literally every single function we wrote is partial. Like, actually.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; If we had passed in the incorrectly sized matrix/vector, or stored mismatched vectors in our network, everything would fall apart.&lt;/li&gt;
&lt;li&gt;There are billions of ways we could have implemented our functions where they would still typechecked. We could multiply mismatched matrices, or forget to multiply a matrix, etc.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;with-static-size-indexed-types&quot;&gt;With Static Size-Indexed Types&lt;/h2&gt;
&lt;h3 id=&quot;networks&quot;&gt;Networks&lt;/h3&gt;
&lt;p&gt;Gauging our potential problems, it seems like the first major class of bugs we can address is improperly sized and incompatible matrices. If the compiler always made sure we used compatible matrices, we can avoid bugs at compile-time, and we also can get a friendly helper when we write programs (by knowing what works with what, and what we need were, and helping us organize our logic)&lt;/p&gt;
&lt;p&gt;Let’s write a &lt;code&gt;Weights&lt;/code&gt; type that tells you the size of its output and the input it expects. Let’s have, say, a &lt;code&gt;Weights 10 5&lt;/code&gt; be a set of weights that takes you from a layer of 10 nodes to a layer of 5 nodes. &lt;code&gt;w :: Weights 4 6&lt;/code&gt; would take you from a layer of 4 nodes to a layer of 6 nodes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L23-25&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; wBiases ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o)
                     ,&lt;span class=&quot;ot&quot;&gt; wNodes  ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;L&lt;/span&gt; o i)
                     }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type constructor &lt;code&gt;Weights&lt;/code&gt; has the kind &lt;code&gt;Weights :: Nat -&amp;gt; Nat -&amp;gt; *&lt;/code&gt; — it takes two types of kind &lt;code&gt;Nat&lt;/code&gt; (from the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-TypeLits.html&quot;&gt;GHC.TypeLits&lt;/a&gt;&lt;/em&gt; module, which the integer type literals give us with &lt;em&gt;&lt;a href=&quot;https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell#type-level-naturals&quot;&gt;DataKinds&lt;/a&gt;&lt;/em&gt; enabled) and returns a &lt;code&gt;*&lt;/code&gt; — a “normal type”.&lt;/p&gt;
&lt;p&gt;We’re using the &lt;em&gt;&lt;a href=&quot;http://mstksg.github.io/hmatrix/Numeric-LinearAlgebra-Static.html&quot;&gt;Numeric.LinearAlgebra.Static&lt;/a&gt;&lt;/em&gt; module from &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/hmatrix&quot;&gt;hmatrix&lt;/a&gt;&lt;/em&gt;, which offers matrix and vector types with their size in their types: an &lt;code&gt;R 5&lt;/code&gt; is a vector of Doubles with 5 elements, and a &lt;code&gt;L 3 6&lt;/code&gt; is a 3x6 vector of Doubles.&lt;/p&gt;
&lt;p&gt;These types are called “dependent” types because the type itself &lt;em&gt;depends&lt;/em&gt; on its value. If an &lt;code&gt;R n&lt;/code&gt; contains a 5-element vector, its type is &lt;code&gt;R 5&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;Static&lt;/em&gt; module in &lt;em&gt;hmatrix&lt;/em&gt; relies on the &lt;a href=&quot;http://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-TypeLits.html#t:KnownNat&quot;&gt;&lt;code&gt;KnownNat&lt;/code&gt;&lt;/a&gt; mechanism that GHC offers. Almost all operations in the library require a &lt;code&gt;KnownNat&lt;/code&gt; constraint on the type-level Nats — for example, you can take the dot product of two vectors with &lt;code&gt;dot :: KnownNat n =&amp;gt; R n -&amp;gt; R n -&amp;gt; Double&lt;/code&gt;. It lets the library use the information in the &lt;code&gt;n&lt;/code&gt; at runtime as an &lt;code&gt;Integer&lt;/code&gt;. (More on this later!)&lt;/p&gt;
&lt;p&gt;Moving on, our network type for this post will be something like &lt;code&gt;Network 10 &#39;[7,5,3] 2&lt;/code&gt;: Take 10 inputs, return 2 outputs — and internally, have hidden layers of size 7, 5, and 3. (The &lt;code&gt;&#39;[7,5,3]&lt;/code&gt; is a type-level list of Nats; the optional &lt;code&gt;&#39;&lt;/code&gt; apostrophe is just for our own benefit to distinguish it from a value-level list of integers.)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L27-34&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;     ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o)
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i &lt;span class=&quot;ch&quot;&gt;&amp;#39;[] o&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    (:&amp;amp;~) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; h
          &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i h)
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; h hs o)
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i (h &lt;span class=&quot;ch&quot;&gt;&amp;#39;: hs) o&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We use GADT syntax here again. The &lt;em&gt;kind signature&lt;/em&gt; of the type constructor means that the &lt;code&gt;Network&lt;/code&gt; type constructor takes three inputs: a &lt;code&gt;Nat&lt;/code&gt; (type-level numeral, like &lt;code&gt;10&lt;/code&gt; or &lt;code&gt;5&lt;/code&gt;), list of &lt;code&gt;Nat&lt;/code&gt;s, and another &lt;code&gt;Nat&lt;/code&gt; (the input, hidden layers, and output sizes). Let’s go over the two constructors.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;O&lt;/code&gt; constructor takes a &lt;code&gt;Weights i o&lt;/code&gt; and returns a &lt;code&gt;Network i &#39;[] o&lt;/code&gt;. That is, if your network is just weights from &lt;code&gt;i&lt;/code&gt; inputs to &lt;code&gt;o&lt;/code&gt; outputs, your network itself just takes &lt;code&gt;i&lt;/code&gt; inputs and returns &lt;code&gt;o&lt;/code&gt; outputs, with no hidden layers.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;(:&amp;amp;~)&lt;/code&gt; constructor takes a &lt;code&gt;Network h hs o&lt;/code&gt; – a network with &lt;code&gt;h&lt;/code&gt; inputs and &lt;code&gt;o&lt;/code&gt; outputs – and “conses” an extra input layer in front. If you give it a &lt;code&gt;Weights i h&lt;/code&gt;, its outputs fit perfectly into the inputs of the subnetwork, and you get a &lt;code&gt;Network i (h &#39;: hs) o&lt;/code&gt;. (&lt;code&gt;(&#39;:)&lt;/code&gt;, or &lt;code&gt;(:)&lt;/code&gt;, is the same as normal &lt;code&gt;(:)&lt;/code&gt;, but is for type-level lists. The apostrophe is optional here too, but it’s just nice to be able to visually distinguish the two)&lt;/p&gt;
&lt;p&gt;We add a &lt;code&gt;KnownNat&lt;/code&gt; constraint on the &lt;code&gt;h&lt;/code&gt;, so that whenever you pattern match on &lt;code&gt;w :&amp;amp;~ net&lt;/code&gt;, you automatically get a &lt;code&gt;KnownNat&lt;/code&gt; constraint for the input size of &lt;code&gt;net&lt;/code&gt; that the &lt;em&gt;hmatrix&lt;/em&gt; library can use.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can still construct them the same way:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- given:&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;ih ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;hh ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;ho ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- we have:&lt;/span&gt;
              &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ho ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[] 2&lt;/span&gt;
       hh &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ho ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[4] 2&lt;/span&gt;
ih &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; hh &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ho ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[7,4] 2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the shape of the constructors requires all of the weight vectors to “fit together”. &lt;code&gt;ih :&amp;amp;~ O ho&lt;/code&gt; would be a type error (feeding a 7-output layer to a 4-input layer). Also, if we ever pattern match on &lt;code&gt;:&amp;amp;~&lt;/code&gt;, we know that the resulting matrices and vectors are compatible!&lt;/p&gt;
&lt;p&gt;One neat thing is that this approach is also self-documenting. I don’t need to specify what the dimensions are in the docs and trust the users to read it and obey it. The types tell them! And if they don’t listen, they get a compiler error! (You should, of course, still provide reasonable documentation. But, in this case, the compiler actually enforces your documentation’s statements!)&lt;/p&gt;
&lt;p&gt;Generating random weights and networks is even nicer now:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L58-65&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomWeights ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
              &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o)
randomWeights &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    s1 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getRandom
&lt;span class=&quot;ot&quot;&gt;    s2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getRandom
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; randomVector  s1 &lt;span class=&quot;dt&quot;&gt;Uniform&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
        wN &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; uniformSample s2 (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice that the &lt;em&gt;Static&lt;/em&gt; versions of &lt;a href=&quot;http://mstksg.github.io/hmatrix/Numeric-LinearAlgebra-Static.html#v:randomVector&quot;&gt;&lt;code&gt;randomVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://mstksg.github.io/hmatrix/Numeric-LinearAlgebra-Static.html#v:uniformSample&quot;&gt;&lt;code&gt;uniformSample&lt;/code&gt;&lt;/a&gt; don’t actually require the size of the vector/matrix you want as an input – they just use &lt;em&gt;type inference&lt;/em&gt; to figure out what size you want! This is the same process that &lt;a href=&quot;http://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; uses to figure out what type of thing you want to return. You would use &lt;code&gt;randomVector s Uniform :: R 10&lt;/code&gt;, and type inference would give you a 10-element vector the same way &lt;code&gt;read &amp;quot;hello&amp;quot; :: Int&lt;/code&gt; would give you an &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It’s important to note that it’s much harder to implement this incorrectly. Before, you could give the matrix the wrong dimensions (maybe you flipped the parameters?), or gave the wrong parameter to the vector generator.&lt;/p&gt;
&lt;p&gt;But here, you are guaranteed/forced to return the correctly sized vectors and matrices. In fact, you &lt;em&gt;don’t even have to worry&lt;/em&gt; about it — it’s handled automatically by the magic of type inference&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;! I consider this a very big victory. One of the whole points of types is to give you less to “worry about”, as a programmer. Here, we completely eliminate an &lt;em&gt;entire dimension&lt;/em&gt; of programmer concern.&lt;/p&gt;
&lt;h4 id=&quot;benefits-to-the-user&quot;&gt;Benefits to the user&lt;/h4&gt;
&lt;p&gt;Not only is this style nicer for you as the implementer, it’s also very beneficial for the &lt;em&gt;user&lt;/em&gt; of the function. Consider looking at the two competing type signatures side-by-side:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;randomWeights ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomWeights ::&lt;/span&gt;               m (&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you want to &lt;em&gt;use&lt;/em&gt; this function, you have to look up some things from the documentation:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;What do the two arguments represent?&lt;/li&gt;
&lt;li&gt;What &lt;em&gt;order&lt;/em&gt; is the function expecting these two arguments?&lt;/li&gt;
&lt;li&gt;What will be the dimension of the result?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These are three things you &lt;em&gt;need&lt;/em&gt; to look up in the documentation. There’s simply no way around it.&lt;/p&gt;
&lt;p&gt;But, here, all of these questions are answered &lt;em&gt;immediately&lt;/em&gt;, just from the type (which you can get from GHC, or from ghci). You don’t need to worry about arguments. You don’t need to worry about what order the function is expecting the arguments to be in. And you already know &lt;em&gt;exactly&lt;/em&gt; what the dimensions of the result is, right in the type.&lt;/p&gt;
&lt;p&gt;I often implement many of my functions in this style, even if the rest of my program isn’t intended to be dependently typed (I can just convert the type to a “dumb” type as soon as I get the result). All of these benefits come even when the caller doesn’t &lt;em&gt;care&lt;/em&gt; at all about dependently typed programming — it’s just a better style of defining functions/offering an API!&lt;/p&gt;
&lt;h3 id=&quot;singletons-and-induction&quot;&gt;Singletons and Induction&lt;/h3&gt;
&lt;p&gt;The code for the updated &lt;code&gt;randomNet&lt;/code&gt; takes a bit of background to understand, so let’s take a quick detour through the concepts of singletons, dependent pattern matching, and induction on dependent data types.&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Let’s say we want to implement an algorithm that can create any &lt;code&gt;Network i hs o&lt;/code&gt;, so that we can construct a &lt;code&gt;Network 4 &#39;[3,2] 1&lt;/code&gt; or something. In true Haskell fashion, we want do this recursively (“inductively”). After all, we know how to make a &lt;code&gt;Network i &#39;[] o&lt;/code&gt; (just &lt;code&gt;O &amp;lt;$&amp;gt; randomWeights&lt;/code&gt;), and we know how to create a &lt;code&gt;Network i (h &#39;: hs) o&lt;/code&gt; if we had a &lt;code&gt;Network h hs o&lt;/code&gt; (just use &lt;code&gt;(:&amp;amp;~)&lt;/code&gt; with &lt;code&gt;randomWeights&lt;/code&gt;). Now all we have to do is just “pattern match” on the type-level list, and…&lt;/p&gt;
&lt;p&gt;Oh wait. We can’t pattern match on types like that in Haskell. This is a consequence of one of Haskell’s fundamental design decisions: types are &lt;strong&gt;erased&lt;/strong&gt; at runtime. We need to have a way to “access” the type (at run-time) as a &lt;em&gt;value&lt;/em&gt; so we can pattern match on it and do things with it.&lt;/p&gt;
&lt;p&gt;In Haskell, the popular way to deal with this is by using &lt;em&gt;singletons&lt;/em&gt; — (parameterized) types which only have valid constructor. The canonical method of working with singletons in Haskell is with the &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/singletons&quot;&gt;singletons&lt;/a&gt;&lt;/em&gt; library, which provides a uniform interface for all sorts of singletons of types you’ll encounter in everyday use.&lt;/p&gt;
&lt;p&gt;We want to “pattern match” on a type-level list, so we want a singleton for lists. The &lt;em&gt;singletons&lt;/em&gt; library provides them:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[]&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; as &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (a &lt;span class=&quot;ch&quot;&gt;&amp;#39;: as)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that if we ever get value of type &lt;code&gt;Sing as&lt;/code&gt; (and &lt;code&gt;as&lt;/code&gt; is a type-level list), we can pattern match on it. If we match on the &lt;code&gt;SNil&lt;/code&gt; constructor, we &lt;em&gt;know&lt;/em&gt; it’s a &lt;code&gt;Sing &#39;[]&lt;/code&gt; in that branch, and if we match on the &lt;code&gt;SCons&lt;/code&gt; constructor, we &lt;em&gt;know&lt;/em&gt; it’s a &lt;code&gt;Sing (a &#39;: as)&lt;/code&gt; – a non-empty list. This is called &lt;em&gt;dependent pattern matching&lt;/em&gt;. Every “branch” of your case statement has a different inferred type of the arguments, depending on the constructor you match on.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; foo &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- here, GHC knows `foo :: Sing &amp;#39;[]`&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt; _ _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- here, GHC knows `foo :: Sing (a &amp;#39;: as)`&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;singletons&lt;/em&gt; actually provides a whole bunch of singleton constructors for different types and kinds, like for &lt;code&gt;Bool&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;True&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SFalse&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(That’s the &lt;em&gt;type&lt;/em&gt; &lt;code&gt;&#39;True&lt;/code&gt;, of &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;Bool&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;So, if we ever are given a &lt;code&gt;Sing b&lt;/code&gt; with some type-level &lt;code&gt;Bool&lt;/code&gt; we don’t know, we can pattern match on it. And in the branch that &lt;code&gt;STrue&lt;/code&gt; matches on, &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;&#39;True&lt;/code&gt;, and in the branch that &lt;code&gt;SFalse&lt;/code&gt; matches on, &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Singletons give us a way to pattern match on types by having an actual term-level value we can pattern match on. So, we &lt;em&gt;could&lt;/em&gt; implement:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;randomNet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
          &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; hs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And &lt;code&gt;randomNet&lt;/code&gt; gets to directly pattern match and deconstruct on &lt;code&gt;Sing hs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, for actual API’s, it’s often more convenient to &lt;em&gt;not&lt;/em&gt; require the extra parameter, and have it be “inferred” in the way we’ve been doing it before. That way the &lt;em&gt;user&lt;/em&gt; doesn’t have the burden of supplying it. The &lt;em&gt;singletons&lt;/em&gt; library offers a typeclass we can use to implicitly conjure up values of a singleton type – &lt;code&gt;SingI&lt;/code&gt;. We can use &lt;code&gt;sing :: SingI s =&amp;gt; Sing s&lt;/code&gt; to generate the “inferred” singleton:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; sing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[]&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; sing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;True&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; sing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[&amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;ch&quot;&gt;&amp;#39;False, &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;]
&lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SFalse&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So if you have a function &lt;code&gt;SingI hs =&amp;gt; ...&lt;/code&gt;, it’s really no different than &lt;code&gt;Sing hs -&amp;gt; ...&lt;/code&gt;. The function itself gets to use a &lt;code&gt;Sing hs&lt;/code&gt; either way … but for the first, the argument is implicit.&lt;/p&gt;
&lt;p&gt;The final piece of the puzzle is the singleton for a type-level &lt;code&gt;Nat&lt;/code&gt;. It’s a little different because when you pattern match on it, instead of directly learning about the type, you “receive” a &lt;code&gt;KnownNat&lt;/code&gt; instance you can use.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- `foo :: Sing n`, but we don&amp;#39;t know what `n` it is&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; foo &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- in this branch, we have a `KnownNat n` instance&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Essentially, the data constructor comes “packaged” with a &lt;code&gt;KnownNat n&lt;/code&gt; instance. The &lt;em&gt;creation&lt;/em&gt; of &lt;code&gt;SNat :: Sing n&lt;/code&gt; requires the presence of &lt;code&gt;KnownNat n&lt;/code&gt;. So if you ever pattern match on a validly created &lt;code&gt;SNat&lt;/code&gt;, the fact that that &lt;code&gt;SNat&lt;/code&gt; constructor even exists (instead of, say, being &lt;code&gt;undefined&lt;/code&gt;) is a &lt;em&gt;witness&lt;/em&gt; to that very &lt;code&gt;KnownNat&lt;/code&gt; instance, and the type system lets us use this. It’s as if you “pattern match” out the instance itself, like any other value the constructor might have.&lt;/p&gt;
&lt;p&gt;Now we have enough pieces of the puzzle:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L67-76&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomNet ::&lt;/span&gt; forall m i hs o&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; hs, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
          &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o)
randomNet &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go sing
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    go ::&lt;/span&gt; forall h hs&amp;#39;&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; h
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; hs&amp;#39;
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; h hs&amp;#39; o)
    go hs &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; hs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
              &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;            &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;     &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights
              &lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; ss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; go ss&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The real heavy lifting is done by &lt;code&gt;go&lt;/code&gt;, which takes the singleton structure it needs and recursively calls it until it reaches the base case (&lt;code&gt;SNil&lt;/code&gt;, an output layer). We just call &lt;code&gt;go sing&lt;/code&gt; to give it the initial structure it needs. Note there, &lt;code&gt;sing :: Sing hs&lt;/code&gt;, but this is inferred, because &lt;code&gt;go&lt;/code&gt; is &lt;code&gt;Sing hs -&amp;gt; Network i hs o&lt;/code&gt;, and it’s being asked to return a &lt;code&gt;Network i hs o&lt;/code&gt;, so it’s safely inferable that we want &lt;code&gt;Sing hs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Remember that we can write &lt;code&gt;O &amp;lt;$&amp;gt; randomWeights&lt;/code&gt; because &lt;code&gt;randomWeights&lt;/code&gt;, like &lt;code&gt;read&lt;/code&gt;, adapts to whatever type we want from it — in this case, we ask for a &lt;code&gt;Weights h o&lt;/code&gt;, and type inference is the real hero.&lt;/p&gt;
&lt;p&gt;When possible, we like to write functions like &lt;code&gt;go&lt;/code&gt; that take &lt;em&gt;explicit&lt;/em&gt; singletons. In a lot of situations, we’ll actually write our internal &lt;em&gt;logic&lt;/em&gt; itself using explicit singletons, and only use &lt;code&gt;SingI&lt;/code&gt; and implicit singletons at the &lt;em&gt;external&lt;/em&gt; boundaries of our API (like &lt;code&gt;randomNet&lt;/code&gt;) for convenience to the user.&lt;/p&gt;
&lt;p&gt;We’ve stumbled upon common pattern in dependent Haskell: “building up” a value-level singleton &lt;em&gt;structure&lt;/em&gt; from a type that we want (either explicitly given as an argument, or provided through a typeclass like &lt;code&gt;SingI&lt;/code&gt;) and then inductively piggybacking on that structure’s constructors to build the thing you &lt;em&gt;really&lt;/em&gt; want (called “elimination”). Here, we use &lt;code&gt;SingI hs&lt;/code&gt; to build our &lt;code&gt;NatList hs&lt;/code&gt; structure, and use/“eliminate” that structure to create our &lt;code&gt;Network i hs o&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;on-typeclasses-and-dictionaries&quot;&gt;On Typeclasses and Dictionaries&lt;/h4&gt;
&lt;p&gt;One of the more bizarre things here, to me, is that &lt;code&gt;SNat&lt;/code&gt; somehow gave us a &lt;code&gt;KnownNat n&lt;/code&gt; instance that we can use and pass off to &lt;code&gt;randomWeights&lt;/code&gt;. However, once you realize that typeclasses in Haskell really aren’t any more than a way to pass in implicit arguments, it starts to make sense.&lt;/p&gt;
&lt;p&gt;The only thing you can really do from a &lt;code&gt;KnownNat&lt;/code&gt; is to get an &lt;code&gt;Integer&lt;/code&gt; from it with &lt;code&gt;natVal&lt;/code&gt;. So really, &lt;code&gt;KnownNat n =&amp;gt; ...&lt;/code&gt; is more or less the same as &lt;code&gt;Integer -&amp;gt; ...&lt;/code&gt;. That’s right — at runtime, a &lt;code&gt;KnownNat n&lt;/code&gt; constraint is more or less just an &lt;code&gt;Integer&lt;/code&gt; that GHC passes around automatically for you, to save you the hassle of manually passing it in yourself. (We say that the “dictionary” of &lt;code&gt;KnownNat&lt;/code&gt; is &lt;code&gt;Integer&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;So, the constructor:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Is really &lt;em&gt;kind&lt;/em&gt; of like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n
&lt;span class=&quot;co&quot;&gt;-- or, in normal data type notation&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- kinda!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The GADT constructor for &lt;code&gt;SNat&lt;/code&gt; requires a &lt;code&gt;KnownNat n&lt;/code&gt; instance in scope to produce. That instance is essentially stored inside the constructor (as if it were just an &lt;code&gt;Integer&lt;/code&gt;). Then, later, when you pattern match on it, you pattern match out the instance that was originally put in there, and you can use it!&lt;/p&gt;
&lt;p&gt;So what’s the big deal, why not just ditch &lt;code&gt;KnownNat&lt;/code&gt; and just pass around integers? The difference is that GHC and the compiler can now &lt;em&gt;track&lt;/em&gt; these at compile-time to give you &lt;em&gt;checks&lt;/em&gt; on how your Nat’s act together on the type level, allowing it to catch mismatches with compile-time checks instead of run-time checks.&lt;/p&gt;
&lt;h3 id=&quot;running-with-it&quot;&gt;Running with it&lt;/h3&gt;
&lt;p&gt;So now, you can use &lt;code&gt;randomNet :: IO (Network 5 &#39;[4,3] 2)&lt;/code&gt; to get a random network of the desired dimensions! (&lt;code&gt;IO&lt;/code&gt; is an instance of &lt;code&gt;MonadRandom&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;Can we just pause right here to just appreciate how awesome it is that we can generate random networks of whatever size we want by &lt;em&gt;just requesting something by its type&lt;/em&gt;? Our implementation is also &lt;em&gt;guaranteed&lt;/em&gt; to have the right sized matrices — no worrying about using the right size parameters for the right matrix in the right order. GHC does it for you automatically! And, for the person who &lt;em&gt;uses&lt;/em&gt; &lt;code&gt;randomNet&lt;/code&gt;, they don’t have to bungle around with figuring out what function argument indicates what, and in what order, and they don’t have to play a guessing game about the shape of the returned matrix.&lt;/p&gt;
&lt;p&gt;The code for &lt;em&gt;running&lt;/em&gt; the nets is actually literally identical from before:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L44-56&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;runLayer ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
         &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o
         &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; i
         &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o
runLayer (&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN) v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; v

&lt;span class=&quot;ot&quot;&gt;runNet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; i
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o
runNet (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w)      &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic (runLayer w v)
runNet (w &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39;) &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic (runLayer w v)
                       &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  runNet n&amp;#39; v&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But now, we get the assurance that the matrices and vectors all fit each-other, at compile-time. GHC basically writes our code for us. The operations all demand vectors and matrices that “fit together”, so you can only ever multiply a matrix by a properly sized vector.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;(+)  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n
     &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n
&lt;span class=&quot;ot&quot;&gt;(#&amp;gt;) ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; m)
     &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;L&lt;/span&gt; n m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n

&lt;span class=&quot;ot&quot;&gt;logistic ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n
         &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The source code is the same from before, so there isn’t any extra overhead in annotation. The correctness proofs and guarantees basically come without any extra work — they’re free!&lt;/p&gt;
&lt;p&gt;Our back-prop algorithm is ported pretty nicely too:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L78-118&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;train ::&lt;/span&gt; forall i hs o&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
      &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- ^ learning rate&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; i              &lt;span class=&quot;co&quot;&gt;-- ^ input vector&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o              &lt;span class=&quot;co&quot;&gt;-- ^ target vector&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o   &lt;span class=&quot;co&quot;&gt;-- ^ network to train&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o
train rate x0 target &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fst &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; go x0
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    go  ::&lt;/span&gt; forall j js&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; j
        &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; j              &lt;span class=&quot;co&quot;&gt;-- ^ input vector&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; j js o   &lt;span class=&quot;co&quot;&gt;-- ^ network to train&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; j js o, &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; j)
    &lt;span class=&quot;co&quot;&gt;-- handle the output layer&lt;/span&gt;
    go &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;x (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN))
        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runLayer w x
              o    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic y
              &lt;span class=&quot;co&quot;&gt;-- the gradient (how much y affects the error)&lt;/span&gt;
              &lt;span class=&quot;co&quot;&gt;--   (logistic&amp;#39; is the derivative of logistic)&lt;/span&gt;
              dEdy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic&amp;#39; y &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; (o &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; target)
              &lt;span class=&quot;co&quot;&gt;-- new bias weights and node weights&lt;/span&gt;
              wB&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; konst rate &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; dEdy
              wN&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; konst rate &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; (dEdy &lt;span class=&quot;ot&quot;&gt;`outer`&lt;/span&gt; x)
              w&amp;#39;   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB&amp;#39; wN&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- bundle of derivatives for next step&lt;/span&gt;
              dWs  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; tr wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; dEdy
          &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w&amp;#39;, dWs)
    &lt;span class=&quot;co&quot;&gt;-- handle the inner layers&lt;/span&gt;
    go &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;x (w&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN) &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n)
        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runLayer w x
              o          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic y
              &lt;span class=&quot;co&quot;&gt;-- get dWs&amp;#39;, bundle of derivatives from rest of the net&lt;/span&gt;
              (n&amp;#39;, dWs&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go o n
              &lt;span class=&quot;co&quot;&gt;-- the gradient (how much y affects the error)&lt;/span&gt;
              dEdy       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic&amp;#39; y &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; dWs&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- new bias weights and node weights&lt;/span&gt;
              wB&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; konst rate &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; dEdy
              wN&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; konst rate &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; (dEdy &lt;span class=&quot;ot&quot;&gt;`outer`&lt;/span&gt; x)
              w&amp;#39;   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB&amp;#39; wN&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- bundle of derivatives for next step&lt;/span&gt;
              dWs  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; tr wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; dEdy
          &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (w&amp;#39; &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39;, dWs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It’s pretty much again almost an exact copy-and-paste, but now with GHC checking to make sure everything fits together in our implementation.&lt;/p&gt;
&lt;p&gt;One thing that’s hard for me to convey here without walking through the implementation step-by-step is how much the types &lt;em&gt;help you&lt;/em&gt; in writing this code.&lt;/p&gt;
&lt;p&gt;Before starting writing a back-prop implementation without the help of types, I’d probably be a bit concerned. I mentioned earlier that writing the untyped version was no fun at all. But, with the types, writing the implementation became a &lt;em&gt;joy&lt;/em&gt; again. And, you have the help of &lt;em&gt;hole driven development&lt;/em&gt;, too.&lt;/p&gt;
&lt;p&gt;If you need, say, an &lt;code&gt;R n&lt;/code&gt;, there might be only one way get it! And if you have something that you need to combine with something you don’t know about, you can use typed holes (&lt;code&gt;_&lt;/code&gt;) and GHC will give you a list of all the values you have in scope that can fit there. Your programs basically write themselves!&lt;/p&gt;
&lt;p&gt;The more you can restrict the implementations of your functions with your types, the more of a joy programming in Haskell is. Things fit together and fall together before your eyes…and the best part is that if they’re wrong, the compiler will nudge you gently into the correct direction.&lt;/p&gt;
&lt;p&gt;The most stressful part of programming happens when you have to tenuously hold a complex and fragile network of ideas and constraints in your brain, and any slight distraction or break in focus causes everything to crash down in your mind. Over time, people have begun to believe that this is “normal” in programming. Don’t believe this lie — it’s &lt;em&gt;not&lt;/em&gt;! A good programming experience involves maintaining as &lt;em&gt;little&lt;/em&gt; in your head as possible, and letting the compiler handle remembering/checking the rest.&lt;/p&gt;
&lt;h4 id=&quot;the-final-test&quot;&gt;The final test&lt;/h4&gt;
&lt;p&gt;You can download the &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs&quot;&gt;typed network&lt;/a&gt; source code and run it yourself. Again, the &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L153-161&quot;&gt;&lt;code&gt;main&lt;/code&gt;&lt;/a&gt; method is written identically to that of the other file and tests the identical function.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;stack&lt;/span&gt; install hmatrix MonadRandom singletons
$ &lt;span class=&quot;kw&quot;&gt;stack&lt;/span&gt; ghc -- -O2 ./NetworkTyped.hs
$ &lt;span class=&quot;kw&quot;&gt;./NetworkTyped&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# Training network...&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#             -#########-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#           -#############=&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          -###############-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          =###############=&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#           ##############=.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#            .##########=.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                               .==#=-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                            -###########-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                           =##############.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                          .###############=&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                           =##############-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                            =############-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                              -######=-.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;finding-something-to-depend-on&quot;&gt;Finding Something to Depend on&lt;/h2&gt;
&lt;p&gt;We wrote out an initial “non-typed” implementation and recognized a lot red flags that you might already be trained to recognize if you have been programming Haskell for a while: &lt;em&gt;partial functions&lt;/em&gt; and &lt;em&gt;multiple potential implementations&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We followed our well-tuned Haskell guts, listened to our hearts, and introduced extra power in our types to remove all partial functions and eliminate &lt;em&gt;most&lt;/em&gt; potential implementations (though not all, yet — there are more gains to be made from pulling in more parametric polymorphism).&lt;/p&gt;
&lt;p&gt;Though we might have been able to find the bugs we avoided “eventually”, we were able to remove entire &lt;em&gt;dimensions&lt;/em&gt; of programmer concern and also leverage parametric polymorphism to help write our programs for us. We found joy again in programming.&lt;/p&gt;
&lt;p&gt;In the process, however, we encountered some unexpected resistance from Haskell (the language). We couldn’t directly pattern match on our types, so we ended up playing games with singletons and GADT constructors to pass instances.&lt;/p&gt;
&lt;p&gt;In practice, using types as powerful and descriptive as these begin to require a whole new set of tools once you get past the simplest use cases here. For example, our &lt;code&gt;Network&lt;/code&gt; types so far required you to specify their size in the program itself (&lt;code&gt;Network 2 &#39;[16, 8] 1&lt;/code&gt; in the example source code, for instance). But what if we wanted to generate a network that has runtime-determined size (For example, getting the size from user input)? What if we wanted to load a pre-trained network whose size we don’t know? How can we manipulate our networks in a “dynamic” and generic way that still gives us all of the benefits of type-safe programming? We’ll found out next post!&lt;/p&gt;
&lt;p&gt;What we’re looking at here is a world where &lt;em&gt;types&lt;/em&gt; can depend on run-time values … and values can depend on types. A world where types can be returned from functions and where types become as much of a manipulatable citizen of as values are.&lt;/p&gt;
&lt;p&gt;The art of working with types like this is &lt;em&gt;dependently typed programming&lt;/em&gt;. We’re going to feel a bit of push back from Haskell at first, but after we hit our stride and tame the tools we need, we’re going to open up a whole new world of potential!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;This sentence is the story of my Haskell life.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;Okay, maybe not &lt;em&gt;literally&lt;/em&gt; every one. But, pretty much every one.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;Thank you based Hindley-Milner.&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;This entire section was previously written to use the &lt;a href=&quot;http://hackage.haskell.org/package/typelits-witnesses&quot;&gt;typelits-witnesses&lt;/a&gt; library, but has now been re-written to use the canonical &lt;a href=&quot;https://hackage.haskell.org/package/singletons&quot;&gt;singletons&lt;/a&gt; library after a &lt;a href=&quot;https://www.reddit.com/r/haskell/comments/4l199z/practical_dependent_types_in_haskell_type_safe/d3jkslv&quot;&gt;conversation&lt;/a&gt; with Andras Kovacs. The &lt;a href=&quot;https://github.com/mstksg/inCode/blob/697c1f726b9ab9c3f9830ed5521bfeee6ec10727/entry/practical-dependent-types-in-haskell-1.md#singletons-and-induction&quot;&gt;old version&lt;/a&gt; is still online at github, if you want to look at it or compare!&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html</guid><pubDate>Wed, 25 May 2016 18:46:21 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings</dc:subject><dc:date>2016-05-25</dc:date></item><item><title>Automatic Propagation of Uncertainty with AD</title><link>https://blog.jle.im/entry/automatic-propagation-of-uncertainty-with-ad.html</link><description>&lt;blockquote&gt;
&lt;p&gt;This post and &lt;a href=&quot;https://blog.jle.im/entries/series/+uncertain.html&quot;&gt;series&lt;/a&gt; is a walk-through of the implementation of my &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/uncertain&quot;&gt;uncertain&lt;/a&gt;&lt;/em&gt; library, now on hackage!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Some of my favorite Haskell “tricks” involve working with exotic numeric types with custom “overloaded” numeric functions and literals that let us work with data in surprisingly elegant and expressive ways.&lt;/p&gt;
&lt;p&gt;Here is one example — from my work in experimental physics and statistics, we often deal with experimental/sampled values with inherent uncertainty. If you ever measure something to be &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?12.3%5C%2C%5Cmathrm%7Bcm%7D&quot; alt=&quot;12.3\,\mathrm{cm}&quot; title=&quot;12.3\,\mathrm{cm}&quot; /&gt;, that doesn’t mean it’s &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?12.300000%5C%2C%5Cmathrm%7Bcm%7D&quot; alt=&quot;12.300000\,\mathrm{cm}&quot; title=&quot;12.300000\,\mathrm{cm}&quot; /&gt; — it means that it’s somewhere between &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?12.2%5C%2C%5Cmathrm%7Bcm%7D&quot; alt=&quot;12.2\,\mathrm{cm}&quot; title=&quot;12.2\,\mathrm{cm}&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?12.4%5C%2C%5Cmathrm%7Bcm%7D&quot; alt=&quot;12.4\,\mathrm{cm}&quot; title=&quot;12.4\,\mathrm{cm}&quot; /&gt;…and we don’t know exactly. We can write it as &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?12.3%20%5Cpm%200.1%5C%2C%5Cmathrm%7Bcm%7D&quot; alt=&quot;12.3 \pm 0.1\,\mathrm{cm}&quot; title=&quot;12.3 \pm 0.1\,\mathrm{cm}&quot; /&gt;. The interesting thing happens when we try to add, multiply, divide numbers with uncertainty. What happens when you “add” &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?12%20%5Cpm%203&quot; alt=&quot;12 \pm 3&quot; title=&quot;12 \pm 3&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?19%20%5Cpm%206&quot; alt=&quot;19 \pm 6&quot; title=&quot;19 \pm 6&quot; /&gt;?&lt;/p&gt;
&lt;p&gt;The initial guess might be &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?31%20%5Cpm%209&quot; alt=&quot;31 \pm 9&quot; title=&quot;31 \pm 9&quot; /&gt;, because one is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cpm%203&quot; alt=&quot;\pm 3&quot; title=&quot;\pm 3&quot; /&gt; and the other is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cpm%206&quot; alt=&quot;\pm 6&quot; title=&quot;\pm 6&quot; /&gt;. But! If you actually do experiments like this several times, you’ll see that this isn’t the case. If you tried this out experimentally and simulate several hundred trials, you’ll see that the answer is actually something like &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?31%20%5Cpm%207&quot; alt=&quot;31 \pm 7&quot; title=&quot;31 \pm 7&quot; /&gt;. (We’ll explain why later, but feel free to stop reading this article now and try this out yourself!&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Let’s write ourselves a Haskell data type that lets us work with “numbers with inherent uncertainty”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;14.6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.8&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;   &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y
&lt;span class=&quot;dv&quot;&gt;46&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y
&lt;span class=&quot;dv&quot;&gt;450&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;40&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; sqrt (x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y)
&lt;span class=&quot;fl&quot;&gt;6.8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; logBase y x
&lt;span class=&quot;fl&quot;&gt;0.78&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.02&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; log (x&lt;span class=&quot;fu&quot;&gt;**&lt;/span&gt;y)
&lt;span class=&quot;fl&quot;&gt;85.9&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Along the way, we’ll also learn how to harness the power of awesome &lt;a href=&quot;https://hackage.haskell.org/package/ad&quot;&gt;ad&lt;/a&gt; library, a library used in implementing back-propagation and other optimization algorithms, to analyze numerical functions in a mathematical way and break down their derivatives and gradients.&lt;/p&gt;
&lt;p&gt;You can follow along with &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs&quot;&gt;the source code&lt;/a&gt;, which is actually a &lt;em&gt;&lt;a href=&quot;http://www.haskellstack.org&quot;&gt;stack&lt;/a&gt;&lt;/em&gt; executable! If you download the source and you have &lt;em&gt;&lt;a href=&quot;http://www.haskellstack.org&quot;&gt;stack&lt;/a&gt;&lt;/em&gt; installed, you can run it (and run the tests above) as an executable:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;./Uncertain.hs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Otherwise, you can run it directly with stack (using &lt;code&gt;runhaskell&lt;/code&gt;) and the &lt;a href=&quot;shttp://hackage.haskell.org/package/linear/docs/Linear-V2.html&quot;&gt;linear&lt;/a&gt; and &lt;a href=&quot;https://hackage.haskell.org/package/ad&quot;&gt;ad&lt;/a&gt; packages installed…or load it up with &lt;code&gt;stack ghci&lt;/code&gt; to play with it. If you want to be sure to reproduce the behavior, this article was written under &lt;a href=&quot;https://www.stackage.org/&quot;&gt;stackage&lt;/a&gt; snapshot &lt;a href=&quot;https://www.stackage.org/lts-5.15&quot;&gt;lts-5.15&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;dealing-with-uncertainty-precisely&quot;&gt;Dealing with Uncertainty Precisely&lt;/h2&gt;
&lt;p&gt;First of all, let’s think about why adding two “uncertain” values doesn’t involve simply adding the uncertainties linearly. (If you don’t care about the math and just want to get on to the Haskell, feel free to skip this section!)&lt;/p&gt;
&lt;p&gt;If I have a value &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?16%20%5Cpm%203&quot; alt=&quot;16 \pm 3&quot; title=&quot;16 \pm 3&quot; /&gt; (maybe I have a ruler whose ticks are 3 units apart, or an instrument that produces measurements with 3 units of noise), it either means that it’s a little below 16 or a little above 16. If I have an independently sampled value &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?25%20%5Cpm%204&quot; alt=&quot;25 \pm 4&quot; title=&quot;25 \pm 4&quot; /&gt;, it means that it’s a little below 25 or a little above 25.&lt;/p&gt;
&lt;p&gt;What happens if I want to think about their sum? Well, it’s going to be somewhere around 41. But, the uncertainty won’t be &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cpm%207&quot; alt=&quot;\pm 7&quot; title=&quot;\pm 7&quot; /&gt;. It would only be &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cpm%207&quot; alt=&quot;\pm 7&quot; title=&quot;\pm 7&quot; /&gt; if the errors in the two values are &lt;em&gt;always aligned&lt;/em&gt;. Only if or when every “little bit above” 16 error lines up perfectly with a “little bit above” 25 error, and when every single “little bit below” 16 error lines up perfectly with a “little bit above” 25 error, would you really get something that is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cpm%207&quot; alt=&quot;\pm 7&quot; title=&quot;\pm 7&quot; /&gt;. But, because the two values are sampled independently, you shouldn’t expect such alignment. So, you’ll get an uncertainty that’s &lt;em&gt;less than&lt;/em&gt; &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cpm%207&quot; alt=&quot;\pm 7&quot; title=&quot;\pm 7&quot; /&gt;. In fact, it’ll actually be around &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cpm%205&quot; alt=&quot;\pm 5&quot; title=&quot;\pm 5&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;In general, we find that for &lt;em&gt;independent&lt;/em&gt; &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?X&quot; alt=&quot;X&quot; title=&quot;X&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?Y&quot; alt=&quot;Y&quot; title=&quot;Y&quot; /&gt;:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Coperatorname%7BVar%7D%5BaX%20%2B%20bY%20%2B%20c%5D%20%3D%20a%5E2%20%5Csigma_X%5E2%20%2B%20b%5E2%20%5Csigma_Y%5E2%0A&quot; alt=&quot;
\operatorname{Var}[aX + bY + c] = a^2 \sigma_X^2 + b^2 \sigma_Y^2
&quot; title=&quot;
\operatorname{Var}[aX + bY + c] = a^2 \sigma_X^2 + b^2 \sigma_Y^2
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Csigma_X%5E2&quot; alt=&quot;\sigma_X^2&quot; title=&quot;\sigma_X^2&quot; /&gt; is the variance in &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?X&quot; alt=&quot;X&quot; title=&quot;X&quot; /&gt;. We consider &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Csigma_X&quot; alt=&quot;\sigma_X&quot; title=&quot;\sigma_X&quot; /&gt; to be the standard deviation of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?X&quot; alt=&quot;X&quot; title=&quot;X&quot; /&gt;, or the “plus or minus” part of our numbers. In the simple case of addition, we have &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Coperatorname%7BVar%7D%5BX%20%2B%20Y%5D%20%3D%20%5Csigma_X%5E2%20%2B%20%5Csigma_Y%5E2&quot; alt=&quot;\operatorname{Var}[X + Y] = \sigma_X^2 + \sigma_Y^2&quot; title=&quot;\operatorname{Var}[X + Y] = \sigma_X^2 + \sigma_Y^2&quot; /&gt;, so our new uncertainty is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Csqrt%7B%5Csigma_X%5E2%20%2B%20%5Csigma_Y%5E2%7D&quot; alt=&quot;\sqrt{\sigma_X^2 + \sigma_Y^2}&quot; title=&quot;\sqrt{\sigma_X^2 + \sigma_Y^2}&quot; /&gt;.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;However, not all functions that combine &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?X&quot; alt=&quot;X&quot; title=&quot;X&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?Y&quot; alt=&quot;Y&quot; title=&quot;Y&quot; /&gt; can be expressed as simple linear combinations &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?aX%20%2B%20bY%20%2B%20c&quot; alt=&quot;aX + bY + c&quot; title=&quot;aX + bY + c&quot; /&gt;. But! If you dig back to your days of high school calculus, you might remember a method for expressing any arbitrary function as a linear approximation – the &lt;a href=&quot;https://en.wikipedia.org/wiki/Taylor_series&quot;&gt;Taylor Expansion&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;In general, we can attempt to approximate any well-behaving function around a point as its tangent hyperplane:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0Af%28x_0%20%2B%20x%2C%20y_0%20%2B%20y%29%20%5Capprox%20f_x%28x_0%2C%20y_0%29%20x%20%2B%20f_y%28x_0%2C%20y_0%29%20y%20%2B%20f%28x_0%2C%20y_0%29%0A&quot; alt=&quot;
f(x_0 + x, y_0 + y) \approx f_x(x_0, y_0) x + f_y(x_0, y_0) y + f(x_0, y_0)
&quot; title=&quot;
f(x_0 + x, y_0 + y) \approx f_x(x_0, y_0) x + f_y(x_0, y_0) y + f(x_0, y_0)
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f_x%28x_0%2Cy_0%29&quot; alt=&quot;f_x(x_0,y_0)&quot; title=&quot;f_x(x_0,y_0)&quot; /&gt; is the first (partial) derivative with respect to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?x&quot; alt=&quot;x&quot; title=&quot;x&quot; /&gt; at &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%28x_0%2C%20y_0%29&quot; alt=&quot;(x_0, y_0)&quot; title=&quot;(x_0, y_0)&quot; /&gt;. This gives us an approximation of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f&quot; alt=&quot;f&quot; title=&quot;f&quot; /&gt; at locations close to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%28x_0%2C%20y_0%29&quot; alt=&quot;(x_0, y_0)&quot; title=&quot;(x_0, y_0)&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;Look familiar? This is exactly the form that we used earlier to calculate “combined” variance! If we approximate the functions around &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%28%5Cmu_X%2C%20%5Cmu_Y%29&quot; alt=&quot;(\mu_X, \mu_Y)&quot; title=&quot;(\mu_X, \mu_Y)&quot; /&gt;, the center/expected value of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?X&quot; alt=&quot;X&quot; title=&quot;X&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?Y&quot; alt=&quot;Y&quot; title=&quot;Y&quot; /&gt;, we see:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Coperatorname%7BVar%7D%5Bf%28X%2CY%29%5D%20%5Capprox%20f_x%28%5Cmu_X%2C%20%5Cmu_Y%29%5E2%20%5Csigma_X%5E2%20%2B%20f_y%28%5Cmu_X%2C%5Cmu_Y%29%5E2%20%5Csigma_Y%5E2%0A&quot; alt=&quot;
\operatorname{Var}[f(X,Y)] \approx f_x(\mu_X, \mu_Y)^2 \sigma_X^2 + f_y(\mu_X,\mu_Y)^2 \sigma_Y^2
&quot; title=&quot;
\operatorname{Var}[f(X,Y)] \approx f_x(\mu_X, \mu_Y)^2 \sigma_X^2 + f_y(\mu_X,\mu_Y)^2 \sigma_Y^2
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;A similar analysis can be used to figure out how the expected value changes by taking the taylor expansion to the &lt;em&gt;second&lt;/em&gt; degree:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Coperatorname%7BE%7D%5Bf%28X%2CY%29%5D%20%5Capprox%0Af%28%5Cmu_X%2C%20%5Cmu_Y%29%20%2B%20%5Cfrac%7B1%7D%7B2%7D%0A%5Cleft%5B%20f_%7Bxx%7D%28%5Cmu_X%2C%20%5Cmu_Y%29%20%5Csigma_X%5E2%20%2B%20f_%7Byy%7D%28%5Cmu_X%2C%20%5Cmu_Y%29%20%5Csigma_Y%5E2%20%5Cright%5D%0A&quot; alt=&quot;
\operatorname{E}[f(X,Y)] \approx
f(\mu_X, \mu_Y) + \frac{1}{2}
\left[ f_{xx}(\mu_X, \mu_Y) \sigma_X^2 + f_{yy}(\mu_X, \mu_Y) \sigma_Y^2 \right]
&quot; title=&quot;
\operatorname{E}[f(X,Y)] \approx
f(\mu_X, \mu_Y) + \frac{1}{2}
\left[ f_{xx}(\mu_X, \mu_Y) \sigma_X^2 + f_{yy}(\mu_X, \mu_Y) \sigma_Y^2 \right]
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f_%7Bxx%7D%28%5Cmu_X%2C%20%5Cmu_Y%29&quot; alt=&quot;f_{xx}(\mu_X, \mu_Y)&quot; title=&quot;f_{xx}(\mu_X, \mu_Y)&quot; /&gt; is the second (partial) derivative with respect to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?x&quot; alt=&quot;x&quot; title=&quot;x&quot; /&gt; twice at &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%28%5Cmu_X%2C%20%5Cmu_Y%29&quot; alt=&quot;(\mu_X, \mu_Y)&quot; title=&quot;(\mu_X, \mu_Y)&quot; /&gt;&lt;/p&gt;
&lt;p&gt;For our case of simple addition, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Coperatorname%7BE%7D%5BX%20%2B%20Y%5D%20%3D%20%5Cmu_X%20%2B%20%5Cmu_Y&quot; alt=&quot;\operatorname{E}[X + Y] = \mu_X + \mu_Y&quot; title=&quot;\operatorname{E}[X + Y] = \mu_X + \mu_Y&quot; /&gt;, because the second-order partials of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f%28x%2Cy%29%20%3D%20x%20%2B%20y&quot; alt=&quot;f(x,y) = x + y&quot; title=&quot;f(x,y) = x + y&quot; /&gt; are 0.&lt;/p&gt;
&lt;h2 id=&quot;uncertain-values-in-haskell&quot;&gt;Uncertain Values in Haskell&lt;/h2&gt;
&lt;p&gt;So, how are we going to model our uncertain values in Haskell … ? With an Algebraic Data Type, of course!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L18-20&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; uMean ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;a
                   ,&lt;span class=&quot;ot&quot;&gt; uVar  ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;a
                   }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We’ll keep track of the mean (the central point) and the &lt;em&gt;variance&lt;/em&gt;, which is the standard deviation &lt;em&gt;squared&lt;/em&gt;. We keep track of the variance and not the standard deviation (the “plus or minus”) because the mathematics is a bit more straightforward.&lt;/p&gt;
&lt;p&gt;We can write a function to turn a “plus or minus” statement into an &lt;code&gt;Uncert&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L22-23&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;(+/-) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
x &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; dx &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x (dx&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;dx)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Give the &lt;code&gt;dx&lt;/code&gt; (the standard deviation) and store &lt;code&gt;dx^2&lt;/code&gt;, the variance.&lt;/p&gt;
&lt;p&gt;Let’s also throw in a handy helper function for “exact” values:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L25-26&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;exact ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
exact x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But, we can do better (if just for fun). We can use pattern synonyms to basically “abstract” away the data type itself, and let people pattern match on a mean and standard deviation:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L28-31&lt;/span&gt;
pattern&lt;span class=&quot;ot&quot;&gt; (:+/-) ::&lt;/span&gt; () &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Floating&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
pattern x &lt;span class=&quot;fu&quot;&gt;:+/-&lt;/span&gt; dx &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x (sqrt&lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;dx)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    x &lt;span class=&quot;fu&quot;&gt;:+/-&lt;/span&gt; dx &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x (dx&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;dx)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, people can pattern match on &lt;code&gt;x :+/- dx&lt;/code&gt; and receive the mean and uncertainty directly. Neat!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L33-34&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;uStdev ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Floating&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
uStdev (_ &lt;span class=&quot;fu&quot;&gt;:+/-&lt;/span&gt; dx) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;making-it-numeric&quot;&gt;Making it Numeric&lt;/h3&gt;
&lt;p&gt;Now, time for the magic! Let’s write a &lt;code&gt;Num&lt;/code&gt; instance!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fromIntegral      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; exact &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromIntegral
    &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y)    (vx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; vy)
    &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; y)    (vx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; vy)
    &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y)    (y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vy)
    negate (&lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (negate x) vx
    &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…that’s it! Do the same thing for every numeric typeclass, and you get automatic propagation of uncertainty.&lt;/p&gt;
&lt;h3 id=&quot;the-problem&quot;&gt;The Problem&lt;/h3&gt;
&lt;p&gt;But, wait — this method is definitely not ideal. It’s pretty repetitive, and involves a but of copy-and-pasting code that is slightly different in ways the typechecker can’t verify. What if we didn’t change something we were supposed to? And, if you look at the &lt;code&gt;Fractional&lt;/code&gt; instance…&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fromRational      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; exact &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromRational
    &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (x&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;y &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;vy)   (x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;vx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; vy&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
    recip (&lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx)   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (recip x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; vx&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) (vx &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Yikes. All that ugly and complicated numerical code that the typechecker can’t help us with (and, honestly, I’m not very confident in the results myself!). Those are runtime bugs just waiting to happen. How do we even &lt;em&gt;know&lt;/em&gt; that we calculated the right derivatives, and implemented the formula correctly?&lt;/p&gt;
&lt;p&gt;What if we could reduce this boilerplate? What if we could somehow analytically compute derivatives for functions instead of computing them manually?&lt;/p&gt;
&lt;h2 id=&quot;automatic-differentiation&quot;&gt;Automatic Differentiation&lt;/h2&gt;
&lt;p&gt;Automatic differentiation is honestly one of the coolest Haskell tricks you can show that any beginner can immediately understand. Like our trick with &lt;code&gt;Uncert&lt;/code&gt;, it’s nice to use because of its overloaded &lt;code&gt;Num&lt;/code&gt;/numeric typeclasses.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; diff (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- 2*x&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; diff (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; sin x) &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;-- cos x&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; diff (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;-- 3*x^2 - 6*x + 2&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A very rough explanation about how forward-mode automatic differentiation works is that it uses a wrapper type (like ours) that defines &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;negate&lt;/code&gt;, etc. so that they also compute the &lt;em&gt;derivative(s)&lt;/em&gt; of the function, instead of just the &lt;em&gt;result&lt;/em&gt;, like normal. There are a lot of nice tutorials online, like &lt;a href=&quot;http://www.danielbrice.net/blog/10/&quot;&gt;this one&lt;/a&gt; by Daniel Brice, if you want to follow up on this fun little subject.&lt;/p&gt;
&lt;h3 id=&quot;single-variable-functions&quot;&gt;Single-variable functions&lt;/h3&gt;
&lt;p&gt;And, now that we can automatically differentiate functions, we can use this knowledge directly in our implementations. Let’s define a universal “lifter” of single-variable functions.&lt;/p&gt;
&lt;p&gt;We use the function &lt;code&gt;diffs0&lt;/code&gt; to get a “tower” of derivatives:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; diffs0 (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
[&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;112&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;88&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;46&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first value is actually &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?4%5E2%20-%202%20%5Ctimes%204%5E3&quot; alt=&quot;4^2 - 2 \times 4^3&quot; title=&quot;4^2 - 2 \times 4^3&quot; /&gt;. The second is the derivative (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?2%20x%20-%206x%5E2&quot; alt=&quot;2 x - 6x^2&quot; title=&quot;2 x - 6x^2&quot; /&gt;) at 4, the third is the second derivative &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?2%20-%2012%20x&quot; alt=&quot;2 - 12 x&quot; title=&quot;2 - 12 x&quot; /&gt; at 4, then the third derivative &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?-12&quot; alt=&quot;-12&quot; title=&quot;-12&quot; /&gt;, then the fourth derivative &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?0&quot; alt=&quot;0&quot; title=&quot;0&quot; /&gt;, etc.&lt;/p&gt;
&lt;p&gt;We only need the actual value and the first two derivatives, so we can pattern match them as &lt;code&gt;fx:dfx:ddfx:_ = diffs0 f x&lt;/code&gt;, the derivatives and values of the function we lift, &lt;code&gt;f&lt;/code&gt;, around the mean &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At that point, the equations we have from before just translate nicely:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Coperatorname%7BE%7D%5Bf%28X%29%5D%20%3D%20f%28%5Cmu_X%29%20%2B%20%5Cfrac%7B1%7D%7B2%7D%20f_%7Bxx%7D%28%5Cmu_X%29%20%5Csigma_X%5E2%0A&quot; alt=&quot;
\operatorname{E}[f(X)] = f(\mu_X) + \frac{1}{2} f_{xx}(\mu_X) \sigma_X^2
&quot; title=&quot;
\operatorname{E}[f(X)] = f(\mu_X) + \frac{1}{2} f_{xx}(\mu_X) \sigma_X^2
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Coperatorname%7BVar%7D%5Bf%28X%29%5D%20%3D%20f_x%28%5Cmu_X%29%5E2%20%5Csigma_X%5E2%0A&quot; alt=&quot;
\operatorname{Var}[f(X)] = f_x(\mu_X)^2 \sigma_X^2
&quot; title=&quot;
\operatorname{Var}[f(X)] = f_x(\mu_X)^2 \sigma_X^2
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;And we call &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cmu_X&quot; alt=&quot;\mu_X&quot; title=&quot;\mu_X&quot; /&gt; &lt;code&gt;x&lt;/code&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Csigma_X%5E2&quot; alt=&quot;\sigma_X^2&quot; title=&quot;\sigma_X^2&quot; /&gt; &lt;code&gt;vx&lt;/code&gt;, and this becomes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;y  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; ddfx &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vx &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
vy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dfx&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Putting it all together:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L36-44&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;liftU ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a
      &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Tower&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Tower&lt;/span&gt; a))
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
liftU f (&lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fx&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;dfx&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ddfx&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; diffs0 f x
    y             &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; ddfx &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vx &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
    vy            &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dfx&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type &lt;code&gt;forall s. AD s (Tower a) -&amp;gt; AD s (Tower a)&lt;/code&gt; looks a little scary, but you can think of it as representing a function on &lt;code&gt;a&lt;/code&gt; (like &lt;code&gt;negate&lt;/code&gt;, &lt;code&gt;(*2)&lt;/code&gt;, etc.) that the &lt;em&gt;ad&lt;/em&gt; library can differentiate several times — something you could use with &lt;code&gt;diff0&lt;/code&gt; to get a “tower” of derivatives.&lt;/p&gt;
&lt;p&gt;And … that’s it! We can already define things like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;negate &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU negate
recip  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU recip
sqrt   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU sqrt
sin    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU sin&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;multivariable-functions&quot;&gt;Multivariable functions&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;ad&lt;/em&gt; also lets you work multivariable functions, too. To model multivariable functions, it takes a function from a &lt;code&gt;Traversable&lt;/code&gt; of vales to a single value. We can use the &lt;code&gt;V2&lt;/code&gt; type from the &lt;em&gt;&lt;a href=&quot;shttp://hackage.haskell.org/package/linear/docs/Linear-V2.html&quot;&gt;linear&lt;/a&gt;&lt;/em&gt; package to pass in a two-variable function:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; grad (\(&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; x y) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x) (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The gradient of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f%28x%2C%20y%29%20%3D%20x%20y%5E2%20%2B%203x&quot; alt=&quot;f(x, y) = x y^2 + 3x&quot; title=&quot;f(x, y) = x y^2 + 3x&quot; /&gt; is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%28y%5E2%20%2B%203%2C%202xy%29&quot; alt=&quot;(y^2 + 3, 2xy)&quot; title=&quot;(y^2 + 3, 2xy)&quot; /&gt;, which, at &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%283%2C%201%29&quot; alt=&quot;(3, 1)&quot; title=&quot;(3, 1)&quot; /&gt;, is indeed &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%284%2C%206%29&quot; alt=&quot;(4, 6)&quot; title=&quot;(4, 6)&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;The gradient gives us the first order partials, but we need the second order partials to calculate the new mean, so for that, we can use &lt;code&gt;hessian&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hessian (\(&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; x y) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x) (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
   (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Hessian_matrix&quot;&gt;hessian&lt;/a&gt; of a function &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f%28x%2Cy%29&quot; alt=&quot;f(x,y)&quot; title=&quot;f(x,y)&quot; /&gt; is basically a matrix of second-order partial derivatives:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%0A%5Cbegin%7Bbmatrix%7D%0Af_%7Bxx%7D%28x%2C%20y%29%20%26%20f_%7Byx%7D%28x%2C%20y%29%20%5C%5C%0Af_%7Byx%7D%28x%2C%20y%29%20%26%20f_%7Byy%7D%28x%2C%20y%29%0A%5Cend%7Bbmatrix%7D%0A&quot; alt=&quot;
\begin{bmatrix}
f_{xx}(x, y) &amp;amp; f_{yx}(x, y) \\
f_{yx}(x, y) &amp;amp; f_{yy}(x, y)
\end{bmatrix}
&quot; title=&quot;
\begin{bmatrix}
f_{xx}(x, y) &amp;amp; f_{yx}(x, y) \\
f_{yx}(x, y) &amp;amp; f_{yy}(x, y)
\end{bmatrix}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;In our case, we only care about the diagonal – the repeated double-derivatives, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f_%7Bxx%7D&quot; alt=&quot;f_{xx}&quot; title=&quot;f_{xx}&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?f_%7Byy%7D&quot; alt=&quot;f_{yy}&quot; title=&quot;f_{yy}&quot; /&gt;. Indeed, the double-partial of our function respect to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?x&quot; alt=&quot;x&quot; title=&quot;x&quot; /&gt; is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?0&quot; alt=&quot;0&quot; title=&quot;0&quot; /&gt;, and the double-partial with respect to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?y&quot; alt=&quot;y&quot; title=&quot;y&quot; /&gt; is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?2x&quot; alt=&quot;2x&quot; title=&quot;2x&quot; /&gt;, which gives us a hessian with a diagonal &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%280%2C%206%29&quot; alt=&quot;(0, 6)&quot; title=&quot;(0, 6)&quot; /&gt; for the input &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%283%2C%201%29&quot; alt=&quot;(3, 1)&quot; title=&quot;(3, 1)&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;ad&lt;/em&gt; package generously gives us a function that lets us calculate the function’s result, its gradient, and its hessian all in one pass:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hessian&amp;#39; (\(&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; x y) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x) (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
(&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)
     &lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can access the gradient by using &lt;code&gt;fmap fst&lt;/code&gt; on the second component of the tuple and access the hessian by using &lt;code&gt;fmap snd&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We need a couple of helpers, first — one to get the “diagonal” of our hessian, because we only care about the repeated partials:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L46-49&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;diag ::&lt;/span&gt; [[a]] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a]
diag &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; []        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; []
             []   &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;yss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; diag (drop &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; yss)
             (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_)&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;yss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; diag (drop &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; yss)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And then a “dot product”, utility function, which just multiplies two lists together component-by-component and sums the results:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L51-52&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;dot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
dot xs ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sum (zipWith (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;) xs ys)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now we can write our multi-variate function lifter:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L54-71&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;liftUF ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; f, &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a)
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; f (&lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a))
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f (&lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a)
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
liftUF f us &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    xs          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;         uMean &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; us
    vxs         &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; toList (uVar  &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; us)
    (fx, hgrad) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; hessian&amp;#39; f xs
    dfxs        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fst &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; hgrad
    hess        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; snd &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; hgrad
    y           &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; partials &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        partials &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dot vxs
                 &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; diag
                 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; toList (fmap toList hess) &lt;span class=&quot;co&quot;&gt;-- from f (f a) to [[a]]&lt;/span&gt;
    vy          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dot vxs
                &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; toList ((&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; dfxs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Again, don’t mind the scary type &lt;code&gt;forall s. f (AD s (Sparse a)) -&amp;gt; AD s (Sparse a)&lt;/code&gt;, it’s just &lt;em&gt;ad&lt;/em&gt;’s type for things you can use &lt;code&gt;hessian&#39;&lt;/code&gt; on)&lt;/p&gt;
&lt;p&gt;And we can write some nice helper functions so we can use them more naturally:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L73-86&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;liftU2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a))
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
liftU2 f x y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftUF (\(&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; x&amp;#39; y&amp;#39;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f x&amp;#39; y&amp;#39;) (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; x y)

&lt;span class=&quot;ot&quot;&gt;liftU3 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a))
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
liftU3 f x y z &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftUF (\(&lt;span class=&quot;dt&quot;&gt;V3&lt;/span&gt; x&amp;#39; y&amp;#39; z&amp;#39;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f x&amp;#39; y&amp;#39; z&amp;#39;) (&lt;span class=&quot;dt&quot;&gt;V3&lt;/span&gt; x y z)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At this point, our code is pretty much complete. We can fill in the other two-argument functions from the numeric typeclasses:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;(&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;)     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU2 (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;)
(&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;)     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU2 (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;)
(&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;)     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU2 (&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;)
(&lt;span class=&quot;fu&quot;&gt;**&lt;/span&gt;)    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU2 (&lt;span class=&quot;fu&quot;&gt;**&lt;/span&gt;)
logBase &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU2 logBase&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Admittedly, there’s still some slight boilerplate (that you can get rid of with some Template Haskell, maybe), but you have a &lt;em&gt;lot&lt;/em&gt; less room for error, and a lot simpler to check over and read to make sure you didn’t miss any bugs.&lt;/p&gt;
&lt;h2 id=&quot;wrapping-it-up&quot;&gt;Wrapping it up&lt;/h2&gt;
&lt;p&gt;The full code (with all of the numeric instances fully implemented) is up &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs&quot;&gt;on github&lt;/a&gt;, which you can run and explore and test by executing it or loading it with &lt;code&gt;stack ghci&lt;/code&gt;. I’ve added a special &lt;em&gt;Show&lt;/em&gt; instance that “rounds” your values to as many digits that your uncertainty suggests, to give more meaningful &lt;code&gt;show&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;All of what’s in this post is actually up on my &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/uncertain&quot;&gt;uncertain&lt;/a&gt;&lt;/em&gt; package on hackage, if you want to use it in your own projects, or see how I take this and make it more robust for real-world applications. The project also has more features on top of the basic things shown here.&lt;/p&gt;
&lt;h3 id=&quot;verification-and-accuracy&quot;&gt;Verification and Accuracy&lt;/h3&gt;
&lt;p&gt;My &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/uncertain&quot;&gt;uncertain&lt;/a&gt;&lt;/em&gt; package has a Monte Carlo module to propagate uncertainty through Monte Carlo simulations. Let’s see how the values compare!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y         &lt;span class=&quot;co&quot;&gt;-- Monte Carlo Results:&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;46&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;            &lt;span class=&quot;co&quot;&gt;-- actually 46 +/- 2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y
&lt;span class=&quot;dv&quot;&gt;450&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;40&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;-- actually 450 +/- 40&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; sqrt (x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y)
&lt;span class=&quot;fl&quot;&gt;6.8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.2&lt;/span&gt;         &lt;span class=&quot;co&quot;&gt;-- actually 6.8 +/- 0.2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; logBase y x
&lt;span class=&quot;fl&quot;&gt;0.78&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.02&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- actually 0.78 +/- 0.02&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; log (x&lt;span class=&quot;fu&quot;&gt;**&lt;/span&gt;y)
&lt;span class=&quot;fl&quot;&gt;85.9&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.3&lt;/span&gt;        &lt;span class=&quot;co&quot;&gt;-- actually 83 +/- 6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, it looks like the mathematical model of uncertainty propagation matched up well with the “actual” results we gain from Monte Carlo simulations! The only one of our examples that was significantly wrong was the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Coperatorname%7Blog%7D%28x%5Ey%29&quot; alt=&quot;\operatorname{log}(x^y)&quot; title=&quot;\operatorname{log}(x^y)&quot; /&gt; example, which heavily underestimated the uncertainty by about a factor of 20. But, remember, the model was derived after dropping the 2nd, 3rd, 4th, etc. terms of the taylor expansion for the calculation of the new uncertainty, and the 4th, 6th, etc. terms of the taylor expansion for the calculation of the new mean. For functions that have high second, third, fourth derivatives relative to the mean and the uncertainty, it’s going to be a bit off.&lt;/p&gt;
&lt;h3 id=&quot;what-next&quot;&gt;What next?&lt;/h3&gt;
&lt;p&gt;For an extension on the mathematics behind this method, Dan Piponi has a &lt;a href=&quot;http://blog.sigfpe.com/2011/08/computing-errors-with-square-roots-of.html&quot;&gt;great article&lt;/a&gt; with a lot of good references for further reading on the formal method.&lt;/p&gt;
&lt;p&gt;Going off of what we’ve done here, a simple extension of this would be to implement the Monte Carlo simulator I mentioned above, which is pretty straightforward to implement with the &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/mwc-random&quot;&gt;mwc-random&lt;/a&gt;&lt;/em&gt; package.&lt;/p&gt;
&lt;p&gt;However, the most unsettling thing here that we never deal with is what happens correlated terms that are combined. All of our math assumed uncorrelated samples. But what happens if we have expressions that involve additions of correlated values?&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;14.6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.8&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; x
&lt;span class=&quot;dv&quot;&gt;29&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;14.6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.8&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x
&lt;span class=&quot;dv&quot;&gt;29&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unfortunately, &lt;code&gt;x + x&lt;/code&gt; is different than &lt;code&gt;2*x&lt;/code&gt;. This is because &lt;code&gt;x&lt;/code&gt; acts like an &lt;em&gt;independent generator&lt;/em&gt;, so when you say &lt;code&gt;x + x&lt;/code&gt;, it expands to &lt;code&gt;(14.6 +/- 0.8) + (14.6 +/- 0.8)&lt;/code&gt;, which represents the addition of two independent samples.&lt;/p&gt;
&lt;p&gt;When you say &lt;code&gt;2*x&lt;/code&gt;, that represents sampling &lt;code&gt;x&lt;/code&gt; &lt;em&gt;once&lt;/em&gt; and &lt;em&gt;doubling&lt;/em&gt; it. If you sample &lt;code&gt;x&lt;/code&gt; and double it, any error in &lt;code&gt;x&lt;/code&gt; will also be doubled. That’s why the uncertainty is greater in the &lt;code&gt;2*x&lt;/code&gt; version.&lt;/p&gt;
&lt;p&gt;How can we account for correlated values that are combined in complex ways? Stay tuned for the next part of the &lt;a href=&quot;https://blog.jle.im/entries/series/+uncertain.html&quot;&gt;series&lt;/a&gt;!&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;You can simulate noisy data by using uniform noise distributions, Gaussian distributions, or however manner you like that has a given expected value (mean) and “spread”. Verify by checking the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt; of the sums!&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;This law actually comes from the mathematical &lt;em&gt;definition&lt;/em&gt; of variance, so does not assume anything about the underlying distribution of the sampling — just that they are independent, and that they have defined variances.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;Or just look at my &lt;a href=&quot;https://hackage.haskell.org/package/uncertain&quot;&gt;package&lt;/a&gt; :)&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Tutorials</category><guid isPermaLink="true">https://blog.jle.im/entry/automatic-propagation-of-uncertainty-with-ad.html</guid><pubDate>Mon,  9 May 2016 18:38:24 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Tutorials</dc:subject><dc:date>2016-05-09</dc:date></item><item><title>Blog Rewrite with Hakyll and Purescript</title><link>https://blog.jle.im/entry/blog-rewrite-with-hakyll-and-purescript.html</link><description>&lt;p&gt;It’s been almost a year since my last post! Things have been a bit hectic with research and related things, and with the unrelenting academia publishing cycle, any time I can get to write or explore has been a nice escape.&lt;/p&gt;
&lt;p&gt;Admittedly, I’ve also run into some friction updating my blog because it was a compiled web server with some delicate dependencies and required environment configuration to build/deploy. It was written/built at a time when a lot of the infrastructure we have now in the Haskell ecosystem either wasn’t there, or wasn’t mature. We didn’t have easy &lt;a href=&quot;https://haskellonheroku.com/&quot;&gt;Heroku deployment&lt;/a&gt;, and we didn’t have great tools like &lt;a href=&quot;http://haskellstack.org/&quot;&gt;stack&lt;/a&gt; to let us create reproducible builds. One of my &lt;a href=&quot;http://blog.jle.im/entry/deploying-medium-to-large-haskell-apps-to-heroku.html&quot;&gt;first posts&lt;/a&gt; in 2013 was actually about hoops to jump through &lt;em&gt;just&lt;/em&gt; to get a simple Heroku deployment. I’ve had to maintain a virtual machine just to compile and push changes!&lt;/p&gt;
&lt;p&gt;My blog was one of my first Haskell projects ever, and if I had started it now, in 2016, things would definitely be a bit different. By this point, it’s been long enough and the slight inconveniences have been building up enough that I thought it’d be time to sit down and finally migrate my “first large-ish Haskell project” and bring it into modern times, by using &lt;a href=&quot;https://jaspervdj.be/hakyll/&quot;&gt;hakyll&lt;/a&gt; and &lt;a href=&quot;http://www.purescript.org/&quot;&gt;purescript&lt;/a&gt;. Here are my thoughts and observations on how the migration went, with insight on Haskell migrations in general!&lt;/p&gt;
&lt;p&gt;My blog engine is open-source, and the &lt;a href=&quot;https://github.com/mstksg/inCode&quot;&gt;source for this specific instance&lt;/a&gt; is up on github, for those interested in checking it out!&lt;/p&gt;
&lt;h2 id=&quot;hakyll&quot;&gt;Hakyll&lt;/h2&gt;
&lt;p&gt;To be honest, there was little actual practical reasons why my site wasn’t static to begin with. The main reason, feature-wise, was for me to be able to schedule blog posts and updates without requiring me to actually re-render and re-push every time I wanted to make a post. The real underlying reason, however, was that this blog was my first major Haskell project, and I wanted to take the opportunity to be able to learn how to interface with databases in Haskell.&lt;/p&gt;
&lt;p&gt;Now that that learning impetus is behind me, I felt free to throw it all out the window and rewrite things to be a completely 100% static site!&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaspervdj.be/hakyll/&quot;&gt;Hakyll&lt;/a&gt; was great; it’s basically like a very specialized &lt;em&gt;make&lt;/em&gt;-like tool for building sites. It takes a bit of time to get used to “thinking in Hakyll” — generating standalone pages instead of just ones based off of files, getting used to the identifier/snapshot system — but once you do, things go pretty smoothly. I started thinking about snapshots as customized “object files” that you can leave behind in the process of creating pages that other pages can use. Hakyll manages all the dependencies for you, so pages that depend on the things left from other pages will be sequenced properly, and rebuilding your website only requires rebuilding pages that depend on files you changed. Neat!&lt;/p&gt;
&lt;p&gt;Before, I had gotten the impression that Hakyll was mostly for generating “simple”, pre-built blog layouts, but I was able to use Hakyll (without much friction, at all) to generate the complex, intricate, and arbitrary site map that I had designed for my &lt;a href=&quot;http://hackage.haskell.org/package/scotty&quot;&gt;scotty&lt;/a&gt;-based blog. I definitely recommend it for any static site generating needs, blogs or not.&lt;/p&gt;
&lt;p&gt;An unexpected consequence of the static-site-hosted-by-github-pages approach, however, is that I don’t have any control over MIME types anymore (or 301 redirects), so I had to do some migrations to move pages over to “.html” and set up redirects and stuff (and get redirects to work with google analytics), but those were made super simple with Hakyll.&lt;/p&gt;
&lt;h2 id=&quot;refactoring-haskell-code&quot;&gt;Refactoring Haskell Code&lt;/h2&gt;
&lt;p&gt;One thing that did not disappoint me was how &lt;em&gt;easy&lt;/em&gt; and &lt;em&gt;painless&lt;/em&gt; it is to refactor Haskell code. This is something I always trumpet/brag about Haskell, and getting the opportunity to actually refactor a major-ish codebase.&lt;/p&gt;
&lt;p&gt;And, yes, I was not disappointed! For the most part, I already had my html templates, CSS, static javascript, etc. in place. All of the mechanisms were extremely modular and very easy to port. The type system made sure everything fit together well at the boundaries. They also instantly told me what did what, and ensured that sweeping changes in my code were safe. The “if it compiles, it works” mantra served me greatly here. I can’t even begin to imagine migrating one of my old ruby projects in the same way. With this, I was confident that my compiled code was correct and did what I wanted. The types were a guide and also a avenue of insight into my 3-years-removed past self.&lt;/p&gt;
&lt;p&gt;Thanks to the types, I was able to pick up something I hadn’t touched in 3 years, figure out how all things fit together, and completely gut everything apart and use them for a new build system … with compile-time assurances that I didn’t do anything incorrectly!&lt;/p&gt;
&lt;p&gt;It’s hard for me to really explain how amazing the feeling of refactoring Haskell code is. I used to dread refactors and migrations, but now I look forward to them and find any opportunity to do one! :D It’s something that’s difficult to convey the sublime joy of until you actually try it, so I recommend trying it some day :)&lt;/p&gt;
&lt;h2 id=&quot;purescript&quot;&gt;Purescript&lt;/h2&gt;
&lt;h3 id=&quot;on-fay&quot;&gt;on Fay&lt;/h3&gt;
&lt;p&gt;With my &lt;a href=&quot;http://blog.jle.im/entry/blog-engine-updates-markdown-preprocessor-fay-scripts.html#fay&quot;&gt;last major blog update&lt;/a&gt;, I ported all of my one-off javascript scripts to fay. This time around, I figured I’d move away from &lt;a href=&quot;https://github.com/faylang/fay/wiki&quot;&gt;fay&lt;/a&gt;, because it was slightly clunky to build/get working/integrate in the way that GHCJS spoiled me to be accustomed to. In the future, I might return … but at this point in time, Fay seems a bit awkward in the ecosystem. GHCJS lets you use the full power of Haskell (including all of &lt;em&gt;base&lt;/em&gt;’s concurrency mechanisms and almost every library on hackage), at the expense of creating large and unreadable javascript blobs.&lt;/p&gt;
&lt;p&gt;Fay seemed like just a &lt;em&gt;weaker&lt;/em&gt; GHCJS to me, but in all the ways that mattered. It doesn’t have all of the awesome GHC things that make modern Haskell what it is (not just the lack of base’s identical API, but also … no typeclasses? Lens abstractions? Hackage libraries?), so almost all of my normal Haskell programming flow is thrown out the window. It’s a subset of Haskell, but lacks most of the tools people use to write &lt;em&gt;actual&lt;/em&gt; Haskell like they’d write everyday. The generated javascript blobs are still decently opaque.&lt;/p&gt;
&lt;p&gt;So, if you’re going to be spending your time writing something that is like Haskell, but forces you to write it in a way that is nothing like any actual Haskell code you’d normally write… why even bother keeping up with Haskell semantics and Haskell compatibility? Why not break out and try something new and fresh, unbound by Haskell and compatibility issues?&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;on-purescript&quot;&gt;on Purescript&lt;/h3&gt;
&lt;p&gt;With that mindset, I looked at &lt;em&gt;&lt;a href=&quot;http://www.purescript.org/&quot;&gt;purescript&lt;/a&gt;&lt;/em&gt;, which is a language that’s inspired by Haskell, with a lot of Haskell features we use every day, and throws in things we all wish we had in Haskell, like extensible records!&lt;/p&gt;
&lt;p&gt;(Note — I &lt;em&gt;did&lt;/em&gt; rewrite all of my fay in GHCJS at first. This resulted in a javascript blob that was &lt;em&gt;1.4 MB&lt;/em&gt; in size for just a bunch of small DOM manipulation scripts. Definitely not practical, unfortunately!)&lt;/p&gt;
&lt;p&gt;I liked that purescript was able to throw away a lot of warts in the Haskell ecosystem, with a cleaner typeclass hierarchy and just a lot of design decisions “done right”, that we’d all change in Haskell if we could. And extensible records being built into the language is quite refreshing; not having to deal with fancy GADT’s in Haskell was a nice step back from the craziness that is type-level programming in Haskell. Alongside all of that, I was also able to rely and seamlessly use a lot of Haskell idioms that we all know and love, like lenses and traversals and compositions.&lt;/p&gt;
&lt;p&gt;At many moments, I felt like writing in Purescript felt like writing in &lt;em&gt;the language that Haskell should have been&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;But one of my favorite aspects about purescript ended up being the sheer beauty and conciseness of the generated javascript. Look at how&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&quot;purescript&quot;&gt;&lt;code&gt;appendTopLinks doc = do
    hs &amp;lt;- querySelectorAll headers (documentToParentNode doc)
    flip traverseNodeList_ hs \h -&amp;gt; do
      topLink &amp;lt;- createElement &amp;quot;a&amp;quot; doc
      let topLinkNode = elementToNode topLink
      setAttribute &amp;quot;href&amp;quot; &amp;quot;#title&amp;quot; topLink
      setClassName &amp;quot;top-link&amp;quot; topLink
      setTextContent &amp;quot;top&amp;quot; topLinkNode
      appendChild topLinkNode (elementToNode h)
      return unit&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gets translated to:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode javascript&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; appendTopLinks &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (doc) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;__do&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; v &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;querySelectorAll&lt;/span&gt;(headers)(&lt;span class=&quot;at&quot;&gt;documentToParentNode&lt;/span&gt;(doc))()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;flip&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;traverseNodeList_&lt;/span&gt;(monadEffEff))(v)(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (h) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;__do&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; v1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;createElement&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;)(doc)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; topLinkNode &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;elementToNode&lt;/span&gt;(v1)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;at&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;href&amp;quot;&lt;/span&gt;)(&lt;span class=&quot;st&quot;&gt;&amp;quot;#title&amp;quot;&lt;/span&gt;)(v1)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;at&quot;&gt;setClassName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;top-link&amp;quot;&lt;/span&gt;)(v1)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;at&quot;&gt;setTextContent&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;top&amp;quot;&lt;/span&gt;)(topLinkNode)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;at&quot;&gt;appendChild&lt;/span&gt;(topLinkNode)(&lt;span class=&quot;at&quot;&gt;elementToNode&lt;/span&gt;(h))()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; unit&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And it’s not just the IO-based imperative code that looks nice, either. Everything gets compiled to clean, readable javascript that you’d be happy to import in your node/normal javascript project.&lt;/p&gt;
&lt;p&gt;The total exported javascript blob is only &lt;em&gt;88 kB&lt;/em&gt;, even smaller than fay’s &lt;em&gt;100 kB&lt;/em&gt; output (but not significantly so), and much smaller than GHCJS’s &lt;em&gt;1.4 MB&lt;/em&gt;&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; output (which, to be fair, has to also contain the entire Haskell runtime, implementing Haskell semantics, as well).&lt;/p&gt;
&lt;p&gt;Interestingly enough, the &lt;em&gt;original&lt;/em&gt; raw javacript I wrote in 2013 came out to about the same size, about &lt;em&gt;80 kB&lt;/em&gt;. (Well, it is about &lt;em&gt;2 kB&lt;/em&gt; of actual script, but it utilized all of &lt;em&gt;jquery&lt;/em&gt;, which implements a lot of the functionality.) Getting comparable filesizes to jquery bundles is something that’s pretty impressive to me!&lt;/p&gt;
&lt;p&gt;I’d recommend purescript to anyone who has to write simple javascript &lt;em&gt;scripts&lt;/em&gt; and wants to do it in a sane, beautiful language. I still use &lt;em&gt;ghcjs&lt;/em&gt; for actual &lt;em&gt;applications&lt;/em&gt;, for now, because I still love Haskell and its ecosystem, along with the free data type sharing and code re-usage. But for small scripts like these, purescript might just be the ideal and perfect solution!&lt;/p&gt;
&lt;p&gt;You can check out &lt;a href=&quot;https://github.com/mstksg/inCode/blob/28f6a5da4c83356c4be87067ab88171879c68784/app-purescript/Entry.purs&quot;&gt;the actual purescript script&lt;/a&gt; on github!&lt;/p&gt;
&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;My main takeways —&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;I will never be able to never work on a Haskell project/application without &lt;em&gt;stack&lt;/em&gt; again (how did we even survive before &lt;em&gt;stack&lt;/em&gt;?)&lt;/li&gt;
&lt;li&gt;Hakyll is a fun little library that is a great specialized &lt;em&gt;make&lt;/em&gt; for building static websites&lt;/li&gt;
&lt;li&gt;Refactoring Haskell is an amazing experience; I would recommend it to anyone to try it out at least once in their lives&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Purescript&lt;/em&gt; is an amazing and beautiful technology that I had the pleasure of learning during this process, and generates elegant, readable javascript scripts.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This reflection post has been to help me organize my thoughts, but I hope they can be useful for those of you looking for new technologies to learn and ways to implement/approach your stack or next programming project, as well!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;I definitely don’t mean to bash on &lt;em&gt;fay&lt;/em&gt; here! It definitely has its role and place in the ecosystem. It’s for my specific application that I was looking for an alternative with.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;There’s another thing here that I skipped over slightly – &lt;a href=&quot;http://haste-lang.org/&quot;&gt;Haste&lt;/a&gt;. I haven’t had much experience with it myself, but for this purpose, I decided to jump into something not-Haskell and try out something new!&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;Unfortunately, &lt;em&gt;&lt;a href=&quot;https://github.com/jgm/highlighting-kate&quot;&gt;highlighting-kate&lt;/a&gt;&lt;/em&gt; doesn’t yet support purescript syntax highlighting?&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;A previous version of this post claimed that the javascript bundle was &lt;em&gt;140 MB&lt;/em&gt;, instead of &lt;em&gt;1.4 MB&lt;/em&gt;. My bad!&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Meta</category><guid isPermaLink="true">https://blog.jle.im/entry/blog-rewrite-with-hakyll-and-purescript.html</guid><pubDate>Fri, 25 Mar 2016 15:59:18 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Meta</dc:subject><dc:date>2016-03-25</dc:date></item><item><title>Introducing the “Prompt” library</title><link>https://blog.jle.im/entry/introducing-the-prompt-library.html</link><description>&lt;p&gt;&lt;strong&gt;Prompt&lt;/strong&gt;: &lt;a href=&quot;https://github.com/mstksg/prompt/blob/master/README.md&quot;&gt;README&lt;/a&gt; / &lt;a href=&quot;http://hackage.haskell.org/package/prompt&quot;&gt;hackage&lt;/a&gt; / &lt;a href=&quot;https://github.com/mstksg/prompt&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Have you ever wanted to specify a computation involving some limited form of IO — like querying a database, or asking stdio — but didn’t want a computation in the &lt;code&gt;IO&lt;/code&gt; monad, opening the entire can of worms that is arbitrary &lt;code&gt;IO&lt;/code&gt;? Have you ever looked at complicated &lt;code&gt;IO a&lt;/code&gt; you wrote last week at 4am and prayed that it didn’t launch missiles if you decided to execute it? Do you want to be able to run an effectful computation and explicitly &lt;em&gt;say&lt;/em&gt; what IO it can or cannot do?&lt;/p&gt;
&lt;p&gt;Introducing the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/prompt&quot;&gt;prompt&lt;/a&gt;&lt;/em&gt; library! It’s a small little lightweight library that allows you to specify and describe computations involving forms of effects where you “ask” with a value and receive a value in return (such as a database query, etc.), but not ever care about how the effects are fulfilled — freeing you from working directly with IO.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; fooBar ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
               ,&lt;span class=&quot;ot&quot;&gt; fooBaz ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
               } &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- ask with a String, receive a String as an answer&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;promptFoo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Prompt&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
promptFoo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; fmap length (prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;running&quot;&gt;Running&lt;/h2&gt;
&lt;p&gt;You can now “run it” in IO, by talking to stdio —&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runPromptM promptFoo &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \str &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; putStrLn str &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; getLine
bar                 &lt;span class=&quot;co&quot;&gt;-- stdout prompt&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;            &lt;span class=&quot;co&quot;&gt;-- stdin response typed in&lt;/span&gt;
baz                 &lt;span class=&quot;co&quot;&gt;-- stdout prompt&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; i am baz          &lt;span class=&quot;co&quot;&gt;-- stdin response typed in&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;-- result&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(this is also just &lt;code&gt;interactP promptFoo&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;Or you can maybe request it from the environment variables:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;System.Environment&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; setEnv &lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; setEnv &lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;i am baz&amp;quot;&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runPromptM promptFoo getEnv
&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or maybe you want to fulfill the prompts purely:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;import qualified&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Data.Map&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;M&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; testMap &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; M.fromList [(&lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt;), (&lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;i am baz&amp;quot;&lt;/span&gt;)]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runPrompt promptFoo (testMap &lt;span class=&quot;fu&quot;&gt;M.!&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With &lt;code&gt;Prompt&lt;/code&gt;, specify the computation and your logic &lt;em&gt;without involving any IO&lt;/em&gt;, so you can write safe code without arbitrary side effects. If you ever receive a &lt;code&gt;Prompt&lt;/code&gt;, you know it can’t wipe out your hard drive or do any IO other than exactly what you allow it to do! I’d feel more safe running a &lt;code&gt;Prompt a b r&lt;/code&gt; than an &lt;code&gt;IO r&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can also do some cute tricks; &lt;code&gt;Prompt a () r&lt;/code&gt; with a “prompt response function” like &lt;code&gt;putStrLn&lt;/code&gt; lets you do streaming logging, and defer &lt;em&gt;how&lt;/em&gt; the logging is done — to IO, to a list?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; logHelloWord &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mapM_ prompt [&lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt;]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runPromptM logHelloWorld putStrLn
hello
world
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; execWriter &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; runPromptM logHelloWorld tell
&lt;span class=&quot;st&quot;&gt;&amp;quot;helloworld&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Prompt () b r&lt;/code&gt; is like a fancy &lt;code&gt;ReaderT b m r&lt;/code&gt;, where you “defer” the choice of the Monad.&lt;/p&gt;
&lt;h2 id=&quot;combining-with-other-effects&quot;&gt;Combining with other effects&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Prompt&lt;/code&gt; can be used as an underlying “effects” source for libraries like &lt;em&gt;pipes&lt;/em&gt;, &lt;em&gt;conduit&lt;/em&gt;, and &lt;em&gt;auto&lt;/em&gt;. If your effects are only ever asking and prompting and receiving, there’s really no need to put the entire power of &lt;code&gt;IO&lt;/code&gt; underneath your DSL as an effects source. That’s just crazy!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Prompt&lt;/code&gt; can be used with monad transformers to give you safe underlying effect sources, like &lt;code&gt;StateT s (Prompt a b) r&lt;/code&gt;, which is a stateful computation which can sometimes sequence “prompty” effects. &lt;code&gt;Prompt&lt;/code&gt; is also itself a “Traversable transformer”, with &lt;code&gt;PrompT a b t r&lt;/code&gt;. It can perform computations in the context of a Traversable &lt;code&gt;t&lt;/code&gt;, to be able to incorporate built-in short-circuiting and logging, etc.&lt;/p&gt;
&lt;p&gt;This is all abstracted over with &lt;code&gt;MonadPrompt&lt;/code&gt;, &lt;code&gt;MonadError&lt;/code&gt;, &lt;code&gt;MonadPlus&lt;/code&gt;, etc., typeclasses —&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;promptFoo2 ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadPlus&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;MonadPrompt&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; m) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
promptFoo2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    bar &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;
    str &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; readMaybe str &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; baz &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; bar baz
        &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; mzero

&lt;span class=&quot;co&quot;&gt;-- more polymorphic&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;promptFoo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadPrompt&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
promptFoo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; fmap length (prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can run &lt;code&gt;promptFoo&lt;/code&gt; as a &lt;code&gt;MaybeT (Prompt String String) Foo&lt;/code&gt;, and manually unwrap:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; interactP &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; runMaybeT &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; promptFoo2
bar
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
baz
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; i am baz
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; interactP &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; runMaybeT &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; promptFoo2
bar
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
baz
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello!&amp;quot;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or you can run it as a &lt;code&gt;PromptT String String MaybeT Foo&lt;/code&gt;, to have &lt;code&gt;PromptT&lt;/code&gt; handle the wrapping/unwrapping itself:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; interactPT promptFoo2
bar
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
baz
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; i am baz
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; interactPT &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; promptFoo2 &lt;span class=&quot;fu&quot;&gt;&amp;lt;|&amp;gt;&lt;/span&gt; promptFoo
bar
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
baz
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; i am baz
bar                 &lt;span class=&quot;co&quot;&gt;-- failed to parse --- retrying with promptFoo!&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hello&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
baz
&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; i am baz
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The previous example of &lt;code&gt;logHelloWorld&lt;/code&gt;?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runPromptT (&lt;span class=&quot;ot&quot;&gt;logHelloWorld ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; () (&lt;span class=&quot;dt&quot;&gt;Writer&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;) ()) tell
&lt;span class=&quot;st&quot;&gt;&amp;quot;helloworld&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;runners&quot;&gt;Runners&lt;/h2&gt;
&lt;p&gt;The “runners” are:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;interactP   ::&lt;/span&gt;                  &lt;span class=&quot;dt&quot;&gt;Prompt&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;   r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; r
&lt;span class=&quot;ot&quot;&gt;interactPT  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; t &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; t r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (t r)

&lt;span class=&quot;ot&quot;&gt;runPrompt   ::&lt;/span&gt;                  &lt;span class=&quot;dt&quot;&gt;Prompt&lt;/span&gt;  a b   r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;   b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r
&lt;span class=&quot;ot&quot;&gt;runPromptM  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Prompt&lt;/span&gt;  a b   r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m r

&lt;span class=&quot;ot&quot;&gt;runPromptT  ::&lt;/span&gt;                  &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; a b t r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;    t b)  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; t r
&lt;span class=&quot;ot&quot;&gt;runPromptTM ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; a b t r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (t b)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (t r)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;runPromptM&lt;/code&gt; and &lt;code&gt;runPromptTM&lt;/code&gt; can run in monads (like &lt;code&gt;IO&lt;/code&gt;) that are &lt;em&gt;completely unrelated&lt;/em&gt; to the &lt;code&gt;Prompt&lt;/code&gt; type itself. It sequences them all “after the fact”. It’s also interesting to note that &lt;code&gt;runPrompt&lt;/code&gt; is just a glorified &lt;code&gt;Reader (a -&amp;gt; b) r&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;runPromptTM&lt;/code&gt;, you can incorporate &lt;code&gt;t&lt;/code&gt; in your “prompt response” function, too. Which brings us to our grand finale – environment variable parsing!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad.Error.Class&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad.Prompt&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Text.Read&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import qualified&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Data.Map&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;M&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Val&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MENoParse&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Val&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MENotFound&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;promptRead ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;MonadPrompt&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Val&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;Read&lt;/span&gt; b)
           &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m b
&lt;span class=&quot;co&quot;&gt;-- promptRead :: Read b =&amp;gt; Key -&amp;gt; PromptT Key Val (Either MyError) b&lt;/span&gt;
promptRead k &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    resp &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; prompt k
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; readMaybe resp &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; throwError &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MEParse&lt;/span&gt; k resp
      &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; v  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; return v

&lt;span class=&quot;ot&quot;&gt;promptFoo3 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadPrompt&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Val&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- promptFoo3 :: Applicative t =&amp;gt; PromptT Key Val t Foo&lt;/span&gt;
promptFoo3 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; prompt &lt;span class=&quot;st&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; promptRead &lt;span class=&quot;st&quot;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- running!&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- Lookup environment variables, and &amp;quot;throw&amp;quot; an error if not found&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;throughEnv ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;)
throughEnv &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runPromptTM parseFoo3 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    env &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; lookupEnv k
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; env &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MENotFound&lt;/span&gt; k)
      &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; v  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; v

&lt;span class=&quot;co&quot;&gt;-- Fulfill the prompt through user input&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;throughStdIO ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;)
throughStdIO &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; interactPT parseFoo3

&lt;span class=&quot;co&quot;&gt;-- Fulfill the prompt through user input; count blank responses as &amp;quot;not found&amp;quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;throughStdIOBlankIsError ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;)
throughStdIOBlankIsError &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runPromptTM parseFoo3 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    putStrLn k
    resp &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getLine
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; null resp
      &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MENotFound&lt;/span&gt; k)
      &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; resp

&lt;span class=&quot;co&quot;&gt;-- Fulfill the prompt purely through a Map lookup&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;throughMap ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;M.Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Val&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MyError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
throughMap m &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runPromptT parseFoo3 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; M.lookup k m &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MENotFound&lt;/span&gt; k)
      &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; v  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; v&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hope you enjoy! Please feel free to leave a comment, find me on &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;twitter&lt;/a&gt;, leave an issue on the &lt;a href=&quot;https://github.com/mstksg/prompt&quot;&gt;github&lt;/a&gt;, etc. — and I’m usually on freenode’s &lt;em&gt;#haskell&lt;/em&gt; as &lt;em&gt;jle`&lt;/em&gt; if you have any questions!&lt;/p&gt;
&lt;h2 id=&quot;comparisons&quot;&gt;Comparisons&lt;/h2&gt;
&lt;p&gt;To lay it all on the floor,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; a b t r &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PromptT&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; runPromptTM ::&lt;/span&gt; forall m&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (t b)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (t r) }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There is admittedly a popular misconception that I’ve seen going around that equates this sort of type to &lt;code&gt;Free&lt;/code&gt; from the &lt;em&gt;free&lt;/em&gt; package. However, &lt;code&gt;Free&lt;/code&gt; doesn’t really have anything significant to do with this. Sure, you might be able to generate this type by using &lt;code&gt;FreeT&lt;/code&gt; over a specifically chosen Functor, but…this is the case for literally any Monad ever, so that doesn’t really mean much :)&lt;/p&gt;
&lt;p&gt;It’s also unrelated in this same manner to &lt;code&gt;Prompt&lt;/code&gt; from the &lt;em&gt;MonadPrompt&lt;/em&gt; package, and &lt;code&gt;Program&lt;/code&gt; from &lt;em&gt;operational&lt;/em&gt; too.&lt;/p&gt;
&lt;p&gt;One close relative to this type is &lt;code&gt;forall m. ReaderT (a -&amp;gt; m b) m r&lt;/code&gt;, where &lt;code&gt;prompt k = ReaderT ($ k)&lt;/code&gt;. This is more or less equivalent to &lt;code&gt;Prompt&lt;/code&gt;, but still can’t do the things that &lt;code&gt;PromptT&lt;/code&gt; can do without a special instance of Monad.&lt;/p&gt;
&lt;p&gt;This type is also similar in structure to &lt;code&gt;Bazaar&lt;/code&gt;, from the &lt;em&gt;lens&lt;/em&gt; package. The biggest difference that makes &lt;code&gt;Bazaar&lt;/code&gt; unusable is because the RankN constraint is only &lt;code&gt;Applicative&lt;/code&gt;, not &lt;code&gt;Monad&lt;/code&gt;, so a &lt;code&gt;Monad&lt;/code&gt; instance is impossible. Ignoring that (or if it’s okay for you to only use the &lt;code&gt;Applicative&lt;/code&gt; instance), &lt;code&gt;Bazaar&lt;/code&gt; forces the “prompting effect” to take place in the same context as the &lt;code&gt;Traversable&lt;/code&gt; &lt;code&gt;t&lt;/code&gt;…which really defeats the purpose of this whole thing in the first place (the idea is to be able to separate your prompting effect from your application logic). If the &lt;code&gt;Traversable&lt;/code&gt; you want to transform has a “monad transformer” version, then you can somewhat simulate &lt;code&gt;PromptT&lt;/code&gt; for that specifc &lt;code&gt;t&lt;/code&gt; with the transformer version.&lt;/p&gt;
&lt;p&gt;It’s also somewhat similar to the &lt;code&gt;Client&lt;/code&gt; type from &lt;em&gt;pipes&lt;/em&gt;, but it’s also a bit tricky to use that with a different effect type than the logic &lt;code&gt;Traversable&lt;/code&gt;, as well…so it has a lot of the same difference as &lt;code&gt;Bazaar&lt;/code&gt; here.&lt;/p&gt;
&lt;p&gt;But this type is common/simple enough that I’m sure someone has it somewhere in a library that I haven’t been able to find. If you find it, let me know!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Projects</category><guid isPermaLink="true">https://blog.jle.im/entry/introducing-the-prompt-library.html</guid><pubDate>Tue, 30 Jun 2015 16:42:11 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Projects</dc:subject><dc:date>2015-06-30</dc:date></item><item><title>Fixed-Length Vector Types in Haskell, 2015</title><link>https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html</link><description>&lt;p&gt;Fixed-length vector types (vector types that indicate the length of the vector in the type itself) are one of the more straightforward applications of the “super-Haskell” GHC type extensions. There’s a lot of magic you can do with GHC’s advanced type mechanisms, but I think fixed length vectors are a good first step to beginning to understand several extensions, including (potentially):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ConstraintKinds&lt;/li&gt;
&lt;li&gt;DataKinds&lt;/li&gt;
&lt;li&gt;GADTs&lt;/li&gt;
&lt;li&gt;KindSignatures&lt;/li&gt;
&lt;li&gt;TypeFamilies&lt;/li&gt;
&lt;li&gt;TypeOperators&lt;/li&gt;
&lt;li&gt;OverloadedLists&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And using type system plugins. (And of course the usual &lt;code&gt;UndecidableInstances&lt;/code&gt; etc.) We’ll be discussing two different ways to implement this — using type-level nats, and using the &lt;em&gt;GHC.TypeLits&lt;/em&gt; model to actually be able to use numeric literals in your types. These things are seen in the wild like with the popular &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/linear-1.18.0.1/docs/Linear-V.html&quot;&gt;linear&lt;/a&gt;&lt;/em&gt; package’s &lt;code&gt;V&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;There are a few great tutorials/writeups on this topic, but many of them are from the time before we had some of these extensions, or only discuss a few. I hope to provide a nice comprehensive look about the tools available today to really approach this topic. That being said, I am no expert myself, so I would appreciate any tips/edits/suggestions for things that I’ve missed or done not-the-best :) This post has a lot of open questions that I’m sure people who know more about this than me can answer.&lt;/p&gt;
&lt;p&gt;Most of the code in this article can be &lt;a href=&quot;https://github.com/mstksg/inCode/blob/master/code-samples/fixvec&quot;&gt;downloaded and tried out&lt;/a&gt;, so follow along if you want!&lt;/p&gt;
&lt;h2 id=&quot;the-idea&quot;&gt;The Idea&lt;/h2&gt;
&lt;p&gt;The basic idea is we’ll have a type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is a vector with items of type &lt;code&gt;a&lt;/code&gt;, whose length is somehow encoded in the &lt;code&gt;n&lt;/code&gt;. We’ll then discuss ways to do useful operations on this, as if it were a list.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; can really only be a certain “kind” of thing — a type that encodes a length. We can represent this by giving it a “kind signature”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which says that our &lt;code&gt;Vec&lt;/code&gt; type constructor takes two arguments: something of kind &lt;code&gt;Nat&lt;/code&gt; (so it can’t be any type…it has to be a type of kind &lt;code&gt;Nat&lt;/code&gt;), something of kind &lt;code&gt;*&lt;/code&gt; (the “normal” kind, of things that have values, like &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Maybe Bool&lt;/code&gt;, etc.), and returns something of kind &lt;code&gt;*&lt;/code&gt; (our vector itself).&lt;/p&gt;
&lt;h2 id=&quot;using-datakinds-for-type-level-nats&quot;&gt;Using DataKinds for Type-Level Nats&lt;/h2&gt;
&lt;p&gt;(The code in this section for this type is &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs&quot;&gt;available online&lt;/a&gt;, if you wanted to play along!)&lt;/p&gt;
&lt;p&gt;There are a couple of ways to find something for that &lt;code&gt;n&lt;/code&gt; &lt;code&gt;Nat&lt;/code&gt; kind, and one way is to use the simple inductive &lt;code&gt;Nat&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L26-27&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
         &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You might have seen this type before…it gives us value-level natural numbers, where &lt;code&gt;Z&lt;/code&gt; is zero, &lt;code&gt;S Z&lt;/code&gt; is one, &lt;code&gt;S (S Z)&lt;/code&gt; is two, &lt;code&gt;S (S (S Z))&lt;/code&gt; is three, etc. So if we had something of type &lt;code&gt;Nat&lt;/code&gt;, it could represent any natural number. This declaration gives you:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A type &lt;code&gt;Nat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A value constructor &lt;code&gt;Z :: Nat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A value constructor &lt;code&gt;S :: Nat -&amp;gt; Nat&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, with the &lt;em&gt;DataKinds&lt;/em&gt; extension, when you define this, you also define some extra fancy things. You also define a &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;Nat&lt;/code&gt;! More specifically, you get:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A kind &lt;code&gt;Nat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A type &lt;code&gt;Z :: Nat&lt;/code&gt; (&lt;code&gt;Z&lt;/code&gt;, of &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;Nat&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;A type constructor &lt;code&gt;S :: Nat -&amp;gt; Nat&lt;/code&gt; (&lt;code&gt;S&lt;/code&gt;, which takes something of kind &lt;code&gt;Nat&lt;/code&gt;, and returns a new thing of kind &lt;code&gt;Nat&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(Note that, to be principled, GHC would prefer us to use &lt;code&gt;&#39;Z&lt;/code&gt; and &lt;code&gt;&#39;S&lt;/code&gt; when we are referring to the &lt;em&gt;types&lt;/em&gt;, and this is how it’ll print them out in error messages. But we’re going to run with this for now…mostly for aesthetic reasons)&lt;/p&gt;
&lt;p&gt;We can check this out in GHCi:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;set &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XDataKinds&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So now we have a &lt;em&gt;type&lt;/em&gt; that can encode numbers. Something of type &lt;code&gt;Z&lt;/code&gt; represents zero…something of type &lt;code&gt;S Z&lt;/code&gt; represents 1…something of type &lt;code&gt;S (S Z)&lt;/code&gt; represents two.&lt;/p&gt;
&lt;p&gt;Note that you can’t ever have anything like &lt;code&gt;S Bool&lt;/code&gt;…that doesn’t work, because &lt;code&gt;Bool&lt;/code&gt; is of kind &lt;code&gt;*&lt;/code&gt;, but &lt;code&gt;S&lt;/code&gt; expects only &lt;code&gt;Nat&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;Now we can make our &lt;code&gt;Vec&lt;/code&gt; data type, with the &lt;em&gt;GADTs&lt;/em&gt; extension, or “generalized algebraic data types”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L37-44&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; a
&lt;span class=&quot;ot&quot;&gt;    (:#) ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n) a

&lt;span class=&quot;kw&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)
&lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you’ve never seen GADTs before, think of it as a way of declaring a type by giving the type of your constructors instead of just the normal boring form. It’s nothing too crazy…it’s basically like defining &lt;code&gt;Maybe&lt;/code&gt; as:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a
    &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;instead of&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In both cases, they create constructors of type &lt;code&gt;Nothing :: Maybe a&lt;/code&gt; and &lt;code&gt;Just :: a -&amp;gt; Maybe a&lt;/code&gt; anyway…so the GADT form just gives us a way to state it explicitly.&lt;/p&gt;
&lt;p&gt;Oh, we also used the &lt;em&gt;KindSignatures&lt;/em&gt; extension to be able to give a kind signature to &lt;code&gt;Vec&lt;/code&gt;…this is important because we want to make sure the first argument has to be a &lt;code&gt;Nat&lt;/code&gt;. That is, we can’t have anything silly like &lt;code&gt;Vec Bool Int&lt;/code&gt;. We also have to put a separate &lt;em&gt;StandaloneDeriving&lt;/em&gt;-extension standalone deriving clause instead of just having &lt;code&gt;deriving Show&lt;/code&gt; because &lt;code&gt;Vec&lt;/code&gt; isn’t a type that can be expressed in “normal Haskell”.&lt;/p&gt;
&lt;p&gt;Note that our type is basically like a list:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; []&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    []&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; [a]
&lt;span class=&quot;ot&quot;&gt;    (:) ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Except now our type constructor actually has a new &lt;code&gt;Nat&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This means that, because of type erasure, everything “runtime” on our new type is basically going to be identical to &lt;code&gt;[]&lt;/code&gt; (not considering compiler tricks). In-memory, this new type is essentially exactly &lt;code&gt;[]&lt;/code&gt;, but its type has an extra tag that is erased at compile-time.&lt;/p&gt;
&lt;p&gt;Okay, let’s define some useful methods:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L93-97&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;headV ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n) a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
headV (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; _)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x

&lt;span class=&quot;ot&quot;&gt;tailV ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n) a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a
tailV (_ &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ah, the classic &lt;code&gt;head&lt;/code&gt;/&lt;code&gt;tail&lt;/code&gt; duo from the days pre-dating Haskell. &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; are somewhat of a sore spot or wart in Haskell’s list API&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;, because they’re &lt;em&gt;partial functions&lt;/em&gt;. You tell people all about how Haskell is great because it can prevent run-time errors by ensuring completeness and having the type system enforce null-pointer checks…but then you go ahead and put unsafe functions that throw errors for empty lists anyways in Prelude.&lt;/p&gt;
&lt;p&gt;But here…this will never happen! We can only use &lt;code&gt;headV&lt;/code&gt; and &lt;code&gt;tailV&lt;/code&gt; on non-empty lists…it won’t typecheck for empty lists. Do you see why?&lt;/p&gt;
&lt;p&gt;It’s because all empty lists are of type &lt;code&gt;Vec Z a&lt;/code&gt;. But &lt;code&gt;headV&lt;/code&gt; and &lt;code&gt;tailV&lt;/code&gt; only take things of &lt;em&gt;type&lt;/em&gt; &lt;code&gt;Vec (S n) a&lt;/code&gt;, for any &lt;code&gt;Nat&lt;/code&gt; &lt;code&gt;n&lt;/code&gt;. So, if you ever try to use it on an empty list, it won’t even compile! No more pesky runtime bugs. &lt;code&gt;headV&lt;/code&gt; and &lt;code&gt;tailV&lt;/code&gt; are safe and will never crash at runtime!&lt;/p&gt;
&lt;p&gt;Note that the return type of &lt;code&gt;tailV&lt;/code&gt; is a vector of a length one less than the given vector. &lt;code&gt;tailV :: Vec (S Z) a -&amp;gt; Vec Z a&lt;/code&gt;, for instance…or &lt;code&gt;tailV :: Vec (S (S Z)) a -&amp;gt; Vec (S Z) a&lt;/code&gt;. Just like we want!&lt;/p&gt;
&lt;p&gt;If you tried implementing this yourself, you might notice that you actually get an &lt;em&gt;error&lt;/em&gt; from GHC if you even &lt;em&gt;try&lt;/em&gt; to handle the &lt;code&gt;Nil&lt;/code&gt; case for &lt;code&gt;tailV&lt;/code&gt; or &lt;code&gt;headV&lt;/code&gt;. GHC will know when you’ve handled all possible cases, and get mad at you if you try to handle a case that doesn’t even make sense!&lt;/p&gt;
&lt;h3 id=&quot;type-families-and-appending&quot;&gt;Type families and appending&lt;/h3&gt;
&lt;p&gt;We can also “append” vectors. But we need a way to add &lt;code&gt;Nat&lt;/code&gt;s together first. For that, we can use a type family, using the &lt;em&gt;TypeFamilies&lt;/em&gt; extension (with &lt;code&gt;TypeOperators&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L29-31&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; family (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;y ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;ch&quot;&gt;&amp;#39;Z   + y = y&lt;/span&gt;
    &lt;span class=&quot;ch&quot;&gt;&amp;#39;S x + y = &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A “type family” is like a type level function. Compare this to defining &lt;code&gt;(+)&lt;/code&gt; on the value level to the &lt;code&gt;Nat&lt;/code&gt; &lt;em&gt;data&lt;/em&gt; type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L33-35&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;(+#) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- types!&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;   &lt;span class=&quot;fu&quot;&gt;+#&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; y
&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+#&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;+#&lt;/span&gt; y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, we’re defining a new type-level function &lt;code&gt;(+)&lt;/code&gt; on two types &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, both of kind &lt;code&gt;Nat&lt;/code&gt;…and the result is their “sum”. Convince yourself that this “addition” is actually addition. Now, let’s use it for &lt;code&gt;appendV&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L99-101&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;appendV ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; m) a
appendV &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;       ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ys
appendV (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; appendV xs ys&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v1 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; v1 &lt;span class=&quot;ot&quot;&gt;`appendV`&lt;/span&gt; v2
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t v1 &lt;span class=&quot;ot&quot;&gt;`appendV`&lt;/span&gt; v2
v1 &lt;span class=&quot;ot&quot;&gt;`appendV` v2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;generating&quot;&gt;Generating&lt;/h3&gt;
&lt;p&gt;It’d be nice to have type-safe methods of &lt;em&gt;generating&lt;/em&gt; these things, too…functions like &lt;code&gt;iterate&lt;/code&gt;, or &lt;code&gt;enumFrom&lt;/code&gt;. One of the ways to do this is by using a typeclass. (Available in a &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs&quot;&gt;separate file&lt;/a&gt; to try out).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L7-8&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; v &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    unfold ::&lt;/span&gt; (b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a, b)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We’re going to call &lt;code&gt;v&lt;/code&gt; an &lt;code&gt;Unfoldable&lt;/code&gt; if you can build a &lt;code&gt;v&lt;/code&gt; from an “unfolding function” and an “initial state”. Run the function on the initial value and get the first item and a new state. Run the function on the new state and get the second item and the next state.&lt;/p&gt;
&lt;p&gt;The list instance should make it more clear:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L11-13&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; [] &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    unfold f x0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, x1) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x0
                  &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  y &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; unfold f x1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; take &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; unfold (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (x &lt;span class=&quot;ot&quot;&gt;`mod`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)) &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
[&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we can have an instance for any fixed-length vector type…where the thing “cuts off” after it’s filled the entire vector:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L46-51&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    unfold _ _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    unfold f x0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, x1) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x0
                  &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  y &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; unfold f x1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Take a moment to think about what these instances are doing.&lt;/p&gt;
&lt;p&gt;You can create a &lt;code&gt;Vec Z a&lt;/code&gt; from an unfolding function pretty easily, because the only thing with type &lt;code&gt;Vec Z a&lt;/code&gt; is &lt;code&gt;Nil&lt;/code&gt;. So just ignore the function/initial state and return &lt;code&gt;Nil&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The instance for &lt;code&gt;Vec (S n)&lt;/code&gt; is slightly more involved. To make a &lt;code&gt;Vec (S n) a&lt;/code&gt;, you need an &lt;code&gt;a&lt;/code&gt; and a &lt;code&gt;Vec n a&lt;/code&gt;. You can get the &lt;code&gt;a&lt;/code&gt; from the unfolding function…but where will you get the &lt;code&gt;Vec n a&lt;/code&gt; from? Well, you can use &lt;code&gt;unfold&lt;/code&gt; to make a &lt;code&gt;Vec n a&lt;/code&gt;! But that only makes sense if &lt;code&gt;Vec n&lt;/code&gt; is an &lt;code&gt;Unfoldable&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So, that’s why in the instance for &lt;code&gt;Vec (S n)&lt;/code&gt;, we constrain that &lt;code&gt;Vec n&lt;/code&gt; must also be an &lt;code&gt;Unfoldable&lt;/code&gt;. We make our result by using our function to create an &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;unfold&lt;/code&gt; to create a &lt;code&gt;Vec n a&lt;/code&gt; (provided &lt;code&gt;Vec n&lt;/code&gt; is an &lt;code&gt;Unfoldable&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Note that this style of declaration looks a lot like induction. We define our instance for zero…and then we say, “if &lt;code&gt;n&lt;/code&gt; is an instance, then so is &lt;code&gt;S n&lt;/code&gt;”. Induction!&lt;/p&gt;
&lt;p&gt;Let’s see this in action.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L15-24&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;replicateU ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; v &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v a
replicateU &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; unfold (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (x, x))

&lt;span class=&quot;ot&quot;&gt;iterateU ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; v &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v a
iterateU f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; unfold (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (x, f x))

&lt;span class=&quot;ot&quot;&gt;fromListMaybes ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; v &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a)
fromListMaybes &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; unfold &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \l &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; l &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                                  []   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, [])
                                  x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; x , xs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; replicateU &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;       ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; replicateU &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;       ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; iterateU succ &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;      ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListMaybes [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; tailV (iterateU succ &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;replicateU&lt;/code&gt; doesn’t need to take in an &lt;code&gt;Int&lt;/code&gt; parameter, like the on in Prelude, to say how many items to have. It just replicates enough to fill the entire vector we want!&lt;/p&gt;
&lt;h3 id=&quot;common-typeclasses&quot;&gt;Common Typeclasses&lt;/h3&gt;
&lt;p&gt;We can go in and implement common typeclasses, too. All the ones you’d expect.&lt;/p&gt;
&lt;p&gt;We can actually use the &lt;em&gt;DeriveFunctor&lt;/em&gt; extension to write a &lt;code&gt;Functor&lt;/code&gt; instance, but let’s write one on our own just for learning purposes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L53-55&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fmap _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
    fmap f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; fmap f xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For &lt;code&gt;Applicative&lt;/code&gt;, it isn’t so simple. The Applicative instance is going to be the “ZipList” instance…so we have to be able to make a &lt;code&gt;pure&lt;/code&gt; that depends on the type, and a &lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt; that depends on the type, too.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L57-63&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    pure _    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    pure x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; pure x
    (f &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; fs) &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; (fs &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; xs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For &lt;code&gt;Vec Z&lt;/code&gt;, it’s just &lt;code&gt;Nil&lt;/code&gt;. For &lt;code&gt;Vec (S n)&lt;/code&gt;…for pure, you need &lt;code&gt;x :#&lt;/code&gt; something…and that something has to be a &lt;code&gt;Vec n a&lt;/code&gt;. That’s just &lt;code&gt;pure&lt;/code&gt; for &lt;code&gt;Vec n&lt;/code&gt;! Remember, we can’t assume that &lt;code&gt;Vec n&lt;/code&gt; is an &lt;code&gt;Applicative&lt;/code&gt; just because &lt;code&gt;Vec (S n)&lt;/code&gt; is. So we need to add a constraint, that &lt;code&gt;Vec n&lt;/code&gt; an Applicative. Induction, again!&lt;/p&gt;
&lt;p&gt;For &lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt;, we can get the first item easily, it’s just &lt;code&gt;f x&lt;/code&gt;. But for the next item, we need a &lt;code&gt;Vec n a&lt;/code&gt;. Luckily…we have exactly that with the &lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt; for &lt;code&gt;Vec n&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;Remember, at the end, we’re saying “We have an &lt;code&gt;Applicative&lt;/code&gt; instance for &lt;em&gt;any&lt;/em&gt; type &lt;code&gt;Vec n&lt;/code&gt;”. The instance for &lt;code&gt;Vec Z&lt;/code&gt; has &lt;code&gt;pure _ = Nil&lt;/code&gt;. The instance for &lt;code&gt;Vec (S Z)&lt;/code&gt; has &lt;code&gt;pure x = x :# Nil&lt;/code&gt;. The instance for &lt;code&gt;Vec (S (S Z))&lt;/code&gt; has &lt;code&gt;pure x = x :# x :# Nil&lt;/code&gt;, etc. etc.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fmap (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; pure &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;         &lt;span class=&quot;co&quot;&gt;-- like replicateV!&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; liftA2 (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;) (&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;302&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;101&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;203&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;305&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I’ll leave the &lt;code&gt;Monad&lt;/code&gt; instance as an exercise, but it’s in the source files for this post. &lt;code&gt;join&lt;/code&gt; for this instance should be a “diagonal” — the first item of the first vector, the second item of the second vector, the third item of the third vector, etc.&lt;/p&gt;
&lt;p&gt;We can define &lt;code&gt;Foldable&lt;/code&gt; and &lt;code&gt;Traversable&lt;/code&gt; the same way. Like for &lt;code&gt;Functor&lt;/code&gt;, GHC can derive these with &lt;em&gt;DeriveFoldable&lt;/em&gt; and &lt;em&gt;DeriveTraversable&lt;/em&gt;…but we’ll do it again here just to demonstrate.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L65-75&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    foldMap _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mempty

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    foldMap f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; foldMap f xs

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    traverse _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; pure &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    traverse f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftA2 (&lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt;) (f x) (traverse f xs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we can only use &lt;code&gt;foldMap f xs&lt;/code&gt; on &lt;code&gt;xs :: Vec n a&lt;/code&gt;, if &lt;code&gt;Vec n&lt;/code&gt; is a &lt;code&gt;Foldable&lt;/code&gt;. So that’s why we add that constraint.&lt;/p&gt;
&lt;p&gt;Again, &lt;code&gt;liftA2 (:#) :: Applicative f =&amp;gt; f a -&amp;gt; f (Vec n a) -&amp;gt; f (Vec (S n) a)&lt;/code&gt;…so this only makes sense if &lt;code&gt;traverse f s&lt;/code&gt; gives us a &lt;code&gt;Vec n a&lt;/code&gt;. So we have to add that as a constraint.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; toList &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; traverse &lt;span class=&quot;dt&quot;&gt;Identity&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Identity&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; sequence_ &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; sequence &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; sequence &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Traversable&lt;/code&gt; of course opens a whole lot of doors. For example, we can write a “safe &lt;code&gt;fromList&lt;/code&gt;”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L26-27&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;fromListU ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; v, &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; v) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (v a)
fromListU &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sequence &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromListMaybes&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListU [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListU [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListU [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And, if you’re on GHC 7.8+, you have access to the &lt;em&gt;OverloadedLists&lt;/em&gt; language extension, where you can interpret list literals as if they were other structures.&lt;/p&gt;
&lt;p&gt;We’ve already already implemented both &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;toList&lt;/code&gt;, in a way, already, so this should be a breeze. The only trick you might see is that the &lt;code&gt;IsList&lt;/code&gt; typeclass asks for a type family to return the &lt;em&gt;type of the element in the container&lt;/em&gt; from the container type.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L86-91&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n), &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n)) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;L.IsList&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Item&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; a
    fromList xs &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; fromListU xs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; error &lt;span class=&quot;st&quot;&gt;&amp;quot;Demanded vector from a list that was too short.&amp;quot;&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; ys &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; ys
    toList      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; Data.Foldable.toList&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;set &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XOverloadedLists&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demanded&lt;/span&gt; vector from a list that was too short&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat! All of the benefits of list literals that &lt;em&gt;OverloadedLists&lt;/em&gt; offers is now available to us.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; Unfortunately, you now open yourself up to runtime errors, so…it’s actually a really bad idea for safety purposes unless you stick to only using it with infinite lists or are very disciplined. (Unless you really want to use list syntax, &lt;code&gt;fromListU&lt;/code&gt; is probably a safer choice for finite lists!)&lt;/p&gt;
&lt;h3 id=&quot;indexing&quot;&gt;Indexing&lt;/h3&gt;
&lt;p&gt;It’d be nice to be able to index into these, of course. For type-safe indexing, we can take advantage of a trick using the &lt;code&gt;Proxy&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;Many might remember having to get a &lt;code&gt;TypeRep&lt;/code&gt; for a &lt;code&gt;Typeable&lt;/code&gt; instance by doing something like &lt;code&gt;typeOf (undefined :: IO Double)&lt;/code&gt;. That’s because &lt;code&gt;typeOf :: Typeable a =&amp;gt; a -&amp;gt; TypeRep&lt;/code&gt;. If you wanted to get the &lt;code&gt;typeRep&lt;/code&gt; for an &lt;code&gt;IO Double&lt;/code&gt; using &lt;code&gt;typeOf&lt;/code&gt;, you have to pass in an &lt;code&gt;IO Double&lt;/code&gt;. But if you don’t have one at hand, you can just use &lt;code&gt;undefined&lt;/code&gt; with a type annotation. It’s a bit of a dirty hack, but it works because &lt;code&gt;typeOf&lt;/code&gt; doesn’t care about the first argument’s value…just its type.&lt;/p&gt;
&lt;p&gt;These days, we like to be a bit less embarrassing and use something called &lt;code&gt;Proxy&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Proxy a&lt;/code&gt; is a bit like &lt;code&gt;()&lt;/code&gt;. It only has one constructor, and doesn’t take any arguments. But we can use the type signature to “pass in types” to functions, as “arguments”.&lt;/p&gt;
&lt;p&gt;We have a couple of options here. One is to make a typeclass for type level nats to turn them into an &lt;code&gt;Integer&lt;/code&gt; or a value-level &lt;code&gt;Nat&lt;/code&gt;, and then do an “unsafe indexing” after verifying, through types, that the index is smaller than the length.&lt;/p&gt;
&lt;p&gt;However, this is a little bit silly because we’re just doing an unsafe indexing in the end anyway, so the compiler can’t help us at all. Wouldn’t it be nice if we could get the compiler on our side and write a &lt;em&gt;real&lt;/em&gt; safe index?&lt;/p&gt;
&lt;p&gt;There are many ways to approach this problem, but one way is to make a specific &lt;code&gt;Index&lt;/code&gt; typeclass: (or make another typeclass like &lt;code&gt;Take&lt;/code&gt;, and write &lt;code&gt;index&lt;/code&gt; in terms of it)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L77-78&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;n ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;) v &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    index ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, we can say that &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are instances of &lt;code&gt;Index n v&lt;/code&gt; if and only if you can safely (totally) index into &lt;code&gt;v a&lt;/code&gt; at index &lt;code&gt;n&lt;/code&gt;. That is, if every value of type &lt;code&gt;v a&lt;/code&gt; ever has an index at &lt;code&gt;n&lt;/code&gt;, a &lt;code&gt;Nat&lt;/code&gt;. (By the way, we need &lt;em&gt;MultiParamTypeClasses&lt;/em&gt; to be able to make a type class with two parameters)&lt;/p&gt;
&lt;p&gt;So, &lt;code&gt;n ~ S Z&lt;/code&gt; and &lt;code&gt;v ~ Vec (S (S Z)) a&lt;/code&gt; has an instance, because you can get the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n%20%3D%201&quot; alt=&quot;n = 1&quot; title=&quot;n = 1&quot; /&gt; element (the second element) from &lt;em&gt;any&lt;/em&gt; value of type &lt;code&gt;Vec (S (S Z)) a&lt;/code&gt; (a length-two vector).&lt;/p&gt;
&lt;p&gt;But &lt;code&gt;n ~ S Z&lt;/code&gt; and &lt;code&gt;v ~ Vec (S Z) a&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt;. There are actually &lt;em&gt;no&lt;/em&gt; length-1 vectors that have a &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?1&quot; alt=&quot;1&quot; title=&quot;1&quot; /&gt; index (second element).&lt;/p&gt;
&lt;p&gt;Note that we use the &lt;code&gt;Proxy&lt;/code&gt; trick we discussed, so that we can indicate somehow what index we really want. It is a trick that basically allows us to pass a &lt;em&gt;type&lt;/em&gt; (&lt;code&gt;S Z&lt;/code&gt;, &lt;code&gt;S (S Z)&lt;/code&gt;, etc.) as a “value”.&lt;/p&gt;
&lt;p&gt;Let’s write our instances — but only the instances that &lt;em&gt;make sense&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L80-84&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    index _ (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; _) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; forall n m&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; n (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n) (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; m)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    index _ (_ &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n) xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first case instance makes sense. We can definitely index at index &lt;code&gt;Z&lt;/code&gt; (zero) of &lt;em&gt;any&lt;/em&gt; &lt;code&gt;Vec (S n) a&lt;/code&gt; — the only thing we can’t index &lt;code&gt;Z&lt;/code&gt; into is &lt;code&gt;Vec Z a&lt;/code&gt;. So, if our vector is of length 1 or higher, we can index at position 0.&lt;/p&gt;
&lt;p&gt;The second case says that, if we can index into &lt;code&gt;n&lt;/code&gt; of a &lt;code&gt;Vec m a&lt;/code&gt;, then of course we can index into an &lt;code&gt;S n&lt;/code&gt; of a &lt;code&gt;Vec (S m) a&lt;/code&gt;. To index into &lt;code&gt;S n&lt;/code&gt; of a &lt;code&gt;Vec (S m) a&lt;/code&gt;, all we need to do is index into &lt;code&gt;n&lt;/code&gt; of the &lt;code&gt;Vec m a&lt;/code&gt; tail!&lt;/p&gt;
&lt;p&gt;We have to use the &lt;em&gt;ScopedTypeVariables&lt;/em&gt; extension to enable us to use, with the &lt;code&gt;forall&lt;/code&gt; statement, the &lt;code&gt;n&lt;/code&gt; in our instance when we are writing our type for &lt;code&gt;Proxy&lt;/code&gt;. If we didn’t, the &lt;code&gt;n&lt;/code&gt; in &lt;code&gt;Proxy n&lt;/code&gt; in our &lt;code&gt;index&lt;/code&gt; definition would be considered unrelated by GHC to the &lt;code&gt;n&lt;/code&gt; in the instance statement, &lt;code&gt;Index (S n) (Vec (S m))&lt;/code&gt;. (This is the only reason we need the &lt;code&gt;forall&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;In any case, note the similarity of this algorithm to the actual indexing function on lists:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!!&lt;/span&gt; (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_ ) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x
n &lt;span class=&quot;fu&quot;&gt;!!&lt;/span&gt; (_&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;!!&lt;/span&gt; xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;trying it out…&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Compile&lt;/span&gt; error&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It’s an error, but remember, it’s a &lt;em&gt;compiler&lt;/em&gt; error, that happens before any code is ever even run! No more indexing errors at runtime! Kiss your days of hunting segfault errors in C goodbye!&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This is something I haven’t really been able to find a good answer too. But notice that we actually could have written a “bad” instance of the second instance of &lt;code&gt;Index&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; n) (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; m)) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    index _ (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; _) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And this compiles fine…but gives the wrong behavior, or at least the behavior we don’t want!&lt;/p&gt;
&lt;p&gt;Does anybody know a way to state the type of &lt;code&gt;Index&lt;/code&gt; or &lt;code&gt;index&lt;/code&gt; in a way that implementations like this are impossible?&lt;/p&gt;
&lt;p&gt;There’s a “fundamental” problem here, it seems, because we can’t really demand or specify anything by the return type, like we could in the other examples. In the other examples, we sort of restricted the implementation by choosing our return type carefully…but for here, it’s just &lt;code&gt;a&lt;/code&gt;. I’d love to hear if anyone has any thoughts on this.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;You might notice that it’s a bit of a plain to write &lt;code&gt;S (S (S (S Z)))&lt;/code&gt;, etc., especially for large numbers. And I wouldn’t even think about writing it for the hundreds.&lt;/p&gt;
&lt;p&gt;We’ll “fix” this in the next section. However, even before this, you actually can generate these “automatically” with template haskell, using techniques from &lt;a href=&quot;http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf&quot;&gt;Functional Pearls: Implicit Configurations&lt;/a&gt;, and the &lt;a href=&quot;http://hackage.haskell.org/package/linear-1.18.0.1/docs/Linear-V.html&quot;&gt;linear&lt;/a&gt; package does just this. (This path slipped my mind before I posted because I didn’t really consider template Haskell, and I think I’ll edit in a section here soon). With this in mind, I still don’t really consider Template Haskell an optimal or clean approach :)&lt;/p&gt;
&lt;h2 id=&quot;using-typelits-and-type-checker-plugins&quot;&gt;Using TypeLits and Type Checker Plugins&lt;/h2&gt;
&lt;p&gt;(This next section uses code that is &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs&quot;&gt;also available online&lt;/a&gt;, as well!)&lt;/p&gt;
&lt;p&gt;Using a custom &lt;code&gt;Nat&lt;/code&gt; kind and &lt;em&gt;DataKinds&lt;/em&gt; is nice and all, but it’s a bit of a hassle to express large numbers like 100, 1000, etc. However, as of GHC 7.8, we’ve had the ability to actually &lt;em&gt;use&lt;/em&gt; numeric (integer) literals in our types. Instead of writing &lt;code&gt;S (S Z)&lt;/code&gt;, we can write &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;GHC can’t yet quite work with that well by default. It has trouble proving statements about variables, like &lt;code&gt;(n + 1) ~ (1 + n)&lt;/code&gt; (that &lt;code&gt;n + 1&lt;/code&gt; is “the same as” &lt;code&gt;1 + n&lt;/code&gt;). Fortunately for us, since GHC 7.10, we have a way to “extend” the type checker with custom plugins that &lt;em&gt;can&lt;/em&gt; prove things like this for us. (Note that this &lt;code&gt;+&lt;/code&gt; is the one from &lt;code&gt;GHC.TypeLits&lt;/code&gt;…not the one we defined earlier.)&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/ghc-typelits-natnormalise&quot;&gt;ghc-typelits-natnormalise&lt;/a&gt;&lt;/em&gt; package is a package providing such a plugin. We can have GHC use it to extend its type checking by passing in &lt;code&gt;-fplugin GHC.TypeLits.Normalise&lt;/code&gt; when we execute our code, or by adding a pragma:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L14-14&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to the top of our file, along with our &lt;code&gt;LANGUAGE&lt;/code&gt; pragmas. (Assuming, of course, a GHC 7.10+)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;set &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XDataKinds&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XTypeOperators&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XTypeFamilies&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;GHC.TypeLits&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; ((n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;~&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; n)) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Compile&lt;/span&gt; error&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cannot&lt;/span&gt; match &lt;span class=&quot;ot&quot;&gt;`1 + n`&lt;/span&gt; with &lt;span class=&quot;ot&quot;&gt;`n + 1`&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;set &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;fplugin &lt;span class=&quot;dt&quot;&gt;GHC.TypeLits.Normalise&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; ((n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;~&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; n)) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n
&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- success!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GHC now uses the plugin to prove that the two are really equivalent.&lt;/p&gt;
&lt;p&gt;If you wanted to play along or try out the code samples, I recommend you use a sandbox:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# in directory of your choice&lt;/span&gt;
$ &lt;span class=&quot;kw&quot;&gt;cabal&lt;/span&gt; sandbox init
$ &lt;span class=&quot;kw&quot;&gt;cabal&lt;/span&gt; install ghc-typelits-natnormalise
$ &lt;span class=&quot;kw&quot;&gt;cabal&lt;/span&gt; exec bash
&lt;span class=&quot;co&quot;&gt;# now the package is in scope, when you use ghci or runghc&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With that in mind, let’s start restating everything in terms of &lt;em&gt;TypeLits&lt;/em&gt; and see what it gains us.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L33-40&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; a
&lt;span class=&quot;ot&quot;&gt;    (:#) ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a

&lt;span class=&quot;kw&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)
&lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A little nicer, right? &lt;code&gt;Nil&lt;/code&gt; is a &lt;code&gt;Vec 0 a&lt;/code&gt;, and &lt;code&gt;x :# xs&lt;/code&gt; is an element with a &lt;code&gt;Vec (n - 1) a&lt;/code&gt;, which overall is a &lt;code&gt;Vec n a&lt;/code&gt;. Let’s go over everything again to see how it’d look in the new regime. (Note that the kind of the type number literals is also called &lt;code&gt;Nat&lt;/code&gt;…unrelated to our &lt;code&gt;Nat&lt;/code&gt; we used before.)&lt;/p&gt;
&lt;h2 id=&quot;a-new-look&quot;&gt;A new look&lt;/h2&gt;
&lt;p&gt;First of all, we’re going to have to define &lt;em&gt;TypeLit&lt;/em&gt; comparison operators, as they aren’t built in in a useful way.&lt;/p&gt;
&lt;p&gt;We have the type family (remember those?) &lt;code&gt;CmpNat x y&lt;/code&gt;, which returns an &lt;code&gt;Ordering&lt;/code&gt; (&lt;code&gt;LT&lt;/code&gt;, &lt;code&gt;EQ&lt;/code&gt;, or &lt;code&gt;GT&lt;/code&gt;) type (of kind &lt;code&gt;Ordering&lt;/code&gt;, using &lt;em&gt;DataKinds&lt;/em&gt;…lifting a type and its value constructors to a kind and its types), which is provided and defined for us by GHC in &lt;code&gt;GHC.TypeLits&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So defining a &lt;code&gt;x &amp;gt; y&lt;/code&gt; constraint is pretty straightforward:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L31-31&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CmpNat&lt;/span&gt; x y &lt;span class=&quot;fu&quot;&gt;~&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;GT&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we need the &lt;em&gt;ConstraintKinds&lt;/em&gt; extension for this to work, as &lt;code&gt;1 &amp;gt; 2&lt;/code&gt; is now a &lt;em&gt;constraint&lt;/em&gt;, of kind &lt;code&gt;Constraint&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Given this, let’s do our favorite list functions, &lt;code&gt;headV&lt;/code&gt; and &lt;code&gt;tailV&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L89-93&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;headV ::&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
headV (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; _)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x

&lt;span class=&quot;ot&quot;&gt;tailV ::&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) a
tailV (_ &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Magnificent!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; headV (&lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; ())
&lt;span class=&quot;co&quot;&gt;-- Error!  Cannot unite &amp;#39;EQ with &amp;#39;GT&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat! The error, remember, is at &lt;em&gt;compile time&lt;/em&gt;, and not at runtime. If we ever tried to do an unsafe head, our code wouldn’t even &lt;em&gt;compile&lt;/em&gt;! The error message comes from the fact that we need &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n%20%3E%200&quot; alt=&quot;n &amp;gt; 0&quot; title=&quot;n &amp;gt; 0&quot; /&gt;, but we have &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n%20%3D%200&quot; alt=&quot;n = 0&quot; title=&quot;n = 0&quot; /&gt; instead. We have &lt;code&gt;EQ&lt;/code&gt;, but we need &lt;code&gt;GT&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There is one problem here, though — GHC gives us a warning for not pattern matching on &lt;code&gt;Nil&lt;/code&gt;. But, if we do try to pattern match on &lt;code&gt;Nil&lt;/code&gt;, we get a type error, like the same one we got when using our custom type nats. I think this is probably something that a plugin or sufficiently smart &lt;code&gt;CmpNat&lt;/code&gt; might be able to handle…but I’m not totally sure. Right now, the best thing I can think of is just to do a wildcard match, &lt;code&gt;headV _ = error &amp;quot;What?&amp;quot;&lt;/code&gt;, knowing that that case will never be reached if your program compiles successfully.&lt;/p&gt;
&lt;p&gt;Moving on, we see that we don’t even have to do any extra work to define our own type family &lt;code&gt;x + y&lt;/code&gt;…because &lt;code&gt;GHC.TypeLits&lt;/code&gt; already defines it for us! So, we can instantly write….&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L95-97&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;appendV ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; m) a
appendV &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;       ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ys
appendV (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; appendV xs ys&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v1 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; iterateU succ &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; v1 &lt;span class=&quot;ot&quot;&gt;`appendV`&lt;/span&gt; v2
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t v1 &lt;span class=&quot;ot&quot;&gt;`appendV` v2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
v1 &lt;span class=&quot;ot&quot;&gt;`appendV` v2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And our list generating typeclasses —&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L42-47&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    unfold _ _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)), n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    unfold f x0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; (y, x1) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x0
                  &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  y &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; unfold f x1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The translation is pretty mechanical, but I think that this new formulation looks…really nice, and really powerful. “If you can build a list from &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n%20-%201&quot; alt=&quot;n - 1&quot; title=&quot;n - 1&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n%20%3E%200&quot; alt=&quot;n &amp;gt; 0&quot; title=&quot;n &amp;gt; 0&quot; /&gt;, then you can build a list for &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?n&quot; alt=&quot;n&quot; title=&quot;n&quot; /&gt;!&lt;/p&gt;
&lt;p&gt;Note that because our definitions of &lt;code&gt;replicateU&lt;/code&gt;, &lt;code&gt;iterateU&lt;/code&gt;, and &lt;code&gt;fromListMaybes&lt;/code&gt; was polymorphic over all &lt;code&gt;Unfoldable&lt;/code&gt;, we can actually re-use them from before:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; iterateU succ &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; int
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; iterateU succ &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; replicateU &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The actual types are much nicer, too — we can write &lt;code&gt;Vec 10 Int&lt;/code&gt; instead of &lt;code&gt;Vec (S (S (S (S (S (S (S (S (S (S Z)))))))))) Int&lt;/code&gt; without resorting to template haskell.&lt;/p&gt;
&lt;p&gt;Going through all of our other typeclasses/functions and making the adjustments… (remembering that we can also derive &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt;, and &lt;code&gt;Foldable&lt;/code&gt; using GHC)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L49-87&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fmap _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
    fmap f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; fmap f xs

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    pure _    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)), n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    pure x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; pure x
    (f &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; fs) &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; (fs &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; xs)

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    foldMap _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mempty

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)), n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    foldMap f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; foldMap f xs

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    traverse _ &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; pure &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)), n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    traverse f (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftA2 (&lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt;) (f x) (traverse f xs)

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;n ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;) v &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    index ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (m &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    index _ (x &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; _) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; forall n m&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (m &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)), n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, m &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Index&lt;/span&gt; n (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    index _ (_ &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)) xs

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Unfoldable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n), &lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n)) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;L.IsList&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Item&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; a
    fromList xs &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; fromListU xs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; error &lt;span class=&quot;st&quot;&gt;&amp;quot;Demanded vector from a list that was too short.&amp;quot;&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; ys &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; ys
    toList      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; Data.Foldable.toList&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Remember, we use the &lt;code&gt;forall&lt;/code&gt; here with &lt;em&gt;ScopedTypeVariables&lt;/em&gt; to be able to say that the &lt;code&gt;n&lt;/code&gt; in the type signature is the same &lt;code&gt;n&lt;/code&gt; that is in the type of &lt;code&gt;Proxy&lt;/code&gt;)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListU [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromListU [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; index (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Couldn&amp;#39;t&lt;/span&gt; match &lt;span class=&quot;ch&quot;&gt;&amp;#39;EQ with &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;GT&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;set &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;XOverloadedLists&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demanded&lt;/span&gt; vector from a list that was too short&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:#&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I think, overall, this formulation gives a much nicer interface. Being able to just write &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?10&quot; alt=&quot;10&quot; title=&quot;10&quot; /&gt; is pretty powerful. The usage with &lt;em&gt;OverloadedLists&lt;/em&gt; is pretty clean, too, especially when you can do things like &lt;code&gt;[1,3..] :: Vec 10 Int&lt;/code&gt; and take full advantage of list syntax and succinct vector types. (Minding your runtime errors, of course)&lt;/p&gt;
&lt;p&gt;However, you do again get the problem that GHC is not able to do real completeness checking and asks for the &lt;code&gt;Nil&lt;/code&gt; cases still of everything…but adding a &lt;code&gt;Nil&lt;/code&gt; case will cause a type error. The only solution is to add a &lt;code&gt;_&lt;/code&gt; wildcard chase, but…again, this isn’t quite satisfactory.&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; If anybody has a way to get around this, I’d love to know :)&lt;/p&gt;
&lt;h2 id=&quot;alternative-underlying-representations&quot;&gt;Alternative Underlying Representations&lt;/h2&gt;
&lt;p&gt;Recall that our &lt;code&gt;Vec&lt;/code&gt; was basically identically the normal list type, with an extra field in the type. Due to type erasure, the two are represented exactly the same in memory. So we have &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?O%28n%29&quot; alt=&quot;O(n)&quot; title=&quot;O(n)&quot; /&gt; appends, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?O%28n%29&quot; alt=&quot;O(n)&quot; title=&quot;O(n)&quot; /&gt; indexing, etc. Our type is essentially equal to&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;VecList&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For this type, though, we’d need to use “smart constructors” and extractors instead of &lt;code&gt;1 :# 2 :# Nil&lt;/code&gt; etc.&lt;/p&gt;
&lt;p&gt;We could, however, chose a more efficient type, like &lt;code&gt;Vector&lt;/code&gt; from the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/vector-0.10.12.2/docs/Data-Vector.html#t:Vector&quot;&gt;vector&lt;/a&gt;&lt;/em&gt; package:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;VecVector&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And, if you made sure to wrap everything with smart constructors, you now have &lt;em&gt;type safe&lt;/em&gt; &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?O%281%29&quot; alt=&quot;O(1)&quot; title=&quot;O(1)&quot; /&gt; random indexing!&lt;/p&gt;
&lt;p&gt;(This is representation is similar to the one used by the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/linear-1.18.0.1/docs/Linear-V.html&quot;&gt;linear&lt;/a&gt;&lt;/em&gt; package.)&lt;/p&gt;
&lt;h2 id=&quot;more-operations&quot;&gt;More Operations&lt;/h2&gt;
&lt;p&gt;One really weird quirk with this is that many functions you’d normally write using pattern matching you’d now might start writing using typeclasses. One example would be our implementation of indexing, using an &lt;code&gt;IndexV&lt;/code&gt; typeclass.&lt;/p&gt;
&lt;p&gt;A bunch of one-shot typeclasses is sort of unideal, as typeclasses are sort of ugly and non-first-class. Ideally you’d only have a few typeclasses for as generic an interface as possible, and then be able to do everything from those. Sometimes this just isn’t practical. I did mention one way around it, which was to make a typeclass to “reify” or turn your type into actual data, and then manipulate your data in an “unsafe” way knowing that the type checker checked that the data matched.&lt;/p&gt;
&lt;p&gt;We’ll demonstrate with &lt;code&gt;SomeNat&lt;/code&gt; from &lt;code&gt;GHC.TypeLits&lt;/code&gt;, but you can also make our own for our inductive &lt;code&gt;Nat&lt;/code&gt; type we used in the first half, too.&lt;/p&gt;
&lt;p&gt;If we use our “wrapped &lt;code&gt;Vector&lt;/code&gt; approach”, we can just do:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a

index&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n, m &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
index p (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; v) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; v &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt; fromInteger (natVal p)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That is, &lt;code&gt;index&lt;/code&gt; internally uses &lt;code&gt;(!)&lt;/code&gt;, an unsafe operator…but only after we assure properly that it’s safe to use by stating &lt;code&gt;m &amp;gt; n&lt;/code&gt; in the constraint. We can be sure that GHC will catch any instance where someone tries to index into a &lt;code&gt;Vec m a&lt;/code&gt; whose &lt;code&gt;m&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; greater than the index desired.&lt;/p&gt;
&lt;p&gt;The rest is up to you, though — to prove that indexing into a number smaller than &lt;code&gt;m&lt;/code&gt; will always provide an answer. We have to make sure our smart constructors are okay and that &lt;code&gt;(!)&lt;/code&gt; behaves like we think it does.&lt;/p&gt;
&lt;h2 id=&quot;singletons&quot;&gt;Singletons&lt;/h2&gt;
&lt;p&gt;Another answer to these sort of ad-hoc typeclasses is to use techniques involving singletons. Going all into how to use singletons to work with these is an article on its own…luckily, this article has already been written as &lt;a href=&quot;https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell&quot;&gt;Part 1: Dependent Types in Haskell&lt;/a&gt; by Hiromi ISHII. A major advantage is that you replace typeclasses with type families and more parameterized types. You’ll have to work with an understanding of how singletons work, and accept using some template haskell to generate singleton types for your data types (or write them yourself!). But it’s a powerful way to bring something like dependent types into Haskell, and there’s already a lot of infrastructure of support on it on hackage and in the haskell dev ecosystem in general. I recommend looking at the linked article!&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Hopefully you’ll see that we are able to apply the full type-safety of the Haskell compiler to our programs regarding lists by encoding the length of the list in its type and limiting its operations by specifically typed functions and choice of instances. I also hope that you’ve been able to become familiar with seeing a lot of GHC’s basic type extensions in real applications :)&lt;/p&gt;
&lt;p&gt;Feel free to &lt;a href=&quot;https://github.com/mstksg/inCode/blob/master/code-samples/fixvec&quot;&gt;download and run&lt;/a&gt; any of the samples&lt;/p&gt;
&lt;p&gt;Please let me know if I got anything wrong, or if there are any techniques that I should mention here that are out and in the wild today :)&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Can we get them out of Prelude? Please? :)&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;By the way, the GHC wiki seems to claim that &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists#Length-indexedobservedVectors&quot;&gt;using &lt;em&gt;OverloadedLists&lt;/em&gt; this way is impossible&lt;/a&gt;. Anyone know what’s going on here? Did we move fast and break everything?&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;Interestingly enough, I think this is something where you could have the best of both situations with the Template Haskell method. But I’d hope for something that works on the beautiful TypeLits :’(&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Tutorials</category><category>Reference</category><guid isPermaLink="true">https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html</guid><pubDate>Tue,  5 May 2015 18:16:07 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Tutorials, Reference</dc:subject><dc:date>2015-05-05</dc:date></item><item><title>mtl is Not a Monad Transformer Library</title><link>https://blog.jle.im/entry/mtl-is-not-a-monad-transformer-library.html</link><description>&lt;p&gt;&lt;em&gt;mtl&lt;/em&gt; is not a monad transformer library — contrary to popular conception. I believe that this commonly spread myth is due in part to some rather peculiar branding choices (the name of the library) and in part to some historical accidents (&lt;em&gt;mtl&lt;/em&gt; was, in the distant and pre-historic past, indeed a monad transformer library).&lt;/p&gt;
&lt;p&gt;What is &lt;em&gt;mtl&lt;/em&gt;? It is a library of &lt;em&gt;interfaces&lt;/em&gt; you can provide to your own types, in the form of typeclasses. It abstracts over &lt;em&gt;different design patterns&lt;/em&gt; for different types, in the form of typeclasses. Just like Functor abstracts over “things that can be fmapped”. &lt;em&gt;mtl&lt;/em&gt; provides typeclasses abstracting over many useful patterns that many types satisfy — patterns involving different sorts of “effects”.&lt;/p&gt;
&lt;h2 id=&quot;the-patterns&quot;&gt;The Patterns&lt;/h2&gt;
&lt;h3 id=&quot;monaderror&quot;&gt;MonadError&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MonadError&lt;/code&gt; is a generic interface over things where you can throw “errors” of a specific type &lt;code&gt;e&lt;/code&gt;, and “catch” them. It offers two methods: &lt;code&gt;throwError :: e -&amp;gt; m a&lt;/code&gt;, and &lt;code&gt;catchError :: m a -&amp;gt; (e -&amp;gt; m a) -&amp;gt; m a&lt;/code&gt;, which does what you’d expect from an error monad.&lt;/p&gt;
&lt;p&gt;Now, we have a generic interface to work on &lt;em&gt;all specfic type error-throwing Monads&lt;/em&gt;. The &lt;code&gt;Either&lt;/code&gt; type comes to mind as an obvious candidate:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadError&lt;/span&gt; e (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; e) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    throwError &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt;
    catchError s f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; s &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                       &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; s
                       &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; e  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f e&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But there are definitely other instances possible. How about for &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;IOException&lt;/code&gt;s, in specific?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadError&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    throwError  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ioError
    catchErrror &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; catch     &lt;span class=&quot;co&quot;&gt;-- will not catch non-IOExceptions&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is great, because we can now write code &lt;em&gt;generic&lt;/em&gt; over &lt;em&gt;all&lt;/em&gt; specific-type error things!&lt;/p&gt;
&lt;h4 id=&quot;error-behaviorfor-free&quot;&gt;Error behavior…for free!&lt;/h4&gt;
&lt;p&gt;If we’re clever enough, we can actually imbue any arbitrary Monad &lt;code&gt;m&lt;/code&gt; with rudimentary, basic, “dumb” error handling by using the &lt;code&gt;ExceptT&lt;/code&gt; type. An &lt;code&gt;ExceptT e m&lt;/code&gt; behaves &lt;em&gt;just&lt;/em&gt; like our original Monad &lt;code&gt;m&lt;/code&gt; in every way…except now, we have access to rudmentary implementations of side-channels of &lt;code&gt;throwError&lt;/code&gt; and &lt;code&gt;catchError&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is pretty useful…to be able to add short-circuiting error behavior to any Monad we wanted. But remember, &lt;code&gt;ExceptT&lt;/code&gt; is not the “point” of &lt;code&gt;MonadError&lt;/code&gt;. It’s just one way to generate instances for free given a Monad. The real power of &lt;code&gt;MonadError&lt;/code&gt; is in the ability to write generically over many Monads with some sort of “error” behavior, like &lt;code&gt;Either&lt;/code&gt; or &lt;code&gt;IO&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;monadstate&quot;&gt;MonadState&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;MonadState s m&lt;/code&gt; is a Monad &lt;code&gt;m&lt;/code&gt; where, during in the context of &lt;code&gt;m&lt;/code&gt;, you have access to a global state of type &lt;code&gt;s&lt;/code&gt; that you can modify.&lt;/p&gt;
&lt;p&gt;You can “get” it with &lt;code&gt;get :: m s&lt;/code&gt;. You can modify it with &lt;code&gt;modify :: (s -&amp;gt; s) -&amp;gt; m ()&lt;/code&gt;. You can replace it with &lt;code&gt;put :: s -&amp;gt; m ()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are a lot of types that can offer this type of interface. You might have, for example, a type where “getting” the state comes from reading an &lt;code&gt;IORef&lt;/code&gt;, and “putting” it comes from writing to the &lt;code&gt;IORef&lt;/code&gt;. Or maybe the state can come from a a query to a database…where &lt;code&gt;get&lt;/code&gt; queries a database in IO, and &lt;code&gt;put&lt;/code&gt; writes to the database.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MonadState&lt;/code&gt;, as a typeclass, gives you the ability to &lt;em&gt;write generically over all Monads with state&lt;/em&gt;. You can now write generically over those database state things…or those IORef state things…or those web query things…or anything that cares to implement the interface!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MonadState&lt;/code&gt; says, “the functions and actions I write can work for &lt;em&gt;all&lt;/em&gt; Monads offering state I can modify!” An action of type &lt;code&gt;MonadState String m =&amp;gt; m Double&lt;/code&gt; can create a &lt;code&gt;Double&lt;/code&gt; from &lt;em&gt;any&lt;/em&gt; monad offering some sort of &lt;code&gt;String&lt;/code&gt; state.&lt;/p&gt;
&lt;h4 id=&quot;statefor-free&quot;&gt;State…for free!&lt;/h4&gt;
&lt;p&gt;Again, we can actually imbue any Monad &lt;code&gt;m&lt;/code&gt; with some very rudimentary, “dumb” stateful interface, using a type called &lt;code&gt;StateT&lt;/code&gt;. A &lt;code&gt;StateT s m&lt;/code&gt; behaves just like our monad &lt;code&gt;m&lt;/code&gt; (be it &lt;code&gt;IO&lt;/code&gt;, &lt;code&gt;Reader&lt;/code&gt;, &lt;code&gt;ST&lt;/code&gt;, &lt;code&gt;STM&lt;/code&gt;…), except now we have access to a rudimentary state getting-and-putting mechanism on a state of type &lt;code&gt;s&lt;/code&gt;, using a form of function composition. The implementation of the &lt;code&gt;StateT&lt;/code&gt; handles it under the hood.&lt;/p&gt;
&lt;p&gt;Obviously, being able to add a rudimentary stateful interface on top of any Monad is pretty useful. Very useful, in fact!&lt;/p&gt;
&lt;p&gt;But remember, this isn’t the &lt;em&gt;point&lt;/em&gt; of &lt;code&gt;MonadState&lt;/code&gt;. &lt;code&gt;MonadState&lt;/code&gt; doesn’t exist for &lt;code&gt;StateT&lt;/code&gt;. &lt;code&gt;StateT&lt;/code&gt; is just a way to generate a free instance of &lt;code&gt;MonadState&lt;/code&gt; if you just want to add rudimentary statefulness to an existing Monad. But there are many instances of &lt;code&gt;MonadState&lt;/code&gt;…really, &lt;code&gt;MonadState&lt;/code&gt; has nothing to do with &lt;code&gt;StateT&lt;/code&gt; fundamentally, any more than &lt;code&gt;Monad&lt;/code&gt; has to do with &lt;code&gt;Maybe&lt;/code&gt; fundamentally. And &lt;code&gt;MonadState&lt;/code&gt; and &lt;code&gt;StateT&lt;/code&gt; don’t even come from the same library!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;mtl&lt;/em&gt; offers a generic interface for working with all monads offering a statey API.&lt;/p&gt;
&lt;h3 id=&quot;monadreader&quot;&gt;MonadReader&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MonadReader&lt;/code&gt; is more or less the same thing…it offers a generic interface to work on monads that have access to some sort of global, unchanging “environment”. An example might be a Monad where you could work with command line arguments, or environment variables, assuming they are read once and fixed when things start up. You could access the command line arguments with &lt;code&gt;ask&lt;/code&gt;, and use them in your program.&lt;/p&gt;
&lt;h3 id=&quot;monadio&quot;&gt;MonadIO&lt;/h3&gt;
&lt;p&gt;This one is actaully from &lt;em&gt;transformers&lt;/em&gt;, but it gives a nice picture. Any &lt;code&gt;MonadIO m&lt;/code&gt; is a &lt;code&gt;Monad&lt;/code&gt; that allows you to embed and sequence in any arbitrary IO action. This is pretty useful! In the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/persistent&quot;&gt;persistent&lt;/a&gt;&lt;/em&gt; database library, for example — the main “database access type monad” can sequence actions that access databases &lt;em&gt;and&lt;/em&gt; arbitrary IO actions, as well. A lot of resource managers and DSL’s offer the ability to sequence IO in the middle of all the other actions.&lt;/p&gt;
&lt;p&gt;That’s what &lt;code&gt;MonadIO&lt;/code&gt; is for — it allows you to write functions and say, “hey, my function is generic over &lt;em&gt;all&lt;/em&gt; things that can embed IO…anything that can embed IO can sequence my function/type”. The generic “embedding” action is &lt;code&gt;liftIO :: MonadIO m =&amp;gt; IO a -&amp;gt; m a&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You know…ideally, all of these typeclasses would have laws, so we could make conclusions and apply equational reasoning to generically written functions.&lt;/p&gt;
&lt;p&gt;Some of the laws are simple…&lt;code&gt;liftIO&lt;/code&gt; from &lt;code&gt;MonadIO&lt;/code&gt; should be a &lt;a href=&quot;http://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html&quot;&gt;monad morphism&lt;/a&gt;. But the rest of them don’t really have any well-established laws. This is a bit of a shame, because we’d really like to be able to apply reasoning to generic functions.&lt;/p&gt;
&lt;p&gt;People have suggested &lt;code&gt;MonadState&lt;/code&gt; have laws similar to how view/set/over interact in the &lt;em&gt;lens&lt;/em&gt; laws. But as of now, most of we have in terms of our capability of analyzing generic programs is rough heuristins/feelings about what “should” be right.&lt;/p&gt;
&lt;p&gt;A bit un-ideal, but…in practice, this ends up working not-so-badly :)&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;not-a-monad-transformer-library&quot;&gt;Not a Monad Transformer Library&lt;/h2&gt;
&lt;p&gt;So, let’s work together to dispel the myth that &lt;em&gt;mtl&lt;/em&gt; is a monad transformer library. It really has nothing to do with monad transformers at all…any more than &lt;code&gt;Control.Monad&lt;/code&gt; is an “IO module”, or &lt;code&gt;Control.Monoid&lt;/code&gt; is a “list module”. Transformers don’t even come from the &lt;em&gt;mtl&lt;/em&gt; library!&lt;/p&gt;
&lt;p&gt;Together, we can overcome this myth. We can show people that we can live in a world where we can combine effects, work generically in Monads with &lt;em&gt;multiple types of effects&lt;/em&gt; by writing functions generic over many different &lt;em&gt;mtl&lt;/em&gt; typeclasses at once! (&lt;code&gt;MonadState&lt;/code&gt; + &lt;code&gt;MonadIO&lt;/code&gt;, maybe?)&lt;/p&gt;
&lt;p&gt;We don’t &lt;em&gt;have to&lt;/em&gt; reach for Monad transformers to work with combined effects. We can write our own combined effects monads and just write the instances…or we can write generically and not even care about what Monad we actually use in the end. We don’t have to teach people to be afraid of monad transformers as if they were the only way to get things done, and &lt;em&gt;mtl&lt;/em&gt; is tied to them like a ball and chain.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;mtl&lt;/em&gt; is not a Monad transformer library. How liberating!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">https://blog.jle.im/entry/mtl-is-not-a-monad-transformer-library.html</guid><pubDate>Mon, 18 May 2015 17:07:36 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings</dc:subject><dc:date>2015-05-18</dc:date></item><item><title>Auto: A Todo GUI application with Auto (on GHCJS, etc.)</title><link>https://blog.jle.im/entry/auto-a-todo-gui-application-with-auto-on.html</link><description>&lt;p&gt;Continuing along with &lt;a href=&quot;http://blog.jle.im/entries/series/+all-about-auto&quot;&gt;All About Auto&lt;/a&gt;, let’s look at another exciting and useful application of the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/auto&quot;&gt;auto&lt;/a&gt;&lt;/em&gt; library: GUI’s. We’re going to look at the canonical “hello world” of GUI apps these days — the todo app. We’re going to be using the specs of &lt;a href=&quot;http://todomvc.com/&quot;&gt;todoMVC&lt;/a&gt; to build a todoMVC “candidate” that follows the specs…and along the way see what &lt;em&gt;auto&lt;/em&gt; offers in its tools of managing isolated state components and modeling GUI logic. We’re really going to be focusing on application logic — “control” and “model” — and not looking too close on “views”, which &lt;em&gt;auto&lt;/em&gt; doesn’t quite try to offer and where you can really pick your own view rendering system, making this adaptable to really any platform — javascript/web, desktop, command line, etc.&lt;/p&gt;
&lt;p&gt;A live version of our end-product &lt;a href=&quot;https://mstksg.github.com/auto-examples/todo&quot;&gt;is hosted and online&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This post does assume &lt;em&gt;some&lt;/em&gt; concepts from the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;tutorial&lt;/a&gt;…if not all, then at least those in the &lt;a href=&quot;http://blog.jle.im/entry/introducing-the-auto-library&quot;&gt;introductory post&lt;/a&gt; or the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/README.md&quot;&gt;README&lt;/a&gt;. If you ever find yourself thinking that these concepts are completely new and crazy, you might want to try looking through the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;tutorial&lt;/a&gt; or &lt;a href=&quot;http://hackage.haskell.org/package/auto&quot;&gt;docs&lt;/a&gt; to refresh your mind. As always, comments are welcome, and I’m also usually on &lt;em&gt;#haskell-auto&lt;/em&gt; as &lt;em&gt;jle`&lt;/em&gt;, and also on &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;twitter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(Fair warning…this is not quite a “ghcjs tutorial”, if that’s what you’re looking for; it’s an auto tutorial that uses some rudimentary ghcjs. Hopefully you can learn from that too!)&lt;/p&gt;
&lt;h2 id=&quot;overall-layout&quot;&gt;Overall Layout&lt;/h2&gt;
&lt;p&gt;At the highest level, &lt;em&gt;auto&lt;/em&gt; is a library that provides us tools to build and work with stream transformers on streams of values. Transform a stream of input values to a stream of output values. So, let’s try to phrase our Todo app problem in that perspective. What are our inputs, and what are our outputs?&lt;/p&gt;
&lt;p&gt;For a Todo app, the outputs are probably going to be a &lt;em&gt;todo list&lt;/em&gt; itself. If we’re building a GUI, then having the todo list itself is going to be enough to build our front-end display. The stream of &lt;em&gt;inputs&lt;/em&gt; is a little less obvious, but, well, what does an app really take as inputs? Commands! Our stream of inputs will be commands sent by a GUI or by whatever front-end we choose. Our todo app then is a transformer of a stream of commands to a stream of todo lists…where the todo list we get changes as we process more commands.&lt;/p&gt;
&lt;p&gt;So the “overall loop” will be:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;A front-end rendered by &lt;em&gt;ghcjs-dom&lt;/em&gt; (or whatever) with event handlers that drop commands into a concurrent &lt;code&gt;Chan&lt;/code&gt; queue. This just handles rendering.&lt;/li&gt;
&lt;li&gt;Our &lt;code&gt;Auto&lt;/code&gt; launched with &lt;code&gt;runOnChan&lt;/code&gt;, which waits on the &lt;code&gt;Chan&lt;/code&gt; queue, runs the inputs through the &lt;code&gt;Auto&lt;/code&gt;, and renders the result. This handles all of the logic.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We like types in Haskell, so let’s begin by laying out our types!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs#L19-46&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto.Collection&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad.Fix&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.IntMap&lt;/span&gt;             (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Serialize&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;GHC.Generics&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Prelude&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;hiding&lt;/span&gt;          ((.), id)
&lt;span class=&quot;kw&quot;&gt;import qualified&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Data.IntMap&lt;/span&gt;   &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IM&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IAdd&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- new task with description&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ITask&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskID&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- send command to task by ID&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IAll&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- send command to all tasks&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CDelete&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;-- delete&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CPrune&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- delete if completed&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CComplete&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- set completed status&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CModify&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- modify description&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CNop&lt;/span&gt;             &lt;span class=&quot;co&quot;&gt;-- do nothing&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; taskDescr     ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
                 ,&lt;span class=&quot;ot&quot;&gt; taskCompleted ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
                 } &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Generic&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Serialize&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- from Data.Serialize, from the cereal library&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We have a type to represent our inputs, &lt;code&gt;TodoInp&lt;/code&gt;, which can be an “add” command with a &lt;code&gt;String&lt;/code&gt;, a “task” command with a &lt;code&gt;TaskId&lt;/code&gt; (&lt;code&gt;Int&lt;/code&gt;) and a &lt;code&gt;TaskCmd&lt;/code&gt;, and an “all” command with a &lt;code&gt;TaskCmd&lt;/code&gt; that is supposed to represent sending that command to all tasks.&lt;/p&gt;
&lt;p&gt;Our &lt;code&gt;TaskCmd&lt;/code&gt; represents commands we can send to individual tasks – we can delete, prune (delete if completed), set the “completed” flag, or modify the description.&lt;/p&gt;
&lt;p&gt;We’re going to represent our task list, &lt;code&gt;TaskMap&lt;/code&gt;, as not a &lt;code&gt;[]&lt;/code&gt; list, but as an &lt;code&gt;IntMap&lt;/code&gt; from &lt;em&gt;containers&lt;/em&gt;, which associates an &lt;code&gt;Int&lt;/code&gt; to a &lt;code&gt;Task&lt;/code&gt; that we can look up with the &lt;code&gt;IntMap&lt;/code&gt; API. What would a &lt;code&gt;TaskMap&lt;/code&gt; store other than a bunch of &lt;code&gt;Task&lt;/code&gt;s, which we are defining as jus a tupling of a &lt;code&gt;String&lt;/code&gt; description and a &lt;code&gt;Bool&lt;/code&gt; completed/uncompleted status.&lt;/p&gt;
&lt;h2 id=&quot;the-todo-auto&quot;&gt;The Todo Auto&lt;/h2&gt;
&lt;p&gt;Time to go over the logic portion! The part that &lt;em&gt;auto&lt;/em&gt; is meant for! We’re going to structure the logic of our app (also known as the “model”) by using principles of local statefulness to avoid ever working with a “global state”, and working in a declarative, high-level manner.&lt;/p&gt;
&lt;h3 id=&quot;tasks&quot;&gt;Tasks&lt;/h3&gt;
&lt;p&gt;It’s clear that the core of our entire thing is going to be the “task list” construct itself…something that can dynamically add or remove tasks.&lt;/p&gt;
&lt;p&gt;In &lt;em&gt;auto&lt;/em&gt;, there is a construct created just for this kind of situation: dynamic collections indexed by a key (a “task id”), where you can add or subtract &lt;code&gt;Auto&lt;/code&gt;s from dynamically — they are &lt;code&gt;dynMap&lt;/code&gt; and &lt;code&gt;dynMapF&lt;/code&gt; from &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/auto/docs/Control-Auto-Collection.html&quot;&gt;Control.Auto.Collection&lt;/a&gt;&lt;/em&gt;. We’ll be using &lt;code&gt;dynMapF&lt;/code&gt; because it’s serializable, and we don’t need the extra power that &lt;code&gt;dynMap&lt;/code&gt; offers.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;dynMapF ::&lt;/span&gt; (k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Interval&lt;/span&gt; m a b)    &lt;span class=&quot;co&quot;&gt;-- ^ function to initialize new `Auto`s&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a                        &lt;span class=&quot;co&quot;&gt;-- ^ default inputs&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m ( &lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; a        &lt;span class=&quot;co&quot;&gt;-- ^ input for each internal `Auto`, indexed by key&lt;/span&gt;
                  , &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [k]        &lt;span class=&quot;co&quot;&gt;-- ^ blip stream to initialize new `Auto`s&lt;/span&gt;
                  )
                  (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; b)        &lt;span class=&quot;co&quot;&gt;-- ^ `Auto` outputs, by key&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;dynMapF&lt;/code&gt; keeps a “dynamic collection” of &lt;code&gt;Interval m a b&lt;/code&gt;s, indexed by an &lt;code&gt;Int&lt;/code&gt; key, or an “ID”. It takes as input a stream of &lt;code&gt;IntMap a&lt;/code&gt;…basically a bunch of &lt;code&gt;(Int, a)&lt;/code&gt; pairs. &lt;code&gt;dynMapF&lt;/code&gt; routes each input to the &lt;code&gt;Interval&lt;/code&gt; at that ID/address (with a suitable “default” &lt;code&gt;a&lt;/code&gt; if none was sent in), and then outputs all of the results as an &lt;code&gt;IntMap b&lt;/code&gt; — a bunch of &lt;code&gt;(Int, b)&lt;/code&gt; pairs, each output with the address of the &lt;code&gt;Auto&lt;/code&gt; that made it.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;IM.singleton 5 True&lt;/code&gt; would send &lt;code&gt;True&lt;/code&gt; to the &lt;code&gt;Auto&lt;/code&gt; stored at &lt;code&gt;5&lt;/code&gt;. It’ll then output something that includes &lt;code&gt;(5, &amp;quot;received True!&amp;quot;)&lt;/code&gt; — the output of the &lt;code&gt;Auto&lt;/code&gt; at slot 5.&lt;/p&gt;
&lt;p&gt;Whenever an &lt;code&gt;Interval&lt;/code&gt; turns “off” (is &lt;code&gt;Nothing&lt;/code&gt;), it is removed from the collection. In this way we can have &lt;code&gt;Auto&lt;/code&gt;s “remove themselves”.&lt;/p&gt;
&lt;p&gt;It also takes as input a blip stream of &lt;code&gt;[k]&lt;/code&gt;s. We use each emitted &lt;code&gt;k&lt;/code&gt; to “initialize a new &lt;code&gt;Interval&lt;/code&gt;” and throw it into the collection, creating a new unique key for it. Every time a new &lt;code&gt;Auto&lt;/code&gt; is initialized, &lt;code&gt;dynMapF&lt;/code&gt; creates a new key for it.&lt;/p&gt;
&lt;p&gt;Read over the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md#semantic-tools&quot;&gt;tutorial section on blip streams and &lt;code&gt;Interval&lt;/code&gt;s&lt;/a&gt; if you are still unfamiliar with them.&lt;/p&gt;
&lt;p&gt;This pretty much fits exactly what we want for our task collection. If we imagined that we had our &lt;code&gt;Task&lt;/code&gt; as an &lt;code&gt;Auto&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;initTask ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Interval&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;initTask&lt;/code&gt; takes a string (a starting description) and initializes an &lt;code&gt;Interval&lt;/code&gt; that takes in a stream of task commands, and has a stream of new, updated &lt;code&gt;Task&lt;/code&gt;s as its output stream. At every step, it processes the command and outputs the new appropriate &lt;code&gt;Task&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can then use this as our “initializer” for &lt;code&gt;dynMapF&lt;/code&gt;…and now we have a dynamic collection of tasks!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs#L48-50&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;taskCollection ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m
               &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;]) (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;)
taskCollection &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dynMapF initTask &lt;span class=&quot;dt&quot;&gt;CNop&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we wanted to send in the command &lt;code&gt;CModify &amp;quot;hey!&amp;quot;&lt;/code&gt; to the task whose id/key/address is &lt;code&gt;12&lt;/code&gt;, I’d feed in &lt;code&gt;IM.singleton 12 (CModify &amp;quot;hey!&amp;quot;)&lt;/code&gt;. The output would then contain the output of feeding that &lt;code&gt;CModify&lt;/code&gt; to the &lt;code&gt;Auto&lt;/code&gt; at that slot 12, associated with slot 12 on the output &lt;code&gt;IntMap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Writing &lt;code&gt;initTask&lt;/code&gt; and the task &lt;code&gt;Auto&lt;/code&gt; is straightforward with &lt;code&gt;accum&lt;/code&gt;, which is basically like &lt;code&gt;foldl&lt;/code&gt; on the inputs and a “current state”. (The current state is of course the &lt;code&gt;Task&lt;/code&gt;).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs#L52-62&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;initTask ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Interval&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;
initTask descr &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; accum f (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; descr &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;))
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    f (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t) tc &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; tc &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                      &lt;span class=&quot;dt&quot;&gt;CDelete&lt;/span&gt;                  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
                      &lt;span class=&quot;dt&quot;&gt;CPrune&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; taskCompleted t &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
                             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t
                      &lt;span class=&quot;dt&quot;&gt;CComplete&lt;/span&gt; s              &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t { taskCompleted &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; s }
                      &lt;span class=&quot;dt&quot;&gt;CModify&lt;/span&gt; descr            &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t { taskDescr &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; descr }
                      &lt;span class=&quot;dt&quot;&gt;CNop&lt;/span&gt;                     &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t
    f &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; _   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;See that our &lt;code&gt;Auto&lt;/code&gt; “turns off” by outputting &lt;code&gt;Nothing&lt;/code&gt;. That’s interval semantics, and it’s what &lt;code&gt;dynMapF&lt;/code&gt; relies on for its internal &lt;code&gt;Auto&lt;/code&gt;s!&lt;/p&gt;
&lt;h3 id=&quot;routing-the-inputs&quot;&gt;Routing the inputs&lt;/h3&gt;
&lt;p&gt;The only thing left, then, is just to route our input stream to send everything to the correct &lt;code&gt;Auto&lt;/code&gt; in &lt;code&gt;taskCollection&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Our input stream is going to be a stream of &lt;code&gt;TodoInp&lt;/code&gt;, which can be “add”, “send command to a single task”, or “send command to all tasks”. Really, though, you can think of it three separate streams all “jammed” into one stream.&lt;/p&gt;
&lt;p&gt;This is a common pattern that we can use &lt;em&gt;blip streams&lt;/em&gt; for. Instead of working with one big fatty stream, we can work with several blip streams that only emit when the input that we care about comes in.&lt;/p&gt;
&lt;p&gt;Typically, we’d do this with &lt;code&gt;emitJusts&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;emitJusts ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can imagine &lt;code&gt;emitJusts&lt;/code&gt; is a “siphon” off of the input stream of &lt;code&gt;a&lt;/code&gt;s…and pulling out only the values that we care about, as a blip stream of &lt;code&gt;b&lt;/code&gt;’s.&lt;/p&gt;
&lt;p&gt;We can build our “siphoners”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs#L95-105&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;getAddEvts ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;]
getAddEvts (&lt;span class=&quot;dt&quot;&gt;IAdd&lt;/span&gt; descr) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; [descr]
getAddEvts _            &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;getModEvts ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;)
getModEvts (&lt;span class=&quot;dt&quot;&gt;ITask&lt;/span&gt; n te) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; IM.singleton n te
getModEvts _            &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;getMassEvts ::&lt;/span&gt; ([&lt;span class=&quot;dt&quot;&gt;TaskID&lt;/span&gt;], &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;)
getMassEvts (allIds, &lt;span class=&quot;dt&quot;&gt;IAll&lt;/span&gt; te) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; IM.fromList (map (,te) allIds)
getMassEvts _                 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;getAddEvts&lt;/code&gt;, when used with &lt;code&gt;emitJusts&lt;/code&gt;, will siphon off all &lt;code&gt;IAdd&lt;/code&gt; commands as a blip stream of &lt;code&gt;[String]&lt;/code&gt;s, emitting descriptions of new tasks to add.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getModEvts&lt;/code&gt;, when used with &lt;code&gt;emitJusts&lt;/code&gt;, will siphon off all &lt;code&gt;ITask&lt;/code&gt; commands as a blip stream of &lt;code&gt;IntMap TaskCmd&lt;/code&gt;, which will be fed into &lt;code&gt;taskCollection&lt;/code&gt; and &lt;code&gt;dynMapF&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getMassEvts&lt;/code&gt; is pretty much the same thing…siphoning off all &lt;code&gt;IAll&lt;/code&gt; commands as a blip stream of &lt;code&gt;IntMap TaskCmd&lt;/code&gt;. It needs a list of all &lt;code&gt;TaskID&lt;/code&gt;s though, to do its job…because it needs to make an &lt;code&gt;IntMap&lt;/code&gt; targeting all of the current tasks.&lt;/p&gt;
&lt;p&gt;Remember, we interace with tasks through an &lt;code&gt;IntMap TaskCmd&lt;/code&gt;…which is a map of task id-task command pairs. The &lt;code&gt;TaskCmd&lt;/code&gt; stored at key &lt;code&gt;1&lt;/code&gt; will be the command we want to send to task id 1.&lt;/p&gt;
&lt;p&gt;Let’s see it all work together!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs#L64-93&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;todoApp ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadFix&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;)
todoApp &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc inpEvt &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;

    rec &lt;span class=&quot;co&quot;&gt;-- all id&amp;#39;s currently alive&lt;/span&gt;
        allIds &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; arrD IM.keys [] &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; taskMap

        &lt;span class=&quot;co&quot;&gt;-- &amp;quot;forking&amp;quot; `inpEvt` into three blip streams:&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- newTaskB :: Blip [String]&lt;/span&gt;
        newTaskB  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; emitJusts getAddEvts  &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inpEvt
        &lt;span class=&quot;co&quot;&gt;-- modTaskB :: Blip (IntMap TaskCmd)&lt;/span&gt;
        modTaskB  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; emitJusts getModEvts  &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inpEvt
        &lt;span class=&quot;co&quot;&gt;-- massTaskB :: Blip (IntMap TaskCmd)&lt;/span&gt;
        massTaskB &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; emitJusts getMassEvts &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (allIds, inpEvt)

        &lt;span class=&quot;co&quot;&gt;-- merge the two streams together to get &amp;quot;all&amp;quot; inputs, single and&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- mass.&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; allInpB ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt;)
            allInpB &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; modTaskB &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; massTaskB

        &lt;span class=&quot;co&quot;&gt;-- from a blip stream to an `IntMap` stream that is empty when the&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- stream doesn&amp;#39;t emit&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- taskCommands :: IntMap TaskCmd&lt;/span&gt;
        taskCommands &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; fromBlips IM.empty &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; allInpB

        &lt;span class=&quot;co&quot;&gt;-- feed the commands and the new tasks to `taskMap`...the result is&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- the `IntMap` of tasks.&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- taskMap :: IntMap Task&lt;/span&gt;
        taskMap &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; taskCollection &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (taskCommands, newTaskB)

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; taskMap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To read the proc block, it does help to sort of see all of the lines as english statements of what things “are”.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;allIds&lt;/code&gt; is a list of keys (id’s) currently in the task map &lt;code&gt;taskMap&lt;/code&gt;. All of the id’s of the tasks currently alive.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now, we fork into blip streams:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;newTaskB&lt;/code&gt; is a blip stream that emits with task descriptions whenever &lt;code&gt;inpEvt&lt;/code&gt; calls for one.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modTaskB&lt;/code&gt; is a blip stream that emits with a command to a specific task whenever &lt;code&gt;inpEvt&lt;/code&gt; calls for one.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;massTaskB&lt;/code&gt; is a blip stream that emits commands to every single task in &lt;code&gt;allIds&lt;/code&gt; whenever &lt;code&gt;inpEvt&lt;/code&gt; calls for it.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;allInpB&lt;/code&gt; is a blip stream with addressed commands whenever either &lt;code&gt;modTaskB&lt;/code&gt; or &lt;code&gt;massTaskB&lt;/code&gt; emits.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;taskCommands&lt;/code&gt; is a map of addressed commands for each task. It’s whatever &lt;code&gt;allInpB&lt;/code&gt; emits, when it does emit…or just &lt;code&gt;IM.empty&lt;/code&gt; (an empty map) when it doesn’t.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;taskMap&lt;/code&gt; is the map of tasks that we get from our &lt;code&gt;taskCollection&lt;/code&gt; updater, which manages a collection of tasks. &lt;code&gt;taskCollection&lt;/code&gt; needs the commands for each task and the new tasks we want to do its job.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We state things as an interplay of streams. And in the end, the result is what we want — an indexed list of tasks.&lt;/p&gt;
&lt;p&gt;Note that we needed the &lt;code&gt;rec&lt;/code&gt; block because we referred to &lt;code&gt;taskMap&lt;/code&gt; at the beginning (to get &lt;code&gt;allIds&lt;/code&gt;), but we don’t define &lt;code&gt;taskMap&lt;/code&gt; until the end.&lt;/p&gt;
&lt;p&gt;Note that we use &lt;code&gt;arrD&lt;/code&gt; for &lt;code&gt;allIds&lt;/code&gt;. What we really “meant” was something like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;allIds &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; arr IM.keys &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; taskMap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But…this doesn’t really work out, because when the whole thing “starts”, we don’t know what &lt;code&gt;taskMap&lt;/code&gt; is. We need to know &lt;code&gt;massTaskB&lt;/code&gt; to know &lt;code&gt;taskMap&lt;/code&gt;, and we need to know &lt;code&gt;allIds&lt;/code&gt; to know &lt;code&gt;massTaskB&lt;/code&gt;, and…recursive dependency!&lt;/p&gt;
&lt;p&gt;We can use &lt;code&gt;arrD&lt;/code&gt; to specify an “initial output” to “close the loop” (in technical terms). We want &lt;code&gt;allIds&lt;/code&gt; to initially be &lt;code&gt;[]&lt;/code&gt; (we can assume we start with no task id’s), so instead of&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;allIds &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; arr IM.keys &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; taskMap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we have&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;allIds &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; arrD IM.keys [] &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; taskMap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where &lt;code&gt;[]&lt;/code&gt; is the “initial output”, so when we first try to do anything, we don’t need &lt;code&gt;taskMap&lt;/code&gt; — we just pop out &lt;code&gt;[]&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;This is just a small thing to worry about whenever you have recursive bindings. There is a small cognitive price to pay, but in return, you have something that really just looks like laying out relationships between different quantities :)&lt;/p&gt;
&lt;h2 id=&quot;interfacing-with-the-world&quot;&gt;Interfacing with the world&lt;/h2&gt;
&lt;p&gt;Our application logic is done; let’s explore ways to interface with it!&lt;/p&gt;
&lt;h3 id=&quot;testingcommand-line&quot;&gt;Testing/command line&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/todo-cmd.hs#L25-62&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;parseInp ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt;
parseInp &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; p &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs)   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IAdd&lt;/span&gt; (unwords xs))
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;D&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onId n &lt;span class=&quot;dt&quot;&gt;CDelete&lt;/span&gt;
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onId n (&lt;span class=&quot;dt&quot;&gt;CComplete&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;)
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;U&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onId n (&lt;span class=&quot;dt&quot;&gt;CComplete&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;)
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;P&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onId n &lt;span class=&quot;dt&quot;&gt;CPrune&lt;/span&gt;
    p (&lt;span class=&quot;st&quot;&gt;&amp;quot;M&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onId n (&lt;span class=&quot;dt&quot;&gt;CModify&lt;/span&gt; (unwords xs))
    p _          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;    onId ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskCmd&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt;
    onId &lt;span class=&quot;st&quot;&gt;&amp;quot;*&amp;quot;&lt;/span&gt; te &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IAll&lt;/span&gt; te)
    onId n   te &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;`ITask`&lt;/span&gt; te) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; readMaybe n

&lt;span class=&quot;ot&quot;&gt;formatTodo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
formatTodo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; unlines &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; map format &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; IM.toList
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    format (n, &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt; desc compl) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; concat [ show n
                                         , &lt;span class=&quot;st&quot;&gt;&amp;quot;. [&amp;quot;&lt;/span&gt;
                                         , &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; compl &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;X&amp;quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt;
                                         , &lt;span class=&quot;st&quot;&gt;&amp;quot;] &amp;quot;&lt;/span&gt;
                                         , desc
                                         ]

&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;Enter command! &amp;#39;A descr&amp;#39; or &amp;#39;[D/C/U/P/M] [id/*]&amp;#39;&amp;quot;&lt;/span&gt;
    void &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; interactAuto &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- interactAuto takes an Interval; `toOn` gives&lt;/span&gt;
                          &lt;span class=&quot;co&quot;&gt;--   one that runs forever&lt;/span&gt;
                          toOn
                          &lt;span class=&quot;co&quot;&gt;-- default output value on bad command&lt;/span&gt;
                        &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromBlips &lt;span class=&quot;st&quot;&gt;&amp;quot;Bad command!&amp;quot;&lt;/span&gt;
                          &lt;span class=&quot;co&quot;&gt;-- run `formatTodo &amp;lt;$&amp;gt; todoApp` on emitted commands&lt;/span&gt;
                        &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; perBlip (formatTodo &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; todoApp)
                          &lt;span class=&quot;co&quot;&gt;-- emit when input is parseable&lt;/span&gt;
                        &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts parseInp&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;interactAuto&lt;/code&gt; runs an &lt;code&gt;Interval&lt;/code&gt; by feeding it in strings from stdin printing the output to stdout, until the output is “off”/&lt;code&gt;Nothing&lt;/code&gt; — then stops. Here we use &lt;code&gt;parseInp&lt;/code&gt; to emit input events whenever there is a parse, run &lt;code&gt;todoApp&lt;/code&gt; (formatted) on the emitted events, and then condense it all with &lt;code&gt;fromBlips&lt;/code&gt; and wrap it in an “always on” &lt;code&gt;toOn&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cabal sandbox init
$ cabal install auto
$ cabal exec runghc todo-cmd.hs
Enter command! &amp;#39;A descr&amp;#39; or &amp;#39;[D/C/U/P/M] [id/*]&amp;#39;
&amp;gt; A take out the trash
0. [ ] take out the trash

&amp;gt; A do the dishes
0. [ ] take out the trash
1. [ ] do the dishes

&amp;gt; C 1
0. [ ] take out the trash
1. [X] do the dishes

&amp;gt; U 1
0. [ ] take out the trash
1. [ ] do the dishes

&amp;gt; C 0
0. [X] take out the trash
1. [ ] do the dishes

&amp;gt; P *
1. [ ] do the dishes&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/auto/todo-cmd.hs&quot;&gt;download and run this yourself&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;Looks like the logic works! Time to take it to GUI!&lt;/p&gt;
&lt;h3 id=&quot;as-a-gui&quot;&gt;As a GUI&lt;/h3&gt;
&lt;p&gt;To build a GUI, we must build an &lt;code&gt;Auto&lt;/code&gt; that takes in inputs from events and output everything the front-end renderer needs to render the interface.&lt;/p&gt;
&lt;p&gt;For a typical todomvc gui, we need to be able to filter and select things. So that means we need to be extend our input type with filtering and selecting events. And our output has to also indicate the current filter selected, and the current task selected, as well.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIOpts&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUI&lt;/span&gt; { _&lt;span class=&quot;ot&quot;&gt;currFilter   ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Filter&lt;/span&gt;        &lt;span class=&quot;co&quot;&gt;-- currently applied filter&lt;/span&gt;
                   , _&lt;span class=&quot;ot&quot;&gt;currSelected ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskID&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;-- currently selected task&lt;/span&gt;
                   }

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GIFilter&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Filter&lt;/span&gt;
            &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GISelect&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskID&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Filter&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;All&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Active&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Completed&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Generic&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Enum&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Serialize&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Filter&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Instead of defining a new input mega-type with all input events and the todo map with the options, we can use good ol’ fashioned &lt;code&gt;Either&lt;/code&gt; and &lt;code&gt;(,)&lt;/code&gt;. So now, instead of:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;todoApp ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We have:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;todoAppGUI ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;GUIOpts&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we take &lt;em&gt;either&lt;/em&gt; &lt;code&gt;TodoInp&lt;/code&gt; or &lt;code&gt;GUIInp&lt;/code&gt; and then return &lt;em&gt;both&lt;/em&gt; &lt;code&gt;IntMap Task&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;GUIOpts&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;todoAppGUI ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&amp;#39;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;GUIOpts&lt;/span&gt;)
todoAppGUI &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc inp &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    filt  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith &lt;span class=&quot;dt&quot;&gt;All&lt;/span&gt;                      &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts filtInps &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp
    selc  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;                  &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts selcInps &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp
    tasks &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith mempty &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; perBlip todoApp &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts todoInps &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (tasks, &lt;span class=&quot;dt&quot;&gt;GUI&lt;/span&gt; filt selc)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    todoInps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt;
    todoInps (&lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; ti) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; ti
    todoInps _         &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    filtInps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Filter&lt;/span&gt;
    filtInps (&lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;GIFilter&lt;/span&gt; filt)) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; filt
    filtInps _                       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    selcInps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TaskID&lt;/span&gt;)
    selcInps (&lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;GISelect&lt;/span&gt; sec))  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; selc
    selcInps _                       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we have the same idea as before. One input stream of &lt;code&gt;Either TodoInp GUIInp&lt;/code&gt; comes through, and we fork it into three blip streams that each do what we want. &lt;code&gt;holdWith x :: Auto m (Blip b) b&lt;/code&gt; is always the value of the last emitted item…but starts off as &lt;code&gt;x&lt;/code&gt; first.&lt;/p&gt;
&lt;p&gt;By the way, the above code is much more succinct if you are willing to use &lt;em&gt;&lt;a href=&quot;http://lens.github.com&quot;&gt;lens&lt;/a&gt;&lt;/em&gt;…&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;todoAppGUI ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&amp;#39;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;GUIOpts&lt;/span&gt;)
todoAppGUI &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc inp &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    filt  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith &lt;span class=&quot;dt&quot;&gt;All&lt;/span&gt;
           &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts (preview (_&lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; _&lt;span class=&quot;dt&quot;&gt;GIFilter&lt;/span&gt;)) &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp
    selc  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
           &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts (preview (_&lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; _&lt;span class=&quot;dt&quot;&gt;GISelect&lt;/span&gt;)) &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp
    tasks &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; holdWith mempty &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; perBlip todoApp
           &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; emitJusts (preview _&lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt;)                &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (tasks, &lt;span class=&quot;dt&quot;&gt;GUI&lt;/span&gt; filt selc)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(assuming we defined the prisms for &lt;code&gt;GUIInp&lt;/code&gt; or used &lt;code&gt;&#39;&#39;mkPrisms&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;Neat, right? In a way, you can say that &lt;code&gt;emitJusts&lt;/code&gt; and &lt;code&gt;Prisms&lt;/code&gt;/lens was a match made in heaven :)&lt;/p&gt;
&lt;h3 id=&quot;giving-it-life&quot;&gt;Giving it life&lt;/h3&gt;
&lt;p&gt;The last step is to hook everything up together —&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Setting up events in our GUI to feed inputs to a queue&lt;/li&gt;
&lt;li&gt;Setting up the queue to wait on inputs, and output the task map/gui status on every one using &lt;code&gt;todoAppGUI&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Rendering the output into the GUI framework of your choice&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The second step in particular can be handled with good ol’ &lt;code&gt;[runOnChan][]&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;runOnChan ::&lt;/span&gt; (b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&amp;#39;&lt;/span&gt; a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Auto&amp;#39;&lt;/span&gt; a b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We know and love &lt;code&gt;runOnChan&lt;/code&gt; from when we used it to make our &lt;a href=&quot;http://blog.jle.im/entry/auto-building-a-declarative-chatbot-with-implicit-serialization#irc-backend-the-ugly-part&quot;&gt;chatbot&lt;/a&gt;. It runs an &lt;code&gt;Auto&#39; a b&lt;/code&gt; “on a &lt;code&gt;Chan&lt;/code&gt;” (concurrent queue). The first argument is an “output hander” — it handles the &lt;code&gt;b&lt;/code&gt;s that the &lt;code&gt;Auto&#39;&lt;/code&gt; pops out. It decides whether to stop the whole thing or keep on listening based on the &lt;code&gt;Bool&lt;/code&gt; result of the handler. The second argument is the &lt;code&gt;Chan a&lt;/code&gt; to listen for inputs on. Whenever something is dropped into that &lt;code&gt;Chan&lt;/code&gt;, it runs the &lt;code&gt;Auto&#39;&lt;/code&gt; with the &lt;code&gt;a&lt;/code&gt; and processes the output &lt;code&gt;b&lt;/code&gt; with the handler.&lt;/p&gt;
&lt;p&gt;Our final runner is then just:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;runOnChan renderGUI inputChan todoAppGUI&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;renderGUI ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;IntMap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Task&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;GUIOpts&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;inputChan ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;TodoInp&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;GUIInp&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The rendering is done with &lt;code&gt;renderGUI&lt;/code&gt;…and it really depends on your framework here. That’s #3 from the list above.&lt;/p&gt;
&lt;p&gt;All you need after that is just to have your GUI hook up event handlers to drop the appropriate &lt;code&gt;Either TodoInp GUIInp&lt;/code&gt; into &lt;code&gt;inputChan&lt;/code&gt;…and you’re golden!&lt;/p&gt;
&lt;h2 id=&quot;seeing-it-in-action&quot;&gt;Seeing it in action&lt;/h2&gt;
&lt;p&gt;We’ve reached the end of our tutorial — the parts about &lt;code&gt;auto&lt;/code&gt;. It is my hope that whatever GUI front-end you want to work with, it’ll be simple enough to “plug in” our &lt;code&gt;Auto&lt;/code&gt; logic.&lt;/p&gt;
&lt;p&gt;A &lt;a href=&quot;https://mstksg.github.com/auto-examples/todo&quot;&gt;live demo&lt;/a&gt; is online too; you can see &lt;a href=&quot;https://github.com/mstksg/auto-examples/blob/master/src/TodoJS.hs&quot;&gt;the source of the front-end bindings&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is a bare-bons &lt;em&gt;ghcjs&lt;/em&gt; implementation using &lt;em&gt;ghcjs-dom&lt;/em&gt;, which uses direct dom manipulation.&lt;/p&gt;
&lt;p&gt;User &lt;a href=&quot;https://github.com/eryx67&quot;&gt;eryx67&lt;/a&gt; has been kind enough to provide &lt;a href=&quot;https://github.com/eryx67/auto-examples/blob/master/src/TodoJS.hs&quot;&gt;an implementation in &lt;em&gt;ghcjs&lt;/em&gt;&lt;/a&gt; with the &lt;em&gt;&lt;a href=&quot;https://github.com/ocharles/virtual-dom&quot;&gt;virtual-dom&lt;/a&gt;&lt;/em&gt; library (&lt;a href=&quot;https://github.com/mstksg/auto-examples/commit/246133a89fbca6a2ec7ea276d8536701f6ab8d2c?diff=split&quot;&gt;side-by-side comparison&lt;/a&gt;), so there is a slightly less uglier implementation with abstraction :)&lt;/p&gt;
&lt;p&gt;As always, feel free to ask questions in the comments, hop over to &lt;em&gt;#haskell-game&lt;/em&gt; or &lt;em&gt;#haskell-auto&lt;/em&gt; on freenode, or send me a &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;tweet&lt;/a&gt;! And look forward to more tutorials as the &lt;a href=&quot;http://blog.jle.im/entries/series/+all-about-auto&quot;&gt;All About Auto&lt;/a&gt; series progresses!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Auto</category><category>Tutorials</category><guid isPermaLink="true">https://blog.jle.im/entry/auto-a-todo-gui-application-with-auto-on.html</guid><pubDate>Thu, 23 Apr 2015 17:04:10 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Auto, Tutorials</dc:subject><dc:date>2015-04-23</dc:date></item><item><title>Unique sample drawing &amp; searches with List and StateT — “Send more money”</title><link>https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.html</link><description>&lt;p&gt;Nothing too crazy today, just a cute (basic/intermediate) haskell trick as a response to Mark Dominus’s excellent &lt;a href=&quot;http://blog.plover.com&quot;&gt;Universe of Discourse&lt;/a&gt; post on &lt;a href=&quot;http://blog.plover.com/prog/haskell/monad-search.html&quot;&gt;Easy exhaustive search with the list monad&lt;/a&gt; intended for people new or unfamiliar with haskell demonstrating the common “list monad as a constraint solver” approach that is standard fare for learning Haskell. I myself have literally done &lt;a href=&quot;http://blog.jle.im/entries/series/+monadplus-success-failure-monads&quot;&gt;an entire series of blog posts&lt;/a&gt; on this usage.&lt;/p&gt;
&lt;p&gt;Mark’s use case however incorporates a bit of an extra pattern not typically discussed. The list monad is good for taking “independent samples” of things (looking at different samples from a list):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         z &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         return [x,y,z]
[&lt;span class=&quot;st&quot;&gt;&amp;quot;aaa&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;aab&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;aac&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;aba&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;abb&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt; ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, what if you wanted to instead “draw” from a pool, and represent different drawings? Traditionally, the answer was something like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; filter (&lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; x) &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         z &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; filter (&lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; y) &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; filter (&lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; x) &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
         return [x,y,z]
&lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;acb&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;bac&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;bca&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;cab&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;cba&amp;quot;&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a little bit awkward…and it definitely gets a lot worse (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?O%28n%5E2%29&quot; alt=&quot;O(n^2)&quot; title=&quot;O(n^2)&quot; /&gt;) when you have more items. Also, it relies on an &lt;code&gt;Eq&lt;/code&gt; constraint — what if our thing doesn’t have an &lt;code&gt;Eq&lt;/code&gt; instance? And this also falls apart when our list contains duplicate items. If we had used &lt;code&gt;&amp;quot;aabc&amp;quot;&lt;/code&gt; instead of &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;, the result would be the same — despite having more &lt;code&gt;&#39;a&#39;&lt;/code&gt;s to pick from!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important note:&lt;/strong&gt; After writing this article, I found out that Douglas Auclair in &lt;a href=&quot;https://wiki.haskell.org/wikiupload/6/6a/TMR-Issue11.pdf&quot;&gt;11th issue of the Monad Reader&lt;/a&gt; solved this exact same problem with pretty much the exact same approach. (Oops!) If you want to do further reading, check it out! :D&lt;/p&gt;
&lt;h2 id=&quot;statet&quot;&gt;StateT&lt;/h2&gt;
&lt;p&gt;There’s a type in the &lt;em&gt;transformers&lt;/em&gt; library that provides a very useful monad instance:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; s m a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; (s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (a, s))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;StateT s m a&lt;/code&gt; is a function that takes an initial state &lt;code&gt;s&lt;/code&gt; and returns a result &lt;code&gt;a&lt;/code&gt; with a modified state…in the context of &lt;code&gt;m&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Specialize for &lt;code&gt;m ~ []&lt;/code&gt; and we get&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; s [] a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; (s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [(a, s)])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is basically describing a function from a initial state to a list of &lt;em&gt;ways you can modify the state&lt;/em&gt;, and different results from each one. It returns a list of “all ways you can mutate this state”.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;foo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; [] &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
foo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [(even x, x&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), (odd x, x&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), (x &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, negate x)]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;foo&lt;/code&gt; takes a number, &lt;code&gt;x&lt;/code&gt;, and says, “here are three ways we might proceed from having this number. We can return whether or not it’s even, in which case the new state is &lt;code&gt;x+1&lt;/code&gt;…we can return whether or not it’s odd, in which case the new state is &lt;code&gt;x-1&lt;/code&gt;….or we can return whether or not it’s positive, in which case the new state is &lt;code&gt;negate x&lt;/code&gt;”&lt;/p&gt;
&lt;p&gt;What the monad instance does is that it allows you to “chain” forks, and go along different forks, and gather together “all possible forks” you could have taken. At the end, it outputs all possible forks. So if you did &lt;code&gt;foo &amp;gt;&amp;gt; foo&lt;/code&gt;, there’d be nine results — one result for when you took the first route (the &lt;code&gt;x+1&lt;/code&gt;) twice, one for when you took the first and then the second (&lt;code&gt;x-1&lt;/code&gt;), one for when you took the first and the third….and the second and the first…etc., etc.&lt;/p&gt;
&lt;h3 id=&quot;monadplus&quot;&gt;MonadPlus&lt;/h3&gt;
&lt;p&gt;One other tool we have at our disposal is &lt;code&gt;guard&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;guard ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; [] ()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is a &lt;code&gt;StateT&lt;/code&gt; action that says “kill this current branch if given &lt;code&gt;False&lt;/code&gt;, or go on if given &lt;code&gt;True&lt;/code&gt;”&lt;/p&gt;
&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;
&lt;p&gt;The problem, as stated, was to find distinct digits for each letter to solve:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    S E N D
+   M O R E
-----------
  M O N E Y&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So &lt;code&gt;SEND&lt;/code&gt; is a four-digit number, &lt;code&gt;MORE&lt;/code&gt; is a four-digit number, and &lt;code&gt;MONEY&lt;/code&gt; is a five-digit number that is the sum of the two. The first digit of &lt;code&gt;MONEY&lt;/code&gt; has to be the first digit of &lt;code&gt;MORE&lt;/code&gt;, the last digit of &lt;code&gt;MORE&lt;/code&gt; has to be the second digit of &lt;code&gt;SEND&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;The previous approach was done using the entire “pick from all possibilities…except for the ones already chosen”, using &lt;code&gt;(/=)&lt;/code&gt; and filtering over all of the things seen vs all of the things to pick from.&lt;/p&gt;
&lt;p&gt;However, we can abstract over “picking dependently from a sample” by defining a function called &lt;code&gt;select&lt;/code&gt;, which really should be in the base libraries but isn’t for some reason:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/send-more-money.hs#L7-9&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;select ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [(a, [a])]
select []     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; []
select (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (x,xs) &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; [(y,x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ys) &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; (y,ys) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; select xs]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Implementation thanks to Cale, who has fought valiantly yet fruitlessly to get this into base for many years.)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;select&lt;/code&gt; will take a list &lt;code&gt;[a]&lt;/code&gt; and return a list of different “selected” &lt;code&gt;a&lt;/code&gt;s, with the rest of the list, too:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; select &lt;span class=&quot;st&quot;&gt;&amp;quot;abcd&amp;quot;&lt;/span&gt;
[(&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;bcd&amp;quot;&lt;/span&gt;),(&lt;span class=&quot;ch&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;acd&amp;quot;&lt;/span&gt;),(&lt;span class=&quot;ch&quot;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;abd&amp;quot;&lt;/span&gt;),(&lt;span class=&quot;ch&quot;&gt;&amp;#39;d&amp;#39;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;)]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But, hey…does the type signature of &lt;code&gt;select&lt;/code&gt; look like anything familiar?&lt;/p&gt;
&lt;p&gt;It looks &lt;em&gt;exactly&lt;/em&gt; like something that &lt;code&gt;StateT&lt;/code&gt; is supposed to describe! Give an initial state (&lt;code&gt;[a]&lt;/code&gt;), and returns a list of all possible ways to “mutate” that state (by removing one element from the state), and a result from each mutation (the removed element).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; select ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; [a] [] a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And armed with this…we have all we need&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/send-more-money.hs#L3-35&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad&lt;/span&gt;             (guard, mfilter)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad.Trans.State&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.List&lt;/span&gt;                 (foldl&amp;#39;)

&lt;span class=&quot;ot&quot;&gt;asNumber ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
asNumber &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; foldl&amp;#39; (\t o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; t&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; o) &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; print &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; flip evalStateT [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    s &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    e &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    n &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    d &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    m &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    o &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    r &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; s &lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; m &lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; send  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [s,e,n,d]
        more  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [m,o,r,e]
        money &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [m,o,n,e,y]
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; send &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; more &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; money
    return (send, more, money)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember, &lt;code&gt;StateT&lt;/code&gt; here operates with an underlying state of &lt;code&gt;[Int]&lt;/code&gt;, a list of numbers not yet picked. &lt;code&gt;StateT select&lt;/code&gt; picks one of these numbers, and modifies the state to now only include the items that were not picked. So every time you sequence &lt;code&gt;StateT select&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt; draws from a smaller and smaller pool of numbers, and makes the state list smaller and smaller. What sequencing &lt;code&gt;StateT&lt;/code&gt; does is allow us to explore &lt;em&gt;all&lt;/em&gt; of the possible ways we could pick and modify state, all at once. Using &lt;code&gt;guard&lt;/code&gt;, we then “close off” and kill off the paths that don’t end up how we’d like.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;asNumber&lt;/code&gt; takes a list like &lt;code&gt;[1,2,3]&lt;/code&gt; and turns it into the number &lt;code&gt;123&lt;/code&gt;; credit to the source blog.&lt;/p&gt;
&lt;p&gt;And, to test it out…&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;ghc&lt;/span&gt; -O2 send-more-money.hs
$ &lt;span class=&quot;kw&quot;&gt;./send-more-money&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# [(9567,1085,10652)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It returns the one and only solution, &lt;code&gt;SEND = 9567&lt;/code&gt;, &lt;code&gt;MORE = 1085&lt;/code&gt;, and &lt;code&gt;MONEY = 10652&lt;/code&gt;.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We can make things a little bit more efficient with minimal cost in expressiveness. But not that it matters…the original version runs fast already.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/send-more-money.hs#L38-59&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;select&amp;#39; ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [(a,[a])]
select&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go []
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
   go xs [] &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; []
   go xs (y&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ys) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (y,xs&lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt;ys) &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; go (y&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) ys

&lt;span class=&quot;ot&quot;&gt;main&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; print &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; flip evalStateT [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    s &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; mfilter (&lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    m &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; mfilter (&lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    e &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    n &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    d &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    o &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    r &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select&amp;#39;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; send  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [s,e,n,d]
        more  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [m,o,r,e]
        money &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; asNumber [m,o,n,e,y]
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; send &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; more &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; money
    return (send, more, money)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a more performant version of &lt;code&gt;select&lt;/code&gt; &lt;a href=&quot;http://chimera.labs.oreilly.com/books/1230000000929/pr01.html&quot;&gt;courtesy of Simon Marlow&lt;/a&gt; that doesn’t preserve the order of the “rest of the elements”.&lt;/p&gt;
&lt;p&gt;Also, we use &lt;code&gt;mfilter&lt;/code&gt; to “eliminate bad &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt;s” right off the bat, before having to pick any more things. &lt;code&gt;mfilter&lt;/code&gt; can be thought of as “killing the fork immediately” if the action doesn’t satisfy the predicate. If the &lt;code&gt;s&lt;/code&gt; picked doesn’t match &lt;code&gt;(/= 0)&lt;/code&gt;, then the entire branch/fork is immediately ruled invalid.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;By the way, isn’t it neat that it does all of this in “constant space”? It just keeps track of the output list, but the actual search processes is in constant space. You don’t need to keep track of all &lt;code&gt;10!&lt;/code&gt; combinations in memory at once. Hooray laziness!&lt;/p&gt;
&lt;h2 id=&quot;other-applications&quot;&gt;Other Applications&lt;/h2&gt;
&lt;p&gt;Using &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;StateT&lt;/code&gt;, we can do a lot of things involving picking from a sample, or permutations. Anything that you used to awkwardly do by using filter not-equal-to’s can work now. You can do things like drawing from a deck:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;pokerGame ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Ordering&lt;/span&gt;]
pokerGame &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; flip evalStateT [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;51&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    p2Hand &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; replicateM &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select)
    p1Hand &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; replicateM &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select)
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; pokerCompare p1Hand p2Hand&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which would draw five distinct cards from a deck of &lt;code&gt;[0..51]&lt;/code&gt;, and return who won for each draw (assuming you had a suitable &lt;code&gt;pokerCompare :: [Card] -&amp;gt; [Card] -&amp;gt; Ordering&lt;/code&gt;). Note that if you use &lt;code&gt;runStateT&lt;/code&gt;, you’d get the results (the winner), &lt;em&gt;as well as&lt;/em&gt; the leftover cards in the deck for each path!&lt;/p&gt;
&lt;!-- I used to have an example here about simulating russian roulette --&gt;
&lt;!-- But this doesn&#39;t really work in a useful way...because the paths all &quot;stop&quot; --&gt;
&lt;!-- after the first shot.  In reality, you are just as likely to be shot on the --&gt;
&lt;!-- first pull as you are on the second.  But as this simulation runs, it &quot;stops&quot; --&gt;
&lt;!-- after the first shot...so `1` will only show up once. --&gt;
&lt;p&gt;You can even combine the two sorts of drawings — sampling independently (like rolling dice) using &lt;code&gt;lift&lt;/code&gt;, and drawing from an underlying deck. For example, you might encode some game logic from a board game like monopoly:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;combo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; flip evalStateT initialDeck &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    roll &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; lift [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;]
    draw &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;StateT&lt;/span&gt; select
    &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Whenever you want a dice roll, use &lt;code&gt;lift [1..6]&lt;/code&gt;…and whenever you want to draw from the deck, use &lt;code&gt;StateT select&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What you get in the end, remember, is a list of “all possible paths”. You’ll get a list of every possible result from all of your different rolling and drawing choices.&lt;/p&gt;
&lt;p&gt;Happy Haskelling!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;For some reason this runs pretty slowly if you use &lt;code&gt;runghc&lt;/code&gt;/&lt;code&gt;runHaskell&lt;/code&gt;, but it runs in the blink of an eye when you actually compile it (and especially with optimizations on). The difference is pretty striking…and I don’t really know what’s going on here, to be honest. If anyone does know a good explanation, I’d love to hear it :)&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Tutorials</category><guid isPermaLink="true">https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.html</guid><pubDate>Fri, 24 Apr 2015 18:05:56 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Tutorials</dc:subject><dc:date>2015-04-24</dc:date></item><item><title>Auto: Building a Declarative Chatbot with Implicit Serialization</title><link>https://blog.jle.im/entry/auto-building-a-declarative-chatbot-with-implicit-serialization.html</link><description>&lt;p&gt;Today we’re going to continue along with the &lt;a href=&quot;http://blog.jle.im/entries/series/+all-about-auto&quot;&gt;All About Auto&lt;/a&gt; introduction series and look at building a declarative chatbot using the denotational components from the &lt;a href=&quot;http://hackage.haskell.org/package/auto&quot;&gt;auto&lt;/a&gt; library that is modular and has implicit serialization. Most importantly, we’ll look at the “design process”, and principles of architecture that you can apply to your own projects.&lt;/p&gt;
&lt;p&gt;This post assumes &lt;em&gt;some&lt;/em&gt; concepts from the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;tutorial&lt;/a&gt;, or at least my &lt;a href=&quot;http://blog.jle.im/entry/introducing-the-auto-library&quot;&gt;last post&lt;/a&gt; or the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/README.md&quot;&gt;README&lt;/a&gt;. If some of these ideas seem completely new, than looking through the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;tutorial&lt;/a&gt; or the &lt;a href=&quot;http://hackage.haskell.org/package/auto&quot;&gt;docs&lt;/a&gt; might refresh your mind…feel free to also leave a comment, stop by &lt;em&gt;#haskell-auto&lt;/em&gt; on freenode where I go by &lt;em&gt;jle`&lt;/em&gt;, or &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;tweet me&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;All of the code in this tutorial can be &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs&quot;&gt;downloaded and run&lt;/a&gt; using &lt;code&gt;runghc&lt;/code&gt; (with the appropriate dependencies installed). Feel free to play along!&lt;/p&gt;
&lt;h2 id=&quot;overall-layout&quot;&gt;Overall Layout&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;auto&lt;/em&gt; is a library that at the highest level gives you a stream transformer on streams of values. Transform a stream of input values to a stream of output values. So when we approach a chat bot, we have to think — what are the inputs, and what are the outputs?&lt;/p&gt;
&lt;p&gt;The choice should be pretty straightforward – our input stream is a stream of input messages from the irc server, and our output stream is a stream of messages to send to the server. In haskell we like types, so let’s make some types.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- first, our imports&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L25-43&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto.Blip&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto.Collection&lt;/span&gt;  (mux)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto.Run&lt;/span&gt;         (runOnChanM)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto.Serialize&lt;/span&gt;   (serializing&amp;#39;)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Auto.Switch&lt;/span&gt;      (resetOn)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Concurrent&lt;/span&gt;       (&lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt;, newChan, writeChan, forkIO, threadDelay)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad&lt;/span&gt;            (void, forever)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Control.Monad.IO.Class&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Foldable&lt;/span&gt;            (forM_)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Map&lt;/span&gt;                 (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Serialize&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Text&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;hiding&lt;/span&gt;         (words, unwords, map)
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Text.Encoding&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Text.Encoding.Error&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Time&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Network.SimpleIRC&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Prelude&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;hiding&lt;/span&gt;           ((.), id)   &lt;span class=&quot;co&quot;&gt;-- we use (.) and id from `Control.Category`&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import qualified&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Data.Map&lt;/span&gt;       &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;M&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L51-66&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; { _&lt;span class=&quot;ot&quot;&gt;inMessageNick   ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;
                           , _&lt;span class=&quot;ot&quot;&gt;inMessageBody   ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;
                           , _&lt;span class=&quot;ot&quot;&gt;inMessageSource ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt;
                           , _&lt;span class=&quot;ot&quot;&gt;inMessageTime   ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;
                           } &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;]) &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monoid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    mempty  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; M.empty
    mappend (&lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; m1) (&lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; m2)
            &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; (M.unionWith (&lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt;) m1 m2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We make some type aliases to make things a bit clearer. Our inputs are going to be a data type/“struct” with a nick, a body, a source, and a time. Our outputs are going to be a &lt;code&gt;Data.Map.Map&lt;/code&gt; from &lt;em&gt;containers&lt;/em&gt; associating channels with messages to send. I’m just adding here a &lt;code&gt;Monoid&lt;/code&gt; instance in case we want to combine &lt;code&gt;OutMessages&lt;/code&gt; maps.&lt;/p&gt;
&lt;p&gt;The type for a chat bot over a monad &lt;code&gt;m&lt;/code&gt; would then be:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L68-68&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;ChatBot&lt;/code&gt; takes a stream of &lt;code&gt;InMessage&lt;/code&gt;s and returns a stream of &lt;code&gt;OutMessages&lt;/code&gt;s…and might have effects in &lt;code&gt;m&lt;/code&gt; as it does so.&lt;/p&gt;
&lt;p&gt;Note that we get a free instance of &lt;code&gt;Monoid&lt;/code&gt; on &lt;code&gt;ChatBot m&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;mappend ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That takes two &lt;code&gt;ChatBot&lt;/code&gt;s and creates a new &lt;code&gt;ChatBot&lt;/code&gt; that forks the input stream (sends all &lt;code&gt;InMessage&lt;/code&gt;s) to both of the original ones, and &lt;code&gt;mappend&lt;/code&gt;s the results. So the new &lt;code&gt;ChatBot&lt;/code&gt; will send message to both original ones and return a “combined” &lt;code&gt;OutMessages&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, not all modules really have to “care” about the room of the outputs…they might just always reply directly to the room they received the message on. So it’ll help us to also make another sort of &lt;code&gt;Auto&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L69-69&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;RoomBot&lt;/code&gt; doesn’t care where its messages go…it just replies to the same room it got its input from. It outputs a blip stream of message lists; when it doesn’t want to send messages out, it doesn’t emit. When it does, it &lt;em&gt;does&lt;/em&gt; emit, with the list of messages.&lt;/p&gt;
&lt;p&gt;(Remember, a &lt;em&gt;blip stream&lt;/em&gt; is just like a normal stream of values, except it only actually &lt;em&gt;has&lt;/em&gt; a value every once in a while, when it “emits”. A &lt;code&gt;Blip Bool&lt;/code&gt; is a stream that sometimes, occasionally emits with a &lt;code&gt;Bool&lt;/code&gt;. We work with them using combinators and &lt;code&gt;Auto&lt;/code&gt;s from &lt;a href=&quot;http://hackage.haskell.org/package/auto/docs/Control-Auto-Blip.html&quot;&gt;&lt;code&gt;Control.Auto.Blip&lt;/code&gt;&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id=&quot;converting&quot;&gt;Converting&lt;/h3&gt;
&lt;p&gt;We can write a quick helper function to convert a &lt;code&gt;RoomBot&lt;/code&gt; into a full-on &lt;code&gt;ChatBot&lt;/code&gt;, so we can merge them together with &lt;code&gt;mappend&lt;/code&gt;/&lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L72-75&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;perRoom ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
perRoom rb &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc inp&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; _ _ src _) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    messages &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; fromBlips [] &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; rb &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp
    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; M.singleton src messages&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(This example uses proc notation; see this &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md#brief-primer-on-proc-notation&quot;&gt;proc notation primer&lt;/a&gt; for a quick run-down of the relevant aspects)&lt;/p&gt;
&lt;p&gt;We say that &lt;code&gt;messages&lt;/code&gt; is just the output of &lt;code&gt;rb&lt;/code&gt; fed with the input, except it “collapses” the blip stream into a normal stream by substituting in &lt;code&gt;[]&lt;/code&gt; whenever the stream doesn’t emit. So &lt;code&gt;messages&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt; when &lt;code&gt;rb&lt;/code&gt; doesn’t emit (it doesn’t want to send anything), and &lt;code&gt;messages&lt;/code&gt; is &lt;code&gt;[message1, message2 ...]&lt;/code&gt;, with the emitted contents, when it &lt;em&gt;does&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The “output” will be a singleton map with the source of the input and the messages to send to that source.&lt;/p&gt;
&lt;p&gt;So now if we have a &lt;code&gt;RoomBot m&lt;/code&gt;, we can convert it up into a &lt;code&gt;ChatBot m&lt;/code&gt;, and combine it/merge it with other &lt;code&gt;ChatBot m&lt;/code&gt;s.&lt;/p&gt;
&lt;h3 id=&quot;the-whole-deal&quot;&gt;The whole deal&lt;/h3&gt;
&lt;p&gt;We have enough now then to imagine our entire program architecture:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Write a bunch of separate modules, as &lt;code&gt;ChatBot m&lt;/code&gt;s or &lt;code&gt;RoomBot m&lt;/code&gt;s, which ever one is more convenient. The beauty is that we can merge them all together in the end with our promoter.&lt;/li&gt;
&lt;li&gt;Combine all of our modules with &lt;code&gt;mconcat&lt;/code&gt; — that is, something like &lt;code&gt;chatBot = mconcat [module1, module2, module3, module 4]&lt;/code&gt;. And that’s it, that’s our entire chat bot!&lt;/li&gt;
&lt;li&gt;Having an overall &lt;code&gt;chatBot :: ChatBot m&lt;/code&gt;, we can use something like &lt;code&gt;runOnChan&lt;/code&gt; from &lt;code&gt;Control.Auto.Run&lt;/code&gt; to have it exist on a concurrent thread and watch a channel for input, and perform an action on output.&lt;/li&gt;
&lt;li&gt;Find an out-of-the-box irc library that can trigger adding something to a concurrent queue when it receives a message, and where you can send messages to rooms.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And…that’s it. Program logic in our &lt;code&gt;ChatBot m&lt;/code&gt;s, and handling the “view”/input with our backend.&lt;/p&gt;
&lt;h4 id=&quot;free-serialization&quot;&gt;Free Serialization&lt;/h4&gt;
&lt;p&gt;Remember that &lt;em&gt;auto&lt;/em&gt; gives us the ability to serialize and resume our &lt;code&gt;Auto&lt;/code&gt;s for free…so we can at any time save the state of our chat bot to disk, and resume it when we re-load. We don’t have to worry about manually gathering our state between each &lt;code&gt;Auto&lt;/code&gt; and writing serialization code.&lt;/p&gt;
&lt;p&gt;There’s a “convenience combinator” called &lt;code&gt;serializing&#39;&lt;/code&gt; in &lt;code&gt;Control.Auto.Serialize&lt;/code&gt; (it’s one of many different ones that can do something like this; &lt;a href=&quot;http://hackage.haskell.org/package/auto/docs/Control-Auto-Serialize.html&quot;&gt;check out the module&lt;/a&gt; to see other ways of varying disciplined-ness!). It’ll take any &lt;code&gt;Auto&lt;/code&gt; and turn it into an &lt;code&gt;Auto&lt;/code&gt; that “self-serializes” — when you begin running it, it automatically loads its previous state if it exists, and as you run it, it automatically maintains an updated “resume state” on disk.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;serializing&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; FilePath &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;serializing&#39; fp :: MonadIO m =&amp;gt; ChatBot m -&amp;gt; ChatBot m&lt;/code&gt;. It looks a lot like an “identity-ish” sort of function, right? That’s because it is meant to behave &lt;em&gt;like&lt;/em&gt; &lt;code&gt;id&lt;/code&gt;…the returned &lt;code&gt;ChatBot&lt;/code&gt; behaves identical to the previous one…except it splices in the serializing action in-between. (We are in &lt;code&gt;MonadIO&lt;/code&gt; now, because the &lt;code&gt;Auto&lt;/code&gt; has to access &lt;code&gt;IO&lt;/code&gt; in order to serialize itself between steps).&lt;/p&gt;
&lt;p&gt;So, instead of&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;chatBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
chatBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mconcat [module1, module2, module3]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can do:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;chatBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
chatBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;state.dat&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; mconcat [module1, module2, module3]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now our &lt;code&gt;chatBot&lt;/code&gt; will automatically resume itself on program startup, and keep its state backed up on disk at &lt;code&gt;state.dat&lt;/code&gt;. We get this for free, without doing anything extra in the composition of our modules.&lt;/p&gt;
&lt;p&gt;Note that in practice, with a bot you are actively developing, this might not be the best idea. &lt;code&gt;serializing&#39;&lt;/code&gt; &lt;em&gt;analyzes&lt;/em&gt; your &lt;code&gt;Auto&lt;/code&gt;s to determine a serialization and reloading strategy, and applies that to do its job. However, if you, for example, add a new module to your chat bot…the serialization strategy will change, and your new bot won’t be able to resume old save files.&lt;/p&gt;
&lt;p&gt;One solution at this point is just to serialize individual modules that you do not see yourself changing…or even just serializing parts of the modules you don’t see yourself changing. Then you can change each portion separately and not worry about migration issues.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;chatBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
chatBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mconcat [ serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;m1.dat&amp;quot;&lt;/span&gt; module1
                  , module2
                  , serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;m3.dat&amp;quot;&lt;/span&gt; module3
                  ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We’re not all-or-nothing now here, either! So, &lt;code&gt;module1&lt;/code&gt; gets serialized and auto-resumed from &lt;code&gt;m1.dat&lt;/code&gt;, &lt;code&gt;module2&lt;/code&gt; is not serialized at all, and &lt;code&gt;module3&lt;/code&gt; now gets serialized and auto-resumed from &lt;code&gt;m3.dat&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;irc-backend-the-ugly-part&quot;&gt;IRC Backend (the ugly part)&lt;/h2&gt;
&lt;p&gt;Before we get started on our actual modules, let’s just write out the backend/interface between our &lt;code&gt;ChatBot&lt;/code&gt; and irc to get it out of the way. This will vary based on what library you use; I’m going to use the &lt;a href=&quot;http://hackage.haskell.org/package/simpleirc-0.3.0&quot;&gt;simpleirc-0.3.0&lt;/a&gt;, but feel free to use any interface/library you want.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L45-228&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;withIrcConf ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IrcConfig&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
withIrcConf ircconf chatbot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;-- chan to receive `InMessage`s&lt;/span&gt;
    inputChan &lt;span class=&quot;ot&quot;&gt;&amp;lt;- newChan ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt;)

    &lt;span class=&quot;co&quot;&gt;-- configuring IRC&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; events   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; cEvents ircconf &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; [ &lt;span class=&quot;dt&quot;&gt;Privmsg&lt;/span&gt; (onMessage inputChan) ]
        ircconf&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ircconf { cEvents &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; events }

    &lt;span class=&quot;co&quot;&gt;-- connect; simplified for demonstration purposes&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; server &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; connect ircconf&amp;#39; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;-- run `chatbot` on `inputChan`&lt;/span&gt;
    void &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; forkIO &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; void &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;
        runOnChanM id (processOutput server) inputChan chatbot

  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- what to do when `chatBot` outputs&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    processOutput ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MIrc&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
    processOutput server (&lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; outs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
      print outs
      _ &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; flip M.traverseWithKey outs &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \channel messages &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; channel&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; encodeUtf8 &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; pack &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; channel
        forM_ messages &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \message &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; message&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; encodeUtf8 &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; pack &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; message
          sendMsg server channel&amp;#39; message&amp;#39;
      return &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- &amp;quot;yes, continue on&amp;quot;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;-- what to do when you get a new message&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    onMessage ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;EventFunc&lt;/span&gt;
    onMessage inputChan &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \_ message &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; (mNick message, mOrigin message) &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; src) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
          time &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getCurrentTime
          writeChan inputChan &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; (unpack (decodeUtf8 nick))
                                          (unpack (decodeUtf8 (mMsg message)))
                                          (unpack (decodeUtf8 src))
                                          time

&lt;span class=&quot;ot&quot;&gt;channels ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt;]
channels &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&amp;quot;#testchan1&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;#testchan2&amp;quot;&lt;/span&gt;]

&lt;span class=&quot;ot&quot;&gt;conf ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IrcConfig&lt;/span&gt;
conf &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (mkDefaultConfig &lt;span class=&quot;st&quot;&gt;&amp;quot;myserver&amp;quot;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;mynick&amp;quot;&lt;/span&gt;) { cChannels &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; channels }

&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    withIrcConf conf chatBot
    forever (threadDelay &lt;span class=&quot;dv&quot;&gt;1000000000&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That should be it…don’t worry if you don’t understand all of it, most of it is just implementation details from &lt;code&gt;simpleirc&lt;/code&gt;. The overall loop is &lt;code&gt;runOnChanM&lt;/code&gt; waits on a separate thread for &lt;code&gt;inputChan&lt;/code&gt;…when it gets input, it runs it through &lt;code&gt;ChatBot&lt;/code&gt; and sends the outputs through &lt;em&gt;simpleirc&lt;/em&gt;’s interface. Meanwhile, &lt;code&gt;onMessage&lt;/code&gt; is triggered whenever &lt;em&gt;simpleirc&lt;/em&gt; receives a message, where it prepares an &lt;code&gt;InMessage&lt;/code&gt; and drops it off at &lt;code&gt;inputChan&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;runOnChanM ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m
           &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (forall c&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; m c &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; c)   &lt;span class=&quot;co&quot;&gt;-- convert `m` to `IO`&lt;/span&gt;
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;)            &lt;span class=&quot;co&quot;&gt;-- handle output&lt;/span&gt;
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt; a                    &lt;span class=&quot;co&quot;&gt;-- chan to await input on&lt;/span&gt;
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a b                &lt;span class=&quot;co&quot;&gt;-- `Auto` to run&lt;/span&gt;
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;runOnChanM&lt;/code&gt; runs any &lt;code&gt;Auto m a b&lt;/code&gt;, as long as there’s a way to convert it to &lt;code&gt;Auto IO a b&lt;/code&gt; (we can use a &lt;code&gt;ChatBot IO&lt;/code&gt;, so we just put &lt;code&gt;id&lt;/code&gt; there). You give it a “handler” &lt;code&gt;b -&amp;gt; IO Bool&lt;/code&gt; that it run whenever it outputs; if the handler returns &lt;code&gt;False&lt;/code&gt;, then the whole thing stops. You give it the &lt;code&gt;Chan a&lt;/code&gt; to await for input &lt;code&gt;a&lt;/code&gt;s on, and it takes care of the rest. It blocks until the handler returns &lt;code&gt;False&lt;/code&gt;, where it’ll return the “updated” &lt;code&gt;Auto m a b&lt;/code&gt; with updated state after running through all of those inputs.&lt;/p&gt;
&lt;p&gt;Phew. With that out of the way, let’s get right on to the fun part — building our chat bot modules.&lt;/p&gt;
&lt;h2 id=&quot;the-modules&quot;&gt;The Modules&lt;/h2&gt;
&lt;h3 id=&quot;seenbot&quot;&gt;seenBot&lt;/h3&gt;
&lt;p&gt;What’s a common module? Well, we can write a module that keeps track of the last time any user was “seen” (sent a message), and then respond when there is a query.&lt;/p&gt;
&lt;p&gt;There are two components here…the part that keeps track of the last seen time, and the part that responds to queries.&lt;/p&gt;
&lt;p&gt;Keeping track of our last seen time sounds like a job that takes in a stream of &lt;code&gt;(Nick, UTCTime)&lt;/code&gt; pairs and outputs a stream of &lt;code&gt;Map Nick UTCTime&lt;/code&gt;, where we could look up the last seen time for a nick by looking up the nick in the map.&lt;/p&gt;
&lt;p&gt;Logically, this is pretty straightforward, and anything other than &lt;code&gt;accum&lt;/code&gt; (which is like &lt;code&gt;foldl&#39;&lt;/code&gt;) would really be a bit overkill; every input would just update the output map.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;trackSeens ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;)
trackSeens &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; accum (\mp (nick, time) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insert nick time mp) M.empty&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;accum&lt;/code&gt; takes the same thing that &lt;code&gt;foldl&lt;/code&gt; takes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;foldl&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt;            (b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b
&lt;span class=&quot;ot&quot;&gt;accum ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So it basically “folds up” the entire history of inputs, with a starting value. Every time an input comes, the output is the new folded history of inputs. You can sort of think of it as it applying the function to any incoming values to an internal accumulator and updating it at every step.&lt;/p&gt;
&lt;p&gt;By the way, because &lt;code&gt;trackSeens&lt;/code&gt; is self-serializing, we need a &lt;code&gt;Serialize&lt;/code&gt; instance for &lt;code&gt;UTCTime&lt;/code&gt;…just for the sake of demonstration, let’s make one now. Let’s also write a &lt;code&gt;Serialize&lt;/code&gt; instance for &lt;code&gt;Day&lt;/code&gt; (which represents a date) too, while we’re at it.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L230-236&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Serialize&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    get &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; read &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; get      &lt;span class=&quot;co&quot;&gt;-- haha don&amp;#39;t do this in real life.&lt;/span&gt;
    put &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; put &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; show

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Serialize&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    get &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ModifiedJulianDay&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; get
    put &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; put &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; toModifiedJulianDay&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The next component is just to respond to requests. We want to do something on some “triggering” input. Every once in a while, some input will come that will “trigger” some special response. This is a sign that we can use &lt;em&gt;blip streams&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@seen&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
    getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;queryBlips&lt;/code&gt; takes an input stream of strings and turns it into an output &lt;em&gt;blip stream&lt;/em&gt; that emits with a &lt;code&gt;Nick&lt;/code&gt; whenever the input stream contains a request in the form of &lt;code&gt;&amp;quot;@seen [nick]&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With these simple blocks, we can build our &lt;code&gt;seenBot&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- seenBot :: Monad m =&amp;gt; Auto m InMessage (Blip [Message])&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L96-115&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;seenBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m
seenBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc (&lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; nick msg _ time) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    seens  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; trackSeens &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (nick, time)

    queryB &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; queryBlips &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; msg

    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; respond ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;]
        respond qry &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; M.lookup qry seens &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                        &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [qry &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; last seen at &amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; show t &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;]
                        &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&amp;quot;No record of &amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; qry &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;]

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; respond &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; queryB
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    trackSeens ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;)
    trackSeens &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; accum (\mp (nick, time) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insert nick time mp) M.empty
&lt;span class=&quot;ot&quot;&gt;    queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
    queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@seen&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
        getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we define &lt;code&gt;respond&lt;/code&gt; as a function that takes a &lt;code&gt;Nick&lt;/code&gt; and returns the output &lt;code&gt;[Message]&lt;/code&gt;. We could have also defined it outside as a helper function &lt;code&gt;respond :: Map Nick UTCTime -&amp;gt; Nick -&amp;gt; [Message]&lt;/code&gt;…but &lt;code&gt;seens&lt;/code&gt; is already in scope, so we might as well just do it there.&lt;/p&gt;
&lt;p&gt;For our output, we use the &lt;code&gt;Functor&lt;/code&gt; instance of blip streams. &lt;code&gt;respond &amp;lt;$&amp;gt; queryB&lt;/code&gt; is a blip stream that emits whenever &lt;code&gt;queryB&lt;/code&gt; emits (so, whenever there is a query input), but replaces the emitted value with the result of the function on the value. So whenever &lt;code&gt;queryB&lt;/code&gt; emits, this whole thing emits with &lt;code&gt;respond&lt;/code&gt; applied to whatever &lt;code&gt;Nick&lt;/code&gt; was emitted — in this case, our &lt;code&gt;[Message]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Short, sweet, simple. In fact, &lt;code&gt;trackSeens&lt;/code&gt; and &lt;code&gt;queryBlips&lt;/code&gt; are small enough that their definition could really have been inlined. Breaking them down just allowed us to look at them individually for this tutorial.&lt;/p&gt;
&lt;p&gt;So that’s it for that; also, if we wanted &lt;code&gt;seenBot&lt;/code&gt; to serialize and persist across sessions, all we have to do is use:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;seenbot.dat&amp;quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; seenBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat, right?&lt;/p&gt;
&lt;p&gt;If we forsee ourselves adding more features to &lt;code&gt;seenBot&lt;/code&gt;, we can future-proof our &lt;code&gt;seenBot&lt;/code&gt; for now by only serializing &lt;code&gt;trackSeens&lt;/code&gt;, meaning replacing that line with:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;    seens &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;seen.dat&amp;quot;&lt;/span&gt; trackSeens &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (nick, time)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember, &lt;code&gt;serializing&#39; fp&lt;/code&gt; acts as a sort of “identity”, so you can drop it in anywhere and you’d expect it to behave the same.&lt;/p&gt;
&lt;h3 id=&quot;repbot&quot;&gt;repBot&lt;/h3&gt;
&lt;p&gt;Another common bot is a “reputation bot”, which allows users to increment or decrement another user’s reputation scores, and look up a user’s total score.&lt;/p&gt;
&lt;p&gt;Again there are two components — keeping track of the scores of all of the users, and responding to requests.&lt;/p&gt;
&lt;p&gt;This time though, our “score updates” only happen every once in a while, triggered by certain words in the message. Again, this pattern calls for a blip stream:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;updateBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;))
updateBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts getUpdateCommand
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- updater is the person triggering the update blip&lt;/span&gt;
    getUpdateCommand (updater, msg) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; words msg &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&amp;quot;@addRep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_ &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; nick &lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; updater &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (nick, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
        &lt;span class=&quot;st&quot;&gt;&amp;quot;@subRep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_                   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (nick, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
        _                                  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;updateBlips&lt;/code&gt; takes in a stream of &lt;code&gt;(Nick, Message)&lt;/code&gt;, with the person who is sending the message and their message, and outputs a blip stream that and emits with a &lt;code&gt;(Nick, Int)&lt;/code&gt; whenever the message is a command. The emitted &lt;code&gt;(Nick, Int)&lt;/code&gt; has the person to adjust, and the amount to adjust by. Note that we ignore commands where the person is trying to increase their own reputation because that’s just lame.&lt;/p&gt;
&lt;p&gt;We probably want to keep track of the scores as a &lt;code&gt;Map Nick Int&lt;/code&gt;, so we can do that with something like &lt;code&gt;accum&lt;/code&gt; again. However, &lt;code&gt;accum&lt;/code&gt; takes a stream of normal values, but we have a &lt;em&gt;blip stream&lt;/em&gt;, so we can use &lt;code&gt;scanB&lt;/code&gt; instead. &lt;code&gt;scanB&lt;/code&gt; is pretty much the same thing, but it collapses a blip stream into a value stream by holding the “current result” of the fold.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;trackReps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
trackReps &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp (nick, change) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick change mp) M.empty&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And finally, the “response” portion — we want to be able to respond to commands and look up the result. We basically had this identical pattern for &lt;code&gt;seenBot&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@rep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
    getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…now we can wrap it all together with a nice proc block:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- repBot :: Monad m =&amp;gt; Auto m InMessage (Blip [Message])&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L117-147&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;repBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m
repBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc (&lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; nick msg _ _) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    updateB &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; updateBlips &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (nick, msg)

    reps    &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; trackReps   &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; updateB

    queryB  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; queryBlips  &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; msg

    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lookupRep ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;]
        lookupRep nick &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [nick &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; has a reputation of &amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; show rep &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;]
          &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
            rep &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; M.findWithDefault &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; nick reps

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; lookupRep &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; queryB
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    updateBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;))
    updateBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts getUpdateCommand
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- updater is the person triggering the update blip&lt;/span&gt;
        getUpdateCommand (updater, msg) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; words msg &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&amp;quot;@addRep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_ &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; nick &lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; updater &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (nick, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
            &lt;span class=&quot;st&quot;&gt;&amp;quot;@subRep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_                   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (nick, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
            _                                  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    trackReps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
    trackReps &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp (nick, change) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick change mp) M.empty
&lt;span class=&quot;ot&quot;&gt;    queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
    queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@rep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
        getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Again note that we take advantage of the &lt;code&gt;Functor&lt;/code&gt; instance of blip streams to create a new blip stream (&lt;code&gt;lookupRep &amp;lt;$&amp;gt; queryB&lt;/code&gt;) that emits whenever &lt;code&gt;queryB&lt;/code&gt; emits, but replaces the value with &lt;code&gt;lookupRep&lt;/code&gt; applied to whatever &lt;code&gt;Nick&lt;/code&gt; was in the query blip. We also take advantage that &lt;code&gt;reps&lt;/code&gt; is in scope and define &lt;code&gt;lookupRep&lt;/code&gt; right there in the block.&lt;/p&gt;
&lt;h3 id=&quot;announcebot&quot;&gt;announceBot&lt;/h3&gt;
&lt;p&gt;Let’s just go over one more module…and I think you’ll be able to use your imagination to think of and implement your own from here.&lt;/p&gt;
&lt;p&gt;Let’s make an “announceBot”, that listens for “announcement” messages from anyone (even in private messages) and broadcasts them to all of the channels in the provided list. It rate-limits the announcements, though, so that a user is only limited to three announcements per day.&lt;/p&gt;
&lt;p&gt;We can start with our typical “blip stream that emits on a certain command” to start off everything:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;announceBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;])
announceBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts getAnnounces
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    getAnnounces (nick, msg) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; words msg &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&amp;quot;@ann&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ann &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; [nick &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; says \&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; unwords ann &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;\&amp;quot;.&amp;quot;&lt;/span&gt;]
        _          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;announceBlips&lt;/code&gt; takes in a nick-message pair and emits an announcement &lt;code&gt;[Message]&lt;/code&gt; whenever the incoming message is an announcement command.&lt;/p&gt;
&lt;p&gt;Next, we’d like to keep track of how many times a user has made an announcement today. This is pretty much just &lt;code&gt;scanB&lt;/code&gt; again like with &lt;code&gt;repBot&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;trackAnns ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
trackAnns &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp nick &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; mp) M.empty&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, we’d like to be able to “reset” this map whenever a new day arrives. For that, we can use &lt;code&gt;resetOn&lt;/code&gt; from &lt;a href=&quot;http://hackage.haskell.org/package/auto/docs/Control-Auto-Switch.html&quot;&gt;&lt;code&gt;Control.Auto.Switch&lt;/code&gt;&lt;/a&gt;, which takes an &lt;code&gt;Auto&lt;/code&gt; and gives it a “reset channel” input blip stream, that resets the whole thing whenever the blip stream emits:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;resetOn ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (a        , &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; c) b
resetOn&lt;span class=&quot;ot&quot;&gt; trackAnns ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt;     &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; c) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(It doesn’t care about the actual value emitted, so we can leave it as a type variable &lt;code&gt;c&lt;/code&gt; conceptually.)&lt;/p&gt;
&lt;p&gt;Now the only thing we need is a blip stream that emits whenever there is a new day. For that, we can use &lt;code&gt;onChange&lt;/code&gt; from &lt;a href=&quot;http://hackage.haskell.org/package/auto/docs/Control-Auto-Blip.html&quot;&gt;&lt;code&gt;Control.Auto.Blip&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;newDayBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt;)
newDayBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onChange&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;newDayBlips&lt;/code&gt; takes in a stream of &lt;code&gt;Day&lt;/code&gt;s (from &lt;code&gt;Data.Time&lt;/code&gt;) that we get from the &lt;code&gt;InMessage&lt;/code&gt; and outputs a blip stream that emits whenever the day changes. It emits with the new &lt;code&gt;Day&lt;/code&gt;…but we don’t really care about the emitted value, we’re just using it to trigger &lt;code&gt;resetOn trackAnns&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Finally, let’s wrap it all together!&lt;/p&gt;
&lt;p&gt;Remember, &lt;code&gt;announceBot&lt;/code&gt; is a full on &lt;code&gt;ChatBot m&lt;/code&gt;, and not a &lt;code&gt;RoomBot m&lt;/code&gt; anymore, so it has to say where it wants to send its messages.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- announceBot :: Monad m =&amp;gt; [Channel] -&amp;gt; Auto m InMessage OutMessages&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L149-183&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;announceBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
announceBot chans &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc (&lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; nick msg src time) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    announceB &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; announceBlips     &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (nick, msg)

    newDayB   &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; newDayBlips       &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; utctDay time

    annCounts &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; resetOn trackAnns &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (nick &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&lt;/span&gt; announceB, newDayB)

    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; hasFlooded  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; M.findWithDefault &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; nick annCounts &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;        targetChans ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt;]
        targetChans &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; hasFlooded &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [src]
                    &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; chans

&lt;span class=&quot;ot&quot;&gt;        outB        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;]
        outB        &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; hasFlooded &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [nick &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;: No flooding!&amp;quot;&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&lt;/span&gt; announceB
                    &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; announceB

&lt;span class=&quot;ot&quot;&gt;        outMsgsB    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt;
        outMsgsB    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (\out &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; (M.fromList (map (,out) targetChans)))
                  &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; outB

    fromBlips mempty &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; outMsgsB
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    announceBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;])
    announceBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts getAnnounces
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getAnnounces (nick, msg) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; words msg &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&amp;quot;@ann&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ann &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; [nick &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; says \&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; unwords ann &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;\&amp;quot;.&amp;quot;&lt;/span&gt;]
            _          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    newDayBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt;)
    newDayBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onChange
&lt;span class=&quot;ot&quot;&gt;    trackAnns ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
    trackAnns &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp nick &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; mp) M.empty&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Only slightly more involved, but still pretty readable, right? We find out if things have flooded, and our target channels will be just the original source if true (a message as a reprimand); otherwise, all the channels in &lt;code&gt;chans&lt;/code&gt;. If they have flooded, then our &lt;code&gt;outB&lt;/code&gt; (blip stream of &lt;code&gt;[Message]&lt;/code&gt; to send to each room) will just be &lt;code&gt;[&amp;quot;No flooding!&amp;quot;]&lt;/code&gt; if yes, or the actual announcement otherwise.&lt;/p&gt;
&lt;p&gt;Finally, our &lt;code&gt;Blip OutMessages&lt;/code&gt; will be the &lt;code&gt;OutMessage&lt;/code&gt; formed by associating all of the channels in &lt;code&gt;targetChans&lt;/code&gt; with the message in &lt;code&gt;outB&lt;/code&gt;…emitting whenever &lt;code&gt;outB&lt;/code&gt; emits.&lt;/p&gt;
&lt;p&gt;Note here that we use &lt;code&gt;(&amp;lt;$)&lt;/code&gt; from the &lt;code&gt;Functor&lt;/code&gt; instance of blip streams. &lt;code&gt;x &amp;lt;$ fooB&lt;/code&gt; is a new blip stream that emits whenever &lt;code&gt;fooB&lt;/code&gt; emits…but instead &lt;em&gt;replaces the emitted value&lt;/em&gt;. So for &lt;code&gt;4 &amp;lt;$ fooB&lt;/code&gt;, if &lt;code&gt;fooB&lt;/code&gt; emits with &lt;code&gt;&amp;quot;hello&amp;quot;&lt;/code&gt;, &lt;code&gt;4 &amp;lt;$ fooB&lt;/code&gt; emits with &lt;code&gt;4&lt;/code&gt;. “Emit at the same time, but pry out the value and put in your own.”&lt;/p&gt;
&lt;p&gt;Finally we use &lt;code&gt;fromBlips&lt;/code&gt;, which we met before in the definition of &lt;code&gt;perRoom&lt;/code&gt;: the output is the &lt;code&gt;OutMessage&lt;/code&gt; in &lt;code&gt;outMsgsB&lt;/code&gt; whenever &lt;code&gt;outMsgsB&lt;/code&gt; &lt;em&gt;does&lt;/em&gt; emit…or it’s &lt;code&gt;mempty&lt;/code&gt; (the empty map) when it doesn’t.&lt;/p&gt;
&lt;h2 id=&quot;wrapping-it-all-up&quot;&gt;Wrapping it all up&lt;/h2&gt;
&lt;p&gt;We have three nice modules now. Now let’s wrap it all together.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L83-88&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;chatBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
chatBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;chatbot.dat&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; mconcat &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; [ perRoom seenBot
                    , perRoom repBot
                    , announceBot channels
                    ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or, to future-proof, in case we foresee adding new modules:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L90-94&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;chatBot&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
chatBot&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mconcat [ perRoom &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;seens.dat&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; seenBot
                   , perRoom &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;reps.dat&amp;quot;&lt;/span&gt;  &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; repBot
                   ,           serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;anns.dat&amp;quot;&lt;/span&gt;  &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; announceBot channels
                   ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…that’s it!&lt;/p&gt;
&lt;p&gt;Feel free to &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs&quot;&gt;download and run this all yourself&lt;/a&gt; using &lt;code&gt;runghc&lt;/code&gt;! (provided you have the appropriate libraries installed)&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This is a quick diversion! It’s slightly more advanced, so don’t worry if you don’t understand it immediately.&lt;/p&gt;
&lt;p&gt;Note that the &lt;code&gt;perRoom&lt;/code&gt; upgrade has the same &lt;code&gt;RoomBot m&lt;/code&gt; watch &lt;em&gt;all&lt;/em&gt; of the channels and send any replies back to the channel that it just received from. Every channel is really interacting with the &lt;em&gt;same&lt;/em&gt; &lt;code&gt;RoomBot&lt;/code&gt; instance, with one shared state. So &lt;code&gt;perRoom repBot&lt;/code&gt; keeps track of reputations between rooms — asking for someone’s reputation in one room will be the same as asking for it in another room.&lt;/p&gt;
&lt;p&gt;Another way we could “upgrade” a &lt;code&gt;RoomBot&lt;/code&gt; is to give each channel its own little copy, with separate state. We can do this using &lt;code&gt;mux&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L78-81&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;isolatedRooms ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
isolatedRooms rb &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc inp&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; _ _ src _) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    messages &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; fromBlips [] &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; mux (const rb) &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (src, inp)
    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; M.singleton src messages&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;mux&lt;/code&gt; is an “&lt;code&gt;Auto&lt;/code&gt; multiplexer”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;mux ::&lt;/span&gt; (k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (k, a) b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;mux f&lt;/code&gt; associates a separate/different &lt;code&gt;Auto&lt;/code&gt;, with its own isolated state, with every key &lt;code&gt;k&lt;/code&gt;. It takes in a stream of key-input pairs &lt;code&gt;(k, a)&lt;/code&gt; and feeds the &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;Auto&lt;/code&gt; it has associated with that key &lt;code&gt;k&lt;/code&gt;. The function &lt;code&gt;f&lt;/code&gt; is what &lt;code&gt;Auto&lt;/code&gt; initialize if the &lt;code&gt;k&lt;/code&gt; has not yet been seen before.&lt;/p&gt;
&lt;p&gt;So we feed it a &lt;code&gt;(Channel, InMessage)&lt;/code&gt;, and it feeds in that &lt;code&gt;InMessage&lt;/code&gt; to the &lt;code&gt;RoomBot m&lt;/code&gt; associated with that &lt;code&gt;Channel&lt;/code&gt;…and the output is the &lt;code&gt;Blip [Message]&lt;/code&gt; blip stream that the &lt;code&gt;RoomBot&lt;/code&gt; at that &lt;code&gt;Channel&lt;/code&gt; popped out.&lt;/p&gt;
&lt;p&gt;Our “auto initialization function” is &lt;code&gt;const rb&lt;/code&gt;, because no matter what channel we’re in, we always want to initialize with the same &lt;code&gt;rb&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So, for example, if we had &lt;code&gt;isolatedRooms repBot&lt;/code&gt;, if a message came from channel &lt;em&gt;#foo&lt;/em&gt; saying &lt;code&gt;&amp;quot;@rep john&amp;quot;&lt;/code&gt;, &lt;em&gt;only the &lt;code&gt;repBot&lt;/code&gt; associated with #foo&lt;/em&gt; would get the message, and only that &lt;code&gt;repBot&lt;/code&gt;’s output will be displayed. If here is not yet a &lt;code&gt;repBot&lt;/code&gt; instance associated with &lt;em&gt;#foo&lt;/em&gt;, then a new one will be created by calling &lt;code&gt;const repBot&lt;/code&gt; on &lt;code&gt;&amp;quot;#foo&amp;quot;&lt;/code&gt;…initializing a new &lt;code&gt;repBot&lt;/code&gt; that only knows about &lt;em&gt;#foo&lt;/em&gt; messages.&lt;/p&gt;
&lt;p&gt;So now every channel has its own &lt;code&gt;repBot&lt;/code&gt;, and maintains its own independent reputation database.&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;fin&quot;&gt;Fin&lt;/h2&gt;
&lt;p&gt;Hopefully, going over this project, you’re starting to see some common and powerful idioms and tools. I hope that a clear picture of how to approach and finish a program with the &lt;em&gt;auto&lt;/em&gt; library looks…and how beneficial the platform and what it offers is to streamlining the development process.&lt;/p&gt;
&lt;p&gt;Also, hopefully the “declarative” nature of everything is apparent. Especially for &lt;em&gt;proc&lt;/em&gt; blocks…everything just “looks like” a graph of relationships. This quantity is related to this quantity in this way, this quantity is related to that in that way, etc. It looks like you’re just specifying a graph of relationships, which is really what the core of &lt;em&gt;auto&lt;/em&gt; is all about. We assemble complex relationships by putting together small, simple relationships.&lt;/p&gt;
&lt;p&gt;Another interesting thing is that we never really explicitly managed any sort of state or state type. All of our &lt;code&gt;Auto&lt;/code&gt;s handled their state on their own. We didn’t need to make a giant massive aggregate bulky “global state” type…and we can add new “aspects” of state (new modules) without ever having to change any data type. The state all manages itself!&lt;/p&gt;
&lt;p&gt;And yeah, we didn’t just implement “easy” modules/components…these are actual working components that you might see in real bots, and not just toy ones.&lt;/p&gt;
&lt;p&gt;Where can we go from here? Well, you might actually want to maybe write “subscription” &lt;code&gt;Auto&lt;/code&gt;s that are updated every minute or so:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChronBot&lt;/span&gt; m &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You feed them inputs every minute with the time, and it’s allowed to react with the time and output an &lt;code&gt;OutMessages&lt;/code&gt;. You can use this bot to implement things like rss feed watchers/subscribers, for instance.&lt;/p&gt;
&lt;p&gt;So, instead of using an input channel waiting for &lt;code&gt;InMessage&lt;/code&gt;, you might wait for &lt;code&gt;Either InMessage UTCTime&lt;/code&gt;…and drop in &lt;code&gt;Left im&lt;/code&gt; whenever you get a message, and &lt;code&gt;Right time&lt;/code&gt; from a thread that just waits a minute and repeatedly throws in times.&lt;/p&gt;
&lt;p&gt;We can do this with minimal extra work by using the &lt;code&gt;(|||)&lt;/code&gt; combinator from &lt;code&gt;Control.Arrow&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;(|||) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a c &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m b c &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; a         b      ) c
&lt;span class=&quot;ot&quot;&gt;(|||) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChronBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…you get it all for free! No extra work. Now both the &lt;code&gt;ChatBot&lt;/code&gt; and the &lt;code&gt;ChronBot&lt;/code&gt; will wait on the input stream, and the &lt;code&gt;Left&lt;/code&gt;s will be fed to the &lt;code&gt;ChatBot&lt;/code&gt; and the &lt;code&gt;Right&lt;/code&gt;s will be fed to the &lt;code&gt;ChronBot&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Anyway, this post is long enough. Have fun exploring &lt;em&gt;auto&lt;/em&gt; on your own; expect more tutorials soon as I continue the &lt;a href=&quot;http://blog.jle.im/entries/series/+all-about-auto&quot;&gt;All About Auto&lt;/a&gt; series, too. I’m always happy to hear about any project you might be working on! You can find me on twitter as &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;mstk&lt;/a&gt;. If you have any questions or comments/suggestions, feel free to leave a comment down below or drop by freenode’s &lt;em&gt;#haskell-auto&lt;/em&gt; or &lt;em&gt;#haskell-game&lt;/em&gt;, where I go by &lt;em&gt;jle`&lt;/em&gt;! And, as always, happy Haskelling!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;&lt;code&gt;scanB f x0 :: Auto m (Blip a) b&lt;/code&gt;, but there’s also &lt;code&gt;accumB f x0 :: Auto m a (Blip a) (Blip b)&lt;/code&gt;, which emits whenever the input emits only.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Auto</category><category>Tutorials</category><guid isPermaLink="true">https://blog.jle.im/entry/auto-building-a-declarative-chatbot-with-implicit-serialization.html</guid><pubDate>Wed, 25 Mar 2015 17:20:17 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Auto, Tutorials</dc:subject><dc:date>2015-03-25</dc:date></item><item><title>Introducing: the Auto library!</title><link>https://blog.jle.im/entry/introducing-the-auto-library.html</link><description>&lt;p&gt;&lt;strong&gt;Auto&lt;/strong&gt;: &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/README.md&quot;&gt;README&lt;/a&gt; (with examples) / &lt;a href=&quot;http://hackage.haskell.org/package/auto&quot;&gt;hackage&lt;/a&gt; / &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;tutorial&lt;/a&gt; / &lt;a href=&quot;https://github.com/mstksg/auto-examples&quot;&gt;examples&lt;/a&gt; / &lt;a href=&quot;https://github.com/mstksg/auto&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(Before anything, maybe take a quick look at the detailed description in the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/README.md&quot;&gt;README&lt;/a&gt; for a quick motivating example and explanation of the library)&lt;/p&gt;
&lt;p&gt;Today I’m announcing and beginning promotion of my &lt;em&gt;auto&lt;/em&gt; library, a denotative and locally stateful programming DSL and platform, now &lt;a href=&quot;http://hackage.haskell.org/package/auto&quot;&gt;on hackage&lt;/a&gt;. &lt;em&gt;auto&lt;/em&gt; is suitable when your program involves an input or output that is a discrete stream of things — events, views, etc., like turn based games, GUI’s, numerical computations…; it allows you to state (possibly cyclic) complex relationships between streams of values by composing simple, primitive ones. You can read the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/README.md&quot;&gt;README&lt;/a&gt; too for a detailed buzz-word laden exposition with nice well-commented short demos and examples, get started with &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;the tutorial&lt;/a&gt;, check out the directory of &lt;a href=&quot;https://github.com/mstksg/auto-examples&quot;&gt;sample projects&lt;/a&gt;, and even see a live running &lt;a href=&quot;http://mstksg.github.io/auto-examples/todo/&quot;&gt;todoMVC&lt;/a&gt; (&lt;a href=&quot;https://github.com/mstksg/auto-examples/blob/master/src/Todo.hs&quot;&gt;source&lt;/a&gt;) example!&lt;/p&gt;
&lt;p&gt;Over the next week or two I’m going to be breaking down real-world projects written on &lt;em&gt;auto&lt;/em&gt;, and even be talking about the design processes of programs written using &lt;em&gt;auto&lt;/em&gt;. You can follow along on &lt;a href=&quot;http://blog.jle.im/entries/series/+all-about-auto&quot;&gt;the series page&lt;/a&gt;, follow me on &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;twitter&lt;/a&gt;, or just subscribe to the &lt;a href=&quot;http://blog.jle.im/rss&quot;&gt;rss feed&lt;/a&gt; feed; expect a post on designing, from start to finish,&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;A fully running chat bot&lt;/li&gt;
&lt;li&gt;A GUI-based todo app on ghcjs&lt;/li&gt;
&lt;li&gt;A text-based adventure game a la the classic &lt;a href=&quot;http://en.wikipedia.org/wiki/Rogue_%28video_game%29&quot;&gt;rogue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A numerical computation DSL&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But enough of that…what is &lt;em&gt;auto&lt;/em&gt;, why does it exist, and what are its design principles?&lt;/p&gt;
&lt;h2 id=&quot;auto&quot;&gt;Auto&lt;/h2&gt;
&lt;h3 id=&quot;on-state&quot;&gt;on State&lt;/h3&gt;
&lt;p&gt;I designed &lt;em&gt;auto&lt;/em&gt; because there really aren’t any good solutions in Haskell for declaratively describing locally stateful programs in a compositional way. And a lack of denotational semantics to reason with them.&lt;/p&gt;
&lt;p&gt;The go-to implementation for a turn-based game is to have a “giant state monad”. It is a clever “hack”, but really, all we’ve done is began programming a game with &lt;em&gt;global mutable state&lt;/em&gt;. People have tried getting over this by using lenses and zoomers, but this processes doesn’t quite scale.&lt;/p&gt;
&lt;p&gt;Even now many games, GUI’s, numerical computations, etc. are written as folds or state compositions over a giant state. Surely there is a better way?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;auto&lt;/em&gt; provides denotational semantics for the composition and transformation of &lt;em&gt;stream transformers&lt;/em&gt;. At a high level, it is an example of “locally stateful programming”. Each component and stream transformer really operates as its own entity, separate from the world, in a composable way. Typical programs involve building a (possibly cyclic) graph of &lt;em&gt;relationships&lt;/em&gt; between quantities over a stream.&lt;/p&gt;
&lt;p&gt;Composing two transformers side-by-side or end-to-end creates a new transformer…and the state of each trasnformer is “closed off” from the other and the rest of the world.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;sumAndProduct &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    sums  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; sumFrom &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x
    prods &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; productFrom &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; x
    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; sums &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; prods&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;sumFrom 0&lt;/code&gt; denotes a relationship between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;sums&lt;/code&gt; such that &lt;code&gt;sums&lt;/code&gt; is the cumulative sum of all &lt;code&gt;x&lt;/code&gt;’s seen. &lt;code&gt;productFrom 1&lt;/code&gt; denotes a relationship between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;prods&lt;/code&gt; that &lt;code&gt;prods&lt;/code&gt; is the cumulative product of all &lt;code&gt;x&lt;/code&gt;s seen. With &lt;code&gt;sumAndProduct&lt;/code&gt;, we &lt;em&gt;built&lt;/em&gt; a new relationship — the output is the sum of the cumulative sum and the cumulative product of the inputs — by composing two primitives.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- running our Autos over the stream [1..10] to get a new stream&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; streamAuto&amp;#39; (sumFrom &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;]
[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;21&lt;/span&gt;,  &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;36&lt;/span&gt;,    &lt;span class=&quot;dv&quot;&gt;45&lt;/span&gt;,     &lt;span class=&quot;dv&quot;&gt;55&lt;/span&gt;]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; streamAuto&amp;#39; (productFrom &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;]
[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;120&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;720&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5040&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;40320&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;362880&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3628800&lt;/span&gt;]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; streamAuto&amp;#39; sumAndProduct [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;]
[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;34&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;135&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;741&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5068&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;40356&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;362925&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3628855&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each of them maintain their own “state”…and even &lt;code&gt;sumAndProduct&lt;/code&gt; will maintain its own internal state as you compose it with other things.&lt;/p&gt;
&lt;p&gt;You build complex programs. For games, you might have an enemy monster, or a player character…why should a player character’s update be able to access the state of the enemy monster? Why should the enemy monster be able to access the state of the player? Now, the enemy monster’s state is only accessible to the enemy monster itself…nobody else can touch it.&lt;/p&gt;
&lt;p&gt;In my opinion, this really is the only sane way to have stateful loops. Separate out your update into the composition of primitives, and describe it using denotative, pure &lt;em&gt;relationships&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&quot;on-architecture&quot;&gt;on Architecture&lt;/h2&gt;
&lt;p&gt;Using &lt;em&gt;auto&lt;/em&gt;, your entire program is structured as a stream transformer, built from the composition of smaller primitives, and using the various combinators and semantic streams of the library.&lt;/p&gt;
&lt;p&gt;In the end, “running” it is simply gathering the input one at a time, pushing it through, and acting on the result.&lt;/p&gt;
&lt;p&gt;For example, in the &lt;a href=&quot;http://mstksg.github.io/auto-examples/todo/&quot;&gt;todo example&lt;/a&gt;, the entire application is just one &lt;code&gt;Auto&lt;/code&gt; that takes a stream of input commands and outputs a stream of output GUI views. It’s launch so that the &lt;code&gt;Auto&lt;/code&gt; waits on a &lt;code&gt;Chan&lt;/code&gt; queue to consume inputs as they come in. All the javascript front-end has to do is render the output gui view, and hook up the DOM elements to trigger events that add new inputs to the queue. That’s it!&lt;/p&gt;
&lt;p&gt;How do we build that &lt;code&gt;Auto&lt;/code&gt;? By composing smaller, simpler ones. Each denoting their own relationship, each keeping track of their state locally. The “full GUI state” never &lt;em&gt;exists&lt;/em&gt; anywhere…it is aggregated during composition.&lt;/p&gt;
&lt;p&gt;By the way, &lt;em&gt;auto&lt;/em&gt; does allow you to take “snap shots” of the actual states of &lt;code&gt;Auto&lt;/code&gt;s as they are run, as a binary…so you can serialize, freeze, and resume &lt;code&gt;Auto&lt;/code&gt;s from any previous state at-will. Free undos, &lt;em&gt;free save states&lt;/em&gt;. And this serialization &lt;strong&gt;composes&lt;/strong&gt;, so the combination of two serialized &lt;code&gt;Auto&lt;/code&gt;s with internal state will also be serialized appropriately.&lt;/p&gt;
&lt;h3 id=&quot;on-comparisons&quot;&gt;on Comparisons&lt;/h3&gt;
&lt;p&gt;Throughout its development &lt;em&gt;auto&lt;/em&gt; has been compared to FRP libraries like netwire. A full address of this comparison is offered on &lt;a href=&quot;https://github.com/mstksg/auto#relation-to-frp&quot;&gt;the readme&lt;/a&gt;. The main difference is that FRP offers an expressive language for working with, manipulating, and transforming continuous-time behaviors. &lt;em&gt;auto&lt;/em&gt; borrows some aspects of FRP as well as some practical API aspects in order to build something separate, manipulating and transforming causal (discrete) streams. There are many situations where FRP is not quite suited — it’d be like using a vector art program to describe a bitmap. There are domains where &lt;em&gt;auto&lt;/em&gt; is not suited — that is, the semantic model doesn’t allow you to say anything meaningful about continuous time behaviors.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;auto&lt;/em&gt; has also been compared to pipes and conduit, but there are some major differences in design and philosophy. pipes is a more general-purpose co-routine library with an emphasis on being able to apply equational reasoning to many different domains. conduit focuses around the problem of effective streaming with resource management. Both work “sources” that come from underlying monads like IO; &lt;em&gt;auto&lt;/em&gt; discourages this except for disciplined exceptions, and it’s definitely not the norm. &lt;em&gt;auto&lt;/em&gt; works as &lt;em&gt;value stream transformers&lt;/em&gt;, working with “pure” one-by-one transformations on streams of &lt;em&gt;values&lt;/em&gt;; pipes and conduit provide &lt;em&gt;effect stream manipulators&lt;/em&gt;, managing streams of &lt;em&gt;effects&lt;/em&gt; in constant space, with resource management, etc…and often involving output effects as a result (“consumers”).&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;on-the-future&quot;&gt;on the Future&lt;/h2&gt;
&lt;p&gt;So, I’ll be using this blog to post complete walk-throughs on designing specific apps like the ones in the &lt;a href=&quot;https://github.com/mstksg/auto-examples&quot;&gt;examples&lt;/a&gt; repo. Along the way hopefully some general design principles will become apparent, too. I’ve been working on this library and have been writing “real world” code for it for almost a year now, so I have some experience with design practices and patterns that work and don’t work.&lt;/p&gt;
&lt;p&gt;For now, you can try reading over the &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md&quot;&gt;tutorial&lt;/a&gt; if you want, or peruse the &lt;a href=&quot;https://github.com/mstksg/auto-examples&quot;&gt;examples&lt;/a&gt; repo!&lt;/p&gt;
&lt;p&gt;Also, I definitely welcome any criticism on the design of the library or the semantic model, or of its use cases. I’ve been more or less working on this alone for almost a year, so now is the time for any delusions of mine to be vetted out in public!&lt;/p&gt;
&lt;h3 id=&quot;on-support&quot;&gt;on Support&lt;/h3&gt;
&lt;p&gt;For now, the official support channel is &lt;em&gt;#haskell-auto&lt;/em&gt; on freenode (I’m &lt;em&gt;jle`&lt;/em&gt;), but you can always use the &lt;a href=&quot;https://github.com/mstksg/issues&quot;&gt;issue tracker&lt;/a&gt; too, &lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
h=&#39;&amp;#106;&amp;#108;&amp;#x65;&amp;#46;&amp;#x69;&amp;#x6d;&#39;;a=&#39;&amp;#64;&#39;;n=&#39;&amp;#106;&amp;#x75;&amp;#x73;&amp;#116;&amp;#x69;&amp;#110;&#39;;e=n+a+h;
document.write(&#39;&lt;a h&#39;+&#39;ref&#39;+&#39;=&quot;ma&#39;+&#39;ilto&#39;+&#39;:&#39;+e+&#39;&quot; clas&#39;+&#39;s=&quot;em&#39; + &#39;ail&quot;&gt;&#39;+&#39;&amp;#x65;&amp;#x6d;&amp;#x61;&amp;#x69;&amp;#108;&amp;#32;&amp;#x6d;&amp;#x65;&#39;+&#39;&lt;\/&#39;+&#39;a&#39;+&#39;&gt;&#39;);
// --&gt;
&lt;/script&gt;&lt;noscript&gt;&amp;#x65;&amp;#x6d;&amp;#x61;&amp;#x69;&amp;#108;&amp;#32;&amp;#x6d;&amp;#x65;&amp;#32;&amp;#40;&amp;#106;&amp;#x75;&amp;#x73;&amp;#116;&amp;#x69;&amp;#110;&amp;#32;&amp;#x61;&amp;#116;&amp;#32;&amp;#106;&amp;#108;&amp;#x65;&amp;#32;&amp;#100;&amp;#x6f;&amp;#116;&amp;#32;&amp;#x69;&amp;#x6d;&amp;#x29;&lt;/noscript&gt;, or find me on twitter as &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;mstk&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All this being said, &lt;em&gt;auto&lt;/em&gt; is still kind of technically in a sorta pre-release state, because not all of the tests are written yet. But the API should be stable and updates before &lt;code&gt;0.3.x&lt;/code&gt; are going to all be backwards compatible (API-wise) bug fixes or filling in holes.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;One could still use a subset of pipes that does not stream effects, but merely values, and &lt;em&gt;that&lt;/em&gt; does somewhat fill a similar role; this is used in the &lt;a href=&quot;https://hackage.haskell.org/package/mvc&quot;&gt;mvc&lt;/a&gt; library to build similar applications that &lt;em&gt;auto&lt;/em&gt; tries to build. However, due to mvc’s “global state” nature, you lose many of the local statefulness idioms in &lt;em&gt;auto&lt;/em&gt;, and a lot of &lt;em&gt;auto&lt;/em&gt;’s benefits and design philosophies go away, for other reasons as well.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><category>Projects</category><category>Auto</category><guid isPermaLink="true">https://blog.jle.im/entry/introducing-the-auto-library.html</guid><pubDate>Tue, 24 Mar 2015 17:30:57 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings, Projects, Auto</dc:subject><dc:date>2015-03-24</dc:date></item><language>en</language><copyright>Copyright 2016 Justin Le</copyright><managingEditor>justin@jle.im (Justin Le)</managingEditor><webMaster>justin@jle.im (Justin Le)</webMaster><lastBuildDate>Sat, 28 May 2016 23:36:03 UTC</lastBuildDate><generator>feed-0.3.11.1 (Sigbjorn Finne)</generator><image><url>https://blog.jle.im/img/site_logo.jpg</url><title>in Code</title><link>https://blog.jle.im/</link></image><dc:creator>Justin Le</dc:creator><dc:language>en</dc:language><dc:rights>Copyright 2016 Justin Le</dc:rights><dc:date>2016-05-28</dc:date><dc:description>Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge.</dc:description></channel></rss>